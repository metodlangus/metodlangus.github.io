const initSpeed = 3;
const maxSpeed = 10;
const minSpeed = 1.75; 
const stepSpeed = 0.25;
const initQuality = 4;
const SLIDESHOW_HIDDEN = true;
const SLIDESHOW_VISIBLE = false;

let randomizeImages = true; // default ON
let slideshowIndex = 0;
var slideshowTitles = [];
var numberOfSlideshows = [];
var toggleButton;
const imageLoadStatus = new Map();
let activeFullscreenIndex = null; // Track the index of the fullscreen slideshow
let currentSlideshowIndex = 0; // Index of current most visible slideshow
const doubleClickThreshold = 300; // Time in milliseconds to detect a double-click
// SVG path end image with Triglav silhouette
const endImage = {
    type: 'image',
    src: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
    <svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="1800.000000pt" height="1350.000000pt" viewBox="0 0 1800.000000 1350.000000" preserveAspectRatio="xMidYMid meet" >
        <g transform="translate(0.000000,1800.000000) scale(0.135000,-0.135000)" fill="#626262" stroke="none">
        <path d="M5725 12119 c-4 -5 -18 -14 -31 -19 -15 -6 -24 -18 -24 -30 0 -11 -7 -23 -15 -26 -11 -4 -15 -21 -15 -59 0 -57 19 -85 58 -85 11 0 24 -4 27 -10 9 -15 68 -12 106 6 71 32 84 43 87 70 4 27 3 27 -40 19 -78 -14 -120 -11 -132 7 -16 26 6 45 37 31 12 -6 40 -8 62 -4 53 8 57 33 14 77 -28 29 -40 34 -80 34 -26 0 -51 -5 -54 -11z"/>
        <path d="M1710 10986 c0 -28 4 -35 23 -38 20 -3 23 -11 33 -93 24 -196 34 -291 34 -322 0 -33 1 -33 48 -33 l47 0 48 83 c26 45 73 123 102 172 30 50 58 97 63 105 32 62 56 90 77 90 13 0 25 7 28 18 2 9 8 25 12 35 7 16 0 18 -86 15 l-94 -3 -3 -28 c-2 -15 4 -34 13 -43 14 -14 14 -19 2 -38 -8 -11 -36 -59 -62 -106 -73 -129 -74 -130 -95 -130 -21 0 -26 23 -34 178 -5 91 -4 93 20 102 18 7 24 17 24 40 l0 30 -100 0 -100 0 0 -34z"/>
        <path d="M4289 10996 c-7 -14 -9 -36 -5 -50 5 -21 12 -26 36 -26 42 0 60 38 36 75 -21 32 -53 32 -67 1z"/>
        <path d="M2300 10844 c-53 -30 -60 -39 -60 -81 0 -46 34 -78 113 -103 62 -20 67 -24 67 -50 0 -32 -14 -40 -75 -40 -32 0 -51 7 -73 25 -52 43 -78 29 -88 -49 -6 -42 -5 -46 15 -46 12 0 30 5 40 12 15 9 25 9 46 0 36 -17 90 -15 128 4 133 67 112 162 -47 208 -31 9 -42 17 -44 35 -2 13 2 28 10 32 21 14 82 10 104 -6 23 -18 73 -20 79 -2 2 6 6 29 10 50 5 34 4 37 -19 37 -14 0 -28 -4 -31 -10 -3 -5 -17 -10 -30 -10 -13 0 -27 5 -30 10 -11 18 -69 10 -115 -16z"/>
        <path d="M2724 10850 c-82 -36 -146 -150 -129 -229 13 -62 89 -121 154 -121 63 0 152 60 129 88 -14 16 -48 15 -72 -3 -42 -32 -126 -6 -126 39 0 28 29 35 146 38 l119 3 3 40 c3 53 -32 113 -83 142 -48 27 -86 28 -141 3z m99 -59 c14 -6 28 -19 32 -31 11 -36 -11 -50 -80 -50 -79 0 -93 20 -45 62 32 30 53 34 93 19z"/>
        <path d="M3145 10853 c-16 -8 -43 -27 -59 -42 -86 -79 -87 -240 -2 -292 39 -24 61 -24 100 0 42 26 61 15 52 -31 -6 -35 -32 -66 -73 -87 -25 -13 -108 -14 -138 -2 -26 11 -55 -4 -55 -28 0 -14 14 -23 49 -35 67 -22 120 -20 178 5 88 37 121 83 142 196 11 55 28 121 53 206 7 21 20 44 29 51 10 7 23 24 28 39 13 34 3 39 -70 35 -47 -3 -54 -6 -59 -28 -8 -30 -30 -29 -75 6 -37 28 -58 29 -100 7z m127 -86 c36 -45 17 -133 -38 -176 -36 -28 -75 -27 -104 4 -29 31 -31 76 -7 128 36 76 108 98 149 44z"/>
        <path d="M3625 10859 c-11 -5 -33 -13 -48 -19 -24 -8 -26 -13 -17 -30 9 -17 17 -19 70 -13 66 6 110 -12 110 -46 0 -25 -24 -33 -74 -26 -57 9 -146 -25 -169 -64 -25 -42 -22 -93 7 -124 37 -40 68 -43 121 -13 l46 25 9 -24 c9 -23 15 -25 78 -25 67 0 68 0 80 32 6 17 11 32 9 33 -1 0 -14 6 -30 13 -25 11 -27 15 -21 54 4 24 11 51 15 60 16 31 11 114 -8 130 -50 43 -129 60 -178 37z m66 -199 c42 -23 8 -73 -60 -86 -68 -14 -99 49 -38 79 38 19 71 21 98 7z"/>
        <path d="M4196 10839 c-5 -24 -1 -35 15 -48 l22 -17 -22 -100 c-55 -249 -61 -263 -112 -279 -29 -9 -39 -22 -39 -52 0 -19 5 -23 30 -23 77 0 138 62 160 163 5 23 16 71 25 107 23 90 55 241 55 263 0 14 -10 17 -64 17 -63 0 -64 0 -70 -31z"/>
        <path d="M4524 10850 c-82 -36 -146 -150 -129 -229 13 -62 89 -121 154 -121 63 0 152 60 129 88 -14 16 -38 15 -77 -4 -43 -22 -98 -11 -113 21 -21 45 0 54 135 57 l122 3 3 40 c3 53 -32 113 -83 142 -48 27 -86 28 -141 3z m99 -59 c30 -12 44 -46 27 -66 -18 -22 -136 -21 -144 1 -10 27 39 71 81 73 6 1 23 -3 36 -8z"/>
        <path d="M9765 10529 c-27 -10 -69 -19 -91 -19 -24 0 -47 -6 -53 -14 -13 -16 -85 -23 -293 -32 -87 -3 -128 -2 -128 5 0 6 -4 11 -10 11 -5 0 -10 -18 -10 -40 0 -27 -5 -43 -15 -46 -13 -5 -15 -37 -15 -203 1 -181 2 -198 21 -220 11 -13 23 -21 26 -17 4 4 6 38 4 77 -4 100 10 132 66 159 25 12 55 19 66 16 11 -3 33 2 48 10 15 7 52 14 82 14 35 0 59 5 66 14 8 9 40 16 84 20 40 3 106 10 147 15 41 6 83 11 93 11 31 2 33 31 3 57 -15 12 -34 23 -42 23 -8 0 -14 4 -14 8 0 5 -11 14 -25 20 -21 10 -24 15 -16 31 6 10 24 24 41 31 16 7 30 16 30 21 0 4 10 11 23 15 29 8 58 34 51 45 -9 15 -86 8 -139 -12z m-126 -133 c10 -11 7 -17 -11 -30 -45 -32 -120 -11 -104 29 7 20 99 21 115 1z m-193 -52 c13 -52 -66 -84 -106 -44 -22 22 -26 56 -7 63 6 3 33 6 59 6 43 1 48 -1 54 -25z"/>
        <path d="M2662 9907 c-14 -17 -10 -42 12 -66 17 -18 17 -23 1 -93 -43 -193 -65 -260 -93 -283 -16 -14 -23 -29 -20 -45 3 -24 6 -25 77 -25 74 0 75 0 82 30 6 21 4 34 -7 46 -16 18 -14 35 30 214 8 33 21 90 30 128 8 37 18 72 22 78 4 6 0 15 -7 20 -22 14 -115 11 -127 -4z"/>
        <path d="M4347 9913 c-15 -15 -6 -61 14 -75 l21 -14 -26 -99 c-15 -55 -33 -129 -41 -165 -10 -45 -22 -71 -39 -85 -14 -11 -26 -33 -28 -50 l-3 -30 60 -3 c32 -2 69 -1 81 2 28 7 40 51 19 72 -19 19 -19 57 -1 97 8 18 19 61 24 97 6 36 18 94 27 130 9 36 19 80 22 98 l5 32 -64 0 c-36 0 -68 -3 -71 -7z"/>
        <path d="M3927 9849 c-20 -17 -37 -40 -37 -51 0 -13 -10 -24 -30 -31 -25 -9 -30 -17 -30 -44 0 -19 6 -36 16 -41 13 -8 13 -19 -5 -109 -12 -56 -21 -108 -21 -117 0 -26 38 -56 70 -56 32 0 79 18 82 32 4 27 0 33 -27 38 -29 5 -30 7 -27 55 1 27 7 54 12 59 6 6 10 24 10 41 0 37 17 62 45 67 29 5 34 63 5 78 -15 8 -19 17 -15 35 3 14 7 36 10 50 7 34 -12 32 -58 -6z"/>
        <path d="M9135 9800 c-16 -17 -39 -33 -50 -36 -12 -3 -67 -52 -123 -110 -56 -57 -108 -104 -115 -104 -19 0 -447 -434 -447 -453 0 -8 -7 -17 -15 -21 -20 -7 -20 -64 1 -104 12 -24 14 -51 10 -118 -3 -48 -10 -92 -16 -98 -5 -5 -10 -27 -10 -47 0 -21 -4 -41 -10 -44 -5 -3 -18 -25 -28 -48 -10 -23 -26 -48 -35 -56 -10 -7 -17 -22 -17 -32 0 -10 -9 -23 -20 -29 -11 -6 -20 -15 -20 -20 0 -14 -75 -122 -100 -145 -11 -10 -20 -22 -20 -27 0 -5 -18 -31 -40 -57 -22 -26 -40 -51 -40 -54 0 -4 -12 -20 -28 -35 -15 -15 -37 -43 -49 -62 -12 -20 -33 -46 -47 -59 -14 -14 -26 -30 -26 -36 0 -7 -10 -20 -21 -31 -12 -10 -39 -41 -60 -69 -21 -27 -52 -65 -68 -84 -17 -18 -31 -38 -31 -44 0 -5 -20 -29 -45 -53 -25 -23 -45 -49 -45 -56 0 -8 -20 -34 -45 -58 -25 -24 -45 -50 -45 -57 0 -7 -12 -23 -26 -36 -14 -12 -39 -40 -55 -62 -15 -22 -44 -57 -64 -79 -19 -21 -35 -43 -35 -49 0 -6 -20 -30 -45 -54 -25 -23 -45 -49 -45 -56 0 -7 -20 -33 -45 -57 -25 -24 -45 -50 -45 -57 0 -7 -13 -25 -30 -40 -16 -14 -30 -33 -30 -41 0 -8 -20 -33 -45 -56 -25 -24 -45 -50 -45 -57 0 -8 -13 -26 -30 -39 -16 -14 -29 -32 -30 -41 0 -8 -16 -30 -35 -49 -19 -19 -35 -38 -35 -43 0 -8 -31 -47 -107 -137 -18 -20 -33 -45 -33 -54 0 -9 -7 -19 -15 -22 -8 -4 -15 -13 -15 -21 0 -20 98 66 99 87 1 9 30 45 66 80 36 35 65 70 65 76 0 7 27 41 60 76 33 34 60 68 60 73 0 6 25 35 55 65 30 30 55 59 55 65 0 6 14 24 30 40 17 16 30 34 30 41 0 7 20 32 45 56 24 24 45 48 45 55 0 7 22 36 50 65 27 29 50 57 50 62 0 5 21 33 48 62 92 104 122 141 122 152 0 6 20 30 45 54 24 24 45 48 45 54 0 7 16 29 35 50 19 22 35 42 35 46 0 4 21 32 48 62 81 94 147 176 151 188 2 6 17 24 32 39 16 16 29 34 29 42 0 7 20 33 45 57 25 24 45 48 45 54 0 9 24 37 133 160 26 29 47 58 47 65 0 18 72 87 100 96 22 7 23 6 14 -26 -13 -55 -11 -299 4 -338 7 -18 13 -58 14 -90 2 -455 0 -554 -15 -591 -10 -25 -14 -73 -12 -168 1 -96 -2 -138 -11 -150 -8 -9 -14 -27 -14 -38 0 -21 -71 -98 -120 -130 -14 -9 -38 -30 -55 -45 -47 -45 -145 -113 -200 -140 -27 -13 -53 -28 -56 -33 -4 -4 -28 -10 -55 -13 -27 -2 -58 -8 -69 -13 -11 -5 -56 -12 -100 -15 -133 -8 -144 -10 -157 -23 -6 -6 -24 -12 -38 -12 -19 0 -40 -15 -73 -51 -47 -51 -47 -52 -45 -112 4 -84 14 -85 81 -9 30 34 35 46 28 61 -19 35 11 59 86 66 63 6 306 8 591 4 64 -1 141 1 170 6 46 7 52 10 52 31 0 34 -33 48 -94 39 -28 -3 -58 -7 -66 -7 -8 -1 -24 -7 -35 -14 -40 -28 -125 -11 -125 24 0 18 128 152 146 152 5 0 25 16 44 35 19 19 42 35 51 35 9 0 19 6 22 14 7 17 54 26 66 12 5 -6 11 -22 13 -35 4 -35 22 -36 52 -4 29 31 35 87 12 118 -18 25 -5 52 42 88 36 26 37 29 34 85 -2 31 -6 81 -8 109 -5 43 -3 54 10 59 18 7 22 49 5 59 -5 4 -10 35 -11 68 -1 282 -10 451 -23 471 -11 15 -15 52 -15 144 0 88 -4 129 -14 145 -8 13 -13 43 -12 71 2 39 7 53 30 72 15 13 34 24 42 24 8 0 14 8 15 18 1 33 10 67 19 76 15 15 12 62 -5 76 -8 7 -12 17 -9 22 4 5 -3 23 -15 39 -12 16 -21 43 -21 62 0 19 -7 40 -15 47 -11 9 -15 35 -15 108 0 148 10 165 263 420 116 116 217 212 225 212 7 0 46 34 86 75 40 41 80 75 89 75 10 0 25 -9 34 -20 10 -11 22 -20 28 -20 5 0 54 -43 108 -95 53 -52 102 -95 108 -95 6 0 32 -22 59 -50 27 -27 55 -50 62 -50 8 0 29 -16 48 -35 19 -19 39 -35 46 -35 6 0 18 -7 25 -17 16 -18 115 -93 124 -93 3 0 19 -10 35 -22 21 -15 30 -30 30 -49 0 -15 4 -30 9 -33 4 -3 11 -35 13 -71 3 -36 10 -71 16 -78 7 -8 11 -339 14 -970 3 -900 4 -959 21 -968 14 -8 17 -25 17 -99 0 -51 4 -90 10 -90 5 0 10 -33 12 -72 4 -96 22 -94 26 2 1 41 7 84 12 95 5 11 11 45 12 75 3 49 6 55 26 58 33 5 141 -71 231 -163 41 -41 79 -75 85 -75 6 0 38 -27 71 -60 33 -33 65 -60 72 -60 7 0 26 -14 44 -31 17 -16 41 -34 52 -40 12 -5 35 -19 50 -31 26 -21 39 -23 142 -23 108 0 114 1 134 25 27 33 28 80 1 80 -11 0 -20 -6 -20 -14 0 -8 -7 -22 -16 -30 -21 -22 -136 -22 -154 -1 -7 8 -21 15 -31 15 -10 0 -33 13 -51 29 -18 15 -43 32 -56 35 -12 4 -30 18 -38 32 -9 13 -22 24 -29 24 -7 0 -41 27 -75 60 -34 33 -68 60 -74 60 -6 0 -41 29 -76 65 -35 36 -69 65 -75 65 -6 0 -42 31 -80 68 -39 38 -79 72 -89 76 -18 6 -19 18 -12 313 5 169 11 316 16 328 6 16 23 25 67 35 70 16 93 34 93 72 0 25 -3 28 -34 28 -18 0 -39 7 -46 15 -7 8 -21 15 -32 15 -24 0 -58 77 -59 134 -2 207 -11 335 -25 346 -21 19 -21 578 1 586 16 6 95 -66 95 -87 0 -11 55 -73 248 -278 45 -48 82 -92 82 -97 0 -5 47 -56 105 -114 58 -58 105 -111 105 -118 0 -8 47 -61 105 -118 58 -57 105 -109 105 -114 0 -6 54 -66 120 -134 66 -68 120 -127 120 -132 0 -5 65 -74 145 -154 80 -80 145 -149 145 -155 0 -6 61 -71 135 -145 74 -74 138 -144 141 -155 10 -29 246 -265 266 -265 27 0 29 15 8 43 -11 14 -20 32 -20 40 0 8 -7 17 -15 21 -8 3 -15 12 -15 21 0 9 -7 26 -15 39 -9 13 -15 28 -14 32 1 5 1 20 0 33 -1 20 -3 22 -16 11 -13 -11 -20 -9 -43 13 -16 15 -33 27 -39 27 -13 0 -413 401 -413 415 0 6 -54 64 -120 130 -66 66 -120 124 -120 130 0 6 -54 64 -120 130 -66 66 -120 126 -120 133 0 7 -40 53 -90 103 -49 49 -90 93 -90 99 0 6 -54 66 -120 134 -66 68 -120 127 -120 131 0 5 -39 51 -87 102 -209 222 -243 260 -243 272 0 6 -20 32 -45 58 -25 25 -45 51 -45 58 0 7 -7 18 -15 25 -8 7 -15 18 -15 24 0 14 -161 176 -175 176 -6 0 -40 29 -75 65 -35 36 -70 65 -76 65 -7 0 -46 34 -88 75 -42 41 -82 75 -89 75 -7 0 -35 23 -62 50 -27 28 -53 50 -59 50 -5 0 -33 21 -62 48 -113 100 -140 119 -175 126 -30 5 -39 2 -64 -24z m-585 -1227 c0 -50 -4 -65 -16 -70 -31 -12 -49 11 -52 65 -2 41 1 55 18 72 33 33 50 11 50 -67z"/>
        <path d="M1824 9745 c-91 -40 -151 -157 -124 -241 17 -54 34 -70 96 -93 50 -19 55 -19 101 -4 50 16 93 48 93 69 0 23 -48 25 -89 3 -26 -13 -48 -18 -63 -14 -51 16 -74 59 -45 83 7 7 66 13 133 14 l119 3 3 37 c4 46 -32 107 -81 137 -39 24 -96 26 -143 6z m121 -71 c9 -9 15 -26 13 -38 -3 -19 -10 -21 -76 -24 -61 -2 -73 0 -79 14 -17 45 104 86 142 48z"/>
        <path d="M2139 9758 c0 -2 -2 -17 -5 -35 -3 -27 0 -32 19 -35 26 -4 27 -20 3 -123 -11 -50 -23 -76 -40 -90 -14 -11 -26 -33 -28 -50 l-3 -30 67 -3 c37 -2 77 2 88 8 24 13 27 52 5 70 -19 16 -18 39 3 119 15 55 22 66 52 82 42 23 73 24 90 5 13 -17 4 -85 -27 -204 -11 -40 -17 -74 -15 -77 3 -3 31 -5 63 -5 55 0 60 2 74 30 20 38 19 39 -11 50 -30 12 -30 15 4 140 15 55 17 80 10 95 -31 60 -71 70 -134 34 -39 -21 -64 -19 -64 6 0 12 -14 15 -75 15 -41 0 -75 -1 -76 -2z"/>
        <path d="M2830 9734 c-13 -34 -13 -44 4 -44 7 0 19 -6 25 -14 10 -12 5 -20 -31 -43 -82 -54 -81 -51 -43 -113 19 -30 35 -59 35 -63 0 -5 9 -22 21 -38 24 -34 67 -39 92 -11 24 27 22 62 -3 62 -20 0 -80 80 -80 107 0 18 91 103 118 109 17 5 22 13 22 40 l0 34 -75 0 c-72 0 -76 -1 -85 -26z"/>
        <path d="M3072 9735 c-17 -36 -15 -45 8 -45 30 0 35 -24 17 -83 -8 -29 -18 -65 -22 -80 -3 -16 -20 -41 -36 -57 -21 -19 -30 -35 -27 -51 3 -23 7 -24 83 -27 66 -2 82 0 92 14 20 27 16 55 -8 61 -20 5 -21 11 -15 59 6 55 33 124 48 124 4 0 8 7 8 15 0 8 -7 15 -16 15 -14 0 -16 7 -11 40 l5 40 -57 0 c-52 0 -59 -2 -69 -25z"/>
        <path d="M3265 9729 c-19 -17 -35 -35 -35 -40 0 -6 88 -2 96 5 1 1 5 16 9 34 6 28 4 32 -14 32 -11 0 -36 -14 -56 -31z"/>
        <path d="M3460 9745 c-23 -8 -35 -19 -35 -31 0 -17 10 -20 79 -24 61 -4 81 -9 90 -22 14 -24 -5 -54 -30 -50 -51 10 -110 2 -152 -20 -39 -20 -48 -31 -59 -66 -15 -54 -2 -97 38 -117 35 -19 57 -19 93 0 39 20 63 19 76 -5 8 -16 21 -20 58 -20 56 0 81 15 84 50 2 19 -2 26 -19 28 -27 4 -28 13 -8 107 25 119 19 141 -49 169 -45 19 -116 19 -166 1z m108 -218 c3 -24 -2 -30 -41 -47 -56 -25 -97 -15 -97 24 0 36 36 57 90 54 41 -3 45 -6 48 -31z"/>
        <path d="M4520 9748 c0 -7 -3 -23 -6 -35 -4 -16 0 -23 15 -28 31 -10 25 -27 -20 -55 -65 -40 -66 -49 -18 -145 46 -92 67 -108 115 -86 18 8 24 19 24 41 0 20 -5 30 -14 30 -15 0 -53 45 -75 88 -11 20 -7 27 36 73 26 28 59 53 74 56 20 4 28 12 31 34 3 16 2 31 0 34 -3 3 -41 5 -84 5 -56 0 -78 -4 -78 -12z"/>
        <path d="M4835 9731 c-70 -40 -91 -67 -105 -133 -20 -102 8 -163 90 -190 155 -51 321 146 235 281 -47 76 -133 92 -220 42z m135 -61 c42 -42 30 -108 -30 -168 -42 -42 -67 -48 -99 -25 -50 38 -34 150 27 201 24 19 79 15 102 -8z"/>
        <path d="M5199 9758 c0 -2 -2 -17 -5 -35 -3 -27 0 -32 19 -35 26 -4 27 -20 3 -123 -11 -50 -23 -76 -40 -90 -14 -11 -26 -33 -28 -50 l-3 -30 67 -3 c37 -2 77 2 88 8 24 13 27 52 5 70 -19 16 -18 39 3 119 15 55 22 66 52 82 42 23 73 24 90 5 13 -17 4 -85 -27 -204 -11 -40 -17 -74 -15 -77 3 -3 31 -5 63 -5 55 0 60 2 74 30 20 38 19 39 -11 50 -30 12 -30 15 5 144 l21 79 -26 34 c-30 40 -65 43 -120 12 -39 -21 -64 -19 -64 6 0 12 -14 15 -75 15 -41 0 -75 -1 -76 -2z"/>
        <path d="M5784 9745 c-91 -40 -151 -157 -124 -241 17 -54 34 -70 96 -93 50 -19 55 -19 101 -4 50 16 93 48 93 69 0 23 -48 25 -89 3 -26 -13 -48 -18 -63 -14 -51 16 -74 59 -45 83 7 7 66 13 133 14 l119 3 3 37 c4 46 -32 107 -81 137 -39 24 -96 26 -143 6z m121 -71 c9 -9 15 -26 13 -38 -3 -19 -9 -21 -77 -21 -85 0 -97 11 -55 50 32 30 93 34 119 9z"/>
        <path d="M6215 9747 c-100 -58 -135 -108 -135 -191 0 -77 30 -119 107 -149 39 -15 47 -16 90 -1 58 19 105 61 101 89 -4 29 -39 29 -71 0 -57 -54 -137 -20 -137 57 0 106 97 174 167 118 53 -41 79 -25 98 58 6 31 5 32 -23 32 -17 0 -32 -6 -35 -12 -3 -10 -11 -10 -39 0 -42 15 -96 15 -123 -1z"/>
        <path d="M8268 8870 c-27 -28 -48 -54 -48 -59 0 -4 -13 -24 -30 -42 -16 -19 -30 -39 -30 -45 0 -5 -13 -23 -30 -39 -16 -16 -30 -33 -30 -38 0 -5 -13 -26 -30 -47 -16 -21 -30 -41 -30 -44 0 -4 -13 -20 -30 -36 -16 -16 -30 -36 -30 -43 0 -8 -9 -22 -20 -32 -11 -10 -20 -22 -20 -28 0 -5 -15 -27 -32 -48 -56 -64 -78 -97 -78 -111 0 -7 -13 -24 -30 -38 -16 -14 -30 -30 -30 -37 0 -7 -13 -28 -30 -46 -16 -19 -30 -39 -30 -44 0 -6 -9 -18 -20 -28 -11 -10 -20 -23 -20 -29 0 -6 -18 -31 -40 -56 -22 -25 -40 -50 -40 -56 0 -7 -7 -14 -15 -18 -8 -3 -15 -14 -15 -24 0 -10 -16 -33 -35 -52 -19 -19 -35 -38 -35 -42 0 -11 -72 -109 -93 -127 -10 -7 -17 -22 -17 -32 0 -10 -6 -22 -12 -26 -17 -10 -88 -116 -88 -130 0 -6 -7 -13 -15 -16 -8 -4 -26 -25 -41 -49 -15 -23 -33 -49 -41 -56 -7 -7 -13 -19 -13 -26 0 -6 -13 -23 -30 -36 -16 -14 -29 -32 -30 -41 0 -9 -9 -24 -20 -34 -11 -10 -20 -23 -20 -30 0 -6 -11 -22 -25 -35 -14 -13 -25 -27 -25 -31 0 -11 -71 -114 -81 -117 -5 -2 -9 -11 -9 -21 0 -9 -13 -29 -28 -44 -16 -15 -39 -49 -52 -75 -13 -26 -30 -53 -37 -60 -14 -15 -18 -42 -5 -42 12 0 72 64 72 77 0 6 20 31 45 55 24 24 45 48 45 54 0 6 13 27 30 45 16 19 30 39 30 45 0 5 14 23 30 39 17 16 30 34 30 40 0 6 14 24 30 40 17 16 30 34 30 40 0 6 14 25 30 43 17 18 30 39 30 46 0 7 9 21 20 31 11 10 20 22 20 28 0 5 15 27 33 48 55 65 77 97 77 111 0 8 14 24 30 36 17 13 30 29 30 36 0 7 13 29 30 47 16 19 30 39 30 45 0 5 14 23 30 39 17 16 30 33 30 38 0 5 14 26 30 47 17 21 30 42 30 48 0 5 7 12 15 16 8 3 15 13 15 23 0 9 14 32 31 49 17 18 36 41 43 52 40 69 120 181 132 186 8 3 14 10 14 15 0 12 117 188 131 197 5 3 9 13 9 22 0 10 14 28 30 42 17 14 30 32 30 41 0 8 14 28 30 44 17 16 30 34 30 40 0 7 9 20 20 30 11 10 20 23 20 30 0 6 11 22 25 35 14 13 25 32 25 42 0 10 7 21 15 24 8 4 15 14 15 23 0 10 14 30 30 46 17 16 30 33 30 38 0 4 11 23 25 41 28 37 31 46 13 46 -7 0 -34 -23 -60 -50z"/>
        <path d="M4841 7257 c-16 -20 -3 -27 54 -27 28 0 55 3 58 7 15 14 -18 33 -58 33 -23 0 -48 -6 -54 -13z"/>
        <path d="M5610 7205 c-4 -5 -7 -21 -6 -35 1 -23 4 -25 56 -25 52 0 55 1 57 27 1 15 -3 31 -9 34 -17 11 -89 10 -98 -1z"/>
        <path d="M6094 7208 c-7 -11 10 -16 86 -23 111 -11 670 -16 670 -6 0 24 -73 30 -403 34 -191 2 -350 0 -353 -5z"/>
        <path d="M7656 7213 c-3 -4 -6 -21 -6 -40 0 -31 2 -33 36 -33 35 0 35 1 32 37 -3 33 -7 38 -30 40 -14 1 -29 -1 -32 -4z"/>
        <path d="M990 7200 c-8 -5 -25 -10 -38 -10 -23 0 -39 -21 -28 -39 4 -6 18 -3 35 7 28 16 31 15 74 -6 25 -12 50 -29 57 -37 17 -21 37 -19 57 5 17 19 30 20 478 20 389 1 463 3 479 15 11 8 40 15 65 15 55 0 43 20 -16 27 -83 10 -1148 13 -1163 3z"/>
        <path d="M2473 7198 c-16 -21 -23 -47 -17 -63 5 -12 29 -15 125 -15 102 0 121 2 126 16 11 28 -25 44 -99 44 -52 0 -70 4 -74 15 -7 18 -48 20 -61 3z"/>
        <path d="M2776 7175 c-17 -18 -17 -19 6 -36 19 -15 45 -19 148 -21 207 -3 228 2 186 41 -23 21 -36 24 -173 28 -134 5 -151 4 -167 -12z"/>
        <path d="M7823 7183 c-10 -3 -10 -9 0 -24 11 -18 25 -19 209 -19 187 0 198 1 198 19 0 14 -10 20 -46 25 -54 7 -343 7 -361 -1z"/>
        <path d="M11505 7173 c-15 -15 -15 -17 2 -33 24 -24 93 -36 93 -17 0 16 -37 51 -62 60 -10 3 -24 -1 -33 -10z"/>
        <path d="M707 7169 c-29 -17 -9 -29 48 -29 58 0 78 13 46 29 -25 14 -71 14 -94 0z"/>
        <path d="M3567 7173 c-4 -3 -7 -12 -7 -20 0 -10 31 -13 145 -13 138 0 145 1 145 20 0 19 -7 20 -138 20 -76 0 -142 -3 -145 -7z"/>
        <path d="M4260 7160 c0 -17 7 -20 50 -20 43 0 50 3 50 20 0 17 -7 20 -50 20 -43 0 -50 -3 -50 -20z"/>
        <path d="M4710 7160 c0 -19 7 -20 119 -20 66 0 122 4 126 9 12 20 -37 31 -139 31 -99 0 -106 -1 -106 -20z"/>
        <path d="M11176 7162 c-15 -18 -15 -20 1 -34 10 -9 28 -19 41 -22 12 -4 22 -12 22 -17 0 -17 54 -9 76 12 30 28 69 17 83 -23 14 -41 35 -30 39 20 2 31 -2 46 -17 61 -19 19 -33 21 -124 21 -88 0 -106 -3 -121 -18z"/>
        <path d="M11044 7157 c-11 -29 0 -102 16 -102 19 0 22 106 3 112 -7 3 -16 -2 -19 -10z"/>
        <path d="M10465 7141 c-3 -5 2 -17 11 -25 13 -14 50 -16 259 -16 226 0 301 8 225 25 -16 4 -32 11 -35 16 -8 12 -452 12 -460 0z"/>
        <path d="M10207 7124 c-16 -16 9 -24 73 -24 66 0 97 11 64 24 -21 8 -129 8 -137 0z"/>
        <path d="M12735 7123 c-38 -2 -79 -8 -90 -13 -11 -5 -31 -10 -45 -12 -17 -2 -25 -9 -25 -23 0 -18 8 -20 62 -23 67 -3 91 -22 78 -62 -10 -33 16 -33 46 1 26 29 27 34 14 49 -13 15 -13 19 8 38 13 12 33 22 45 22 13 0 22 6 22 15 0 9 -8 14 -22 13 -13 -1 -54 -3 -93 -5z"/>
        <path d="M750 7082 c0 -21 29 -32 86 -32 68 0 91 14 49 30 -31 12 -135 13 -135 2z"/>
        <path d="M2756 7074 c-22 -22 -36 -50 -29 -58 3 -3 28 -6 55 -6 54 0 63 17 29 58 -23 26 -34 28 -55 6z"/>
        <path d="M3327 7084 c-9 -9 3 -34 17 -34 6 0 28 -9 49 -20 38 -21 111 -27 122 -11 14 24 -166 86 -188 65z"/>
        <path d="M5345 7073 c-67 -34 -81 -68 -25 -56 25 4 34 0 57 -26 20 -22 36 -31 58 -31 31 0 65 28 65 54 0 18 -33 46 -56 46 -10 0 -28 7 -38 15 -23 17 -22 17 -61 -2z"/>
        <path d="M5924 7076 c-16 -12 -16 -15 -4 -20 65 -21 346 -34 363 -17 6 6 21 11 34 11 16 0 23 6 23 20 0 19 -7 20 -198 20 -156 0 -202 -3 -218 -14z"/>
        <path d="M3577 7073 c-4 -3 -7 -23 -7 -44 0 -34 3 -38 31 -44 36 -8 44 -2 33 22 -4 10 -9 23 -9 28 -6 37 -30 56 -48 38z"/>
        <path d="M4147 7034 c-4 -4 -7 -22 -7 -41 0 -31 2 -33 33 -33 20 0 39 8 50 20 26 31 22 50 -12 50 -16 0 -36 2 -43 5 -8 3 -17 2 -21 -1z"/>
        <path d="M4357 7034 c-16 -16 9 -24 73 -24 66 0 97 11 64 24 -21 8 -129 8 -137 0z"/>
        <path d="M4950 7025 c0 -12 16 -15 80 -15 64 0 80 3 80 15 0 12 -16 15 -80 15 -64 0 -80 -3 -80 -15z"/>
        <path d="M5802 7018 c-7 -7 -12 -23 -12 -36 0 -20 4 -23 33 -20 28 3 32 7 35 36 3 28 0 32 -20 32 -13 0 -29 -5 -36 -12z"/>
        <path d="M6452 6998 l3 -33 103 0 c105 0 128 9 80 33 -16 7 -28 17 -28 23 0 5 -36 9 -81 9 l-80 0 3 -32z"/>
        <path d="M7515 7020 c-3 -5 -21 -10 -39 -10 -58 0 -90 -61 -41 -80 26 -10 68 0 80 19 4 7 53 11 127 11 102 0 128 3 164 21 23 11 48 27 54 35 11 12 -11 14 -163 14 -106 0 -178 -4 -182 -10z"/>
        <path d="M5166 6902 c-3 -3 -1 -11 5 -19 7 -8 34 -13 75 -13 60 0 87 11 63 26 -14 8 -136 14 -143 6z"/>
        <path d="M3398 6838 c-18 -9 -41 -19 -50 -22 -10 -3 -18 -12 -18 -21 0 -12 14 -15 78 -15 66 1 81 4 107 25 36 30 27 42 -37 47 -32 2 -59 -3 -80 -14z"/>
        <path d="M12036 6802 c-7 -11 243 -262 261 -262 30 0 6 31 -111 148 -118 117 -138 132 -150 114z"/>
        <path d="M3132 6763 c-26 -10 2 -23 53 -23 54 0 79 12 49 24 -18 7 -83 7 -102 -1z"/>
        <path d="M2881 6722 c-6 -2 -7 -10 -4 -18 4 -10 23 -14 70 -14 55 0 64 2 61 17 -2 13 -15 17 -60 17 -32 1 -62 0 -67 -2z"/>
        <path d="M814 6671 c-21 -22 60 -29 412 -37 195 -4 222 -3 228 11 3 9 0 18 -7 20 -16 6 -627 11 -633 6z"/>
        <path d="M2588 6649 c-43 -22 -51 -49 -15 -49 21 0 137 56 137 66 0 12 -90 -1 -122 -17z"/>
        <path d="M10115 6631 c-9 -8 -5 -32 8 -45 21 -21 79 -46 107 -46 14 0 35 -7 46 -15 51 -38 173 9 174 68 0 13 -8 17 -40 17 -22 0 -40 -4 -40 -9 0 -5 -13 -12 -30 -16 -16 -4 -30 -11 -30 -16 0 -21 -55 -4 -67 20 -6 13 -20 29 -30 35 -18 10 -90 16 -98 7z"/>
        <path d="M1655 6582 c-2 -3 -2 -9 1 -13 7 -12 141 -11 149 1 3 6 -2 10 -12 11 -93 4 -134 4 -138 1z"/>
        <path d="M2130 6582 c-5 -2 -10 -8 -10 -13 0 -5 34 -9 76 -9 56 0 75 3 71 13 -3 11 -109 18 -137 9z"/>
        <path d="M7225 6480 c-3 -5 -14 -10 -24 -10 -30 0 -80 -51 -107 -109 -14 -31 -37 -70 -50 -88 -13 -17 -24 -36 -24 -41 0 -6 -34 -44 -75 -86 -60 -61 -81 -76 -105 -76 -16 0 -30 -4 -30 -9 0 -5 -9 -13 -20 -16 -22 -7 -28 -52 -10 -85 8 -15 15 -17 41 -10 17 5 43 17 57 26 42 28 127 117 157 164 15 25 40 61 55 80 15 19 30 52 34 73 7 35 64 107 85 107 5 0 20 11 35 25 15 14 33 25 40 25 7 0 21 9 31 20 18 20 17 20 -33 20 -28 0 -54 -4 -57 -10z"/>
        <path d="M11073 6483 c4 -3 26 -10 49 -14 91 -17 141 -29 152 -38 6 -5 34 -12 61 -15 28 -3 84 -10 125 -16 108 -13 131 -20 156 -47 30 -32 42 -23 39 29 -3 58 -2 56 -27 64 -41 14 -62 15 -218 21 -85 2 -159 9 -164 14 -6 5 -48 9 -95 9 -46 0 -81 -3 -78 -7z"/>
        <path d="M11735 6300 c3 -5 37 -10 75 -10 38 0 72 5 75 10 4 6 -23 10 -75 10 -52 0 -79 -4 -75 -10z"/>
        <path d="M11942 6278 c3 -30 6 -33 38 -33 29 0 34 3 32 20 -6 30 -22 45 -49 45 -21 0 -24 -4 -21 -32z"/>
        <path d="M8595 5545 c-109 -53 -109 -66 3 -182 94 -98 136 -157 128 -178 -4 -11 -21 -15 -66 -15 -55 0 -66 -4 -114 -40 -29 -22 -60 -40 -69 -40 -22 0 -31 -17 -37 -70 -4 -37 -9 -46 -27 -48 -24 -4 -28 6 -38 89 -3 31 -12 64 -18 73 -16 22 -109 36 -243 36 -114 0 -164 -13 -218 -55 -32 -24 -64 -18 -103 20 l-36 35 -196 0 -196 0 -48 -46 c-26 -25 -50 -58 -54 -72 -4 -15 -8 -153 -8 -307 l0 -280 38 -77 c44 -88 107 -151 171 -170 44 -13 71 -13 556 -3 231 5 319 10 330 19 29 25 50 25 97 1 27 -14 59 -25 73 -24 14 0 207 4 430 8 343 6 413 10 457 24 51 17 53 17 90 -3 34 -18 56 -20 203 -20 142 0 175 3 227 21 34 11 66 26 72 33 5 6 15 117 22 246 7 129 16 240 21 247 12 16 127 28 140 15 6 -6 14 -64 19 -129 19 -277 60 -358 207 -406 110 -36 439 -40 550 -6 36 10 45 10 68 -6 24 -15 48 -17 238 -12 135 3 225 9 249 18 33 11 44 10 85 -4 40 -15 95 -17 392 -18 527 -1 557 0 616 22 89 34 83 2 84 459 1 402 1 404 -21 434 -21 28 -22 34 -11 98 15 87 15 215 1 257 -7 19 -22 36 -36 42 -13 5 -87 9 -164 9 -127 0 -145 -2 -192 -24 -95 -44 -97 -48 -97 -197 0 -114 2 -130 18 -136 25 -9 52 -34 52 -48 0 -7 -18 -20 -40 -29 l-40 -16 -59 40 c-56 39 -61 40 -141 40 -81 0 -246 -23 -285 -40 -79 -35 -97 -39 -117 -29 -19 10 -20 17 -13 169 l7 158 -25 26 c-26 26 -27 26 -196 26 l-170 0 -60 -40 c-68 -45 -67 -43 -79 -187 -10 -112 -21 -137 -55 -124 -54 21 -137 41 -168 41 -60 0 -63 8 -70 135 -5 109 -7 117 -32 143 l-27 27 -153 0 c-124 -1 -158 -4 -184 -18 -18 -9 -40 -17 -49 -17 -9 0 -32 -11 -50 -25 l-32 -25 -4 -115 c-3 -109 -4 -116 -28 -132 -67 -49 -120 -53 -161 -13 l-31 29 11 95 c6 52 11 128 11 168 0 65 -3 77 -23 96 -22 21 -33 22 -188 22 l-164 0 -57 -37 c-31 -20 -59 -46 -62 -57 -3 -12 -6 -72 -7 -134 l-1 -114 31 -19 c37 -22 52 -51 30 -58 -8 -2 -29 -19 -47 -38 l-34 -33 3 -240 c2 -159 0 -243 -7 -250 -13 -13 -252 16 -271 32 -26 22 -11 48 70 116 138 118 128 98 128 258 0 120 -2 140 -18 156 -14 13 -53 23 -147 35 -87 12 -130 22 -134 31 -3 8 14 32 39 56 41 38 87 88 148 161 68 81 85 127 59 153 -21 21 -179 15 -238 -8 -35 -14 -74 -20 -128 -20 -58 0 -88 5 -117 20 -60 31 -202 28 -270 -5z m678 -19 c9 -7 17 -20 17 -28 0 -15 -122 -161 -170 -203 -18 -17 -39 -21 -127 -23 -66 -3 -114 0 -131 8 -28 12 -195 191 -200 214 -2 7 10 19 26 25 38 16 128 1 205 -33 32 -14 68 -26 80 -26 23 0 83 19 106 34 22 14 123 44 151 45 14 0 33 -6 43 -13z m3215 -26 c127 -12 132 -17 132 -133 0 -123 -4 -127 -128 -127 -120 0 -170 14 -178 49 -3 14 -10 36 -15 49 -5 13 -9 45 -9 73 0 63 21 83 100 98 3 0 47 -4 98 -9z m-2553 -20 c14 -15 18 -38 19 -114 1 -126 -4 -132 -122 -129 -105 2 -172 21 -189 54 -19 35 -17 159 3 187 14 21 22 22 143 22 115 0 130 -2 146 -20z m1554 -64 c11 -9 12 -54 6 -262 -7 -258 -4 -314 20 -314 7 0 31 28 51 63 55 90 135 187 159 192 101 21 138 25 220 25 86 0 95 -2 106 -21 9 -18 7 -30 -11 -68 -13 -25 -33 -59 -45 -76 -52 -72 -115 -187 -115 -211 0 -14 8 -38 19 -52 10 -15 44 -76 76 -137 32 -60 75 -133 96 -162 74 -100 53 -114 -171 -116 -133 -2 -158 0 -180 16 -13 9 -50 64 -80 122 -58 109 -104 170 -120 160 -6 -4 -10 -61 -10 -129 0 -84 -4 -128 -13 -140 -11 -16 -31 -18 -166 -18 -84 0 -156 3 -159 7 -8 8 -10 914 -3 1040 l6 90 45 6 c63 9 252 -1 269 -15z m-832 -1 c19 -13 21 -26 24 -145 3 -103 7 -133 19 -140 8 -5 51 -10 95 -10 88 -1 108 -10 125 -56 15 -37 4 -161 -17 -193 -15 -23 -19 -23 -109 -19 -88 5 -96 4 -106 -15 -12 -24 -3 -199 12 -228 17 -31 66 -49 151 -56 67 -5 83 -10 94 -27 16 -25 20 -199 5 -226 -14 -26 -124 -34 -272 -22 -112 10 -120 12 -166 45 -56 42 -151 140 -153 159 -1 7 -3 24 -4 38 -1 14 -8 57 -14 95 -6 39 -11 102 -11 140 0 98 -13 115 -89 115 -40 0 -63 5 -71 15 -7 9 -13 48 -14 96 -1 74 1 82 23 100 16 13 39 19 72 19 68 0 75 16 82 165 5 114 7 121 32 142 24 21 36 23 148 23 92 0 128 -4 144 -15z m-2911 -345 c7 -19 17 -133 23 -253 13 -242 21 -276 70 -296 65 -27 116 8 136 94 12 53 12 83 -4 250 -10 104 -16 197 -14 206 9 32 67 42 207 36 111 -5 132 -8 149 -26 19 -19 20 -34 21 -401 1 -367 0 -382 -18 -396 -15 -10 -55 -14 -162 -14 -147 0 -158 3 -166 45 -5 31 -40 29 -78 -5 -65 -58 -178 -75 -291 -43 -49 14 -72 27 -115 70 -30 30 -54 58 -54 64 0 6 -11 25 -24 42 -41 56 -46 104 -44 378 2 201 6 260 17 273 12 14 34 16 175 14 l161 -3 11 -35z m1392 31 c220 -10 213 -6 220 -155 l5 -105 -30 -28 c-16 -15 -84 -74 -151 -131 -119 -100 -142 -125 -127 -140 3 -4 48 -10 98 -13 155 -11 221 -21 240 -37 14 -12 17 -32 17 -103 0 -126 21 -119 -340 -118 -358 1 -468 8 -487 34 -8 12 -13 48 -13 100 0 113 -3 108 261 340 58 51 75 77 64 95 -4 6 -64 10 -149 10 -117 0 -146 3 -156 15 -7 9 -15 49 -18 90 -6 93 8 131 52 144 39 11 286 12 514 2z m817 -36 l25 -24 -1 -263 c-1 -145 -4 -307 -8 -360 -8 -133 -8 -133 -164 -133 -80 0 -133 5 -154 13 -29 13 -32 19 -39 69 -11 87 9 674 24 701 12 21 18 22 153 22 135 0 141 -1 164 -25z m2679 9 c3 -9 6 -183 6 -388 0 -343 -1 -374 -17 -388 -14 -13 -46 -16 -150 -16 -184 -1 -174 -13 -181 206 -4 149 10 505 23 569 6 27 20 30 181 32 112 1 133 -1 138 -15z m-490 -70 c3 -9 6 -138 6 -289 0 -351 -6 -360 -116 -169 -114 197 -113 180 -23 329 40 66 80 125 88 132 22 17 38 16 45 -3z m-1133 -166 c3 -26 9 -85 15 -165 8 -106 4 -109 -133 -88 -54 8 -104 15 -110 15 -30 0 -53 40 -53 90 0 56 24 90 62 90 52 0 139 25 160 46 25 25 57 31 59 12z m-2568 -28 c20 -16 46 -22 114 -26 116 -7 133 -11 133 -32 0 -9 -52 -69 -117 -132 -65 -64 -124 -124 -131 -134 -8 -9 -21 -16 -30 -14 -15 3 -17 24 -20 168 -1 90 0 170 2 177 7 18 19 16 49 -7z"/>
        <path d="M6385 5505 c-27 -20 -54 -44 -60 -53 -13 -24 -9 -240 6 -258 6 -8 19 -14 29 -14 10 0 20 -10 24 -22 4 -17 -1 -29 -22 -45 -34 -29 -63 -29 -88 -2 -10 11 -37 29 -58 40 -76 37 -307 16 -430 -39 -58 -26 -60 -26 -80 -6 -13 13 -16 44 -16 179 0 209 15 195 -208 195 l-163 0 -64 -37 c-35 -20 -67 -44 -71 -52 -11 -27 -23 -409 -17 -561 5 -133 4 -147 -13 -168 l-19 -23 -40 31 c-132 104 -154 145 -85 156 44 7 87 43 96 81 13 51 -67 153 -156 199 -103 53 -154 64 -297 64 l-132 0 -85 -40 c-47 -22 -109 -49 -138 -61 -29 -12 -68 -29 -86 -37 -43 -22 -64 -9 -79 51 -15 61 -18 65 -61 77 -74 20 -158 9 -259 -36 -46 -21 -74 -17 -118 14 -39 26 -45 27 -191 30 -146 3 -152 3 -180 -20 -16 -13 -48 -36 -71 -50 -40 -26 -42 -30 -47 -90 -4 -35 -7 -83 -9 -108 -2 -41 -4 -45 -27 -45 -19 0 -27 7 -34 30 -17 56 -65 154 -85 174 -66 66 -260 111 -482 111 l-116 0 -87 -44 c-84 -43 -189 -120 -250 -185 -42 -44 -69 -41 -95 12 -25 52 -26 66 -6 103 20 40 19 60 -10 121 -41 89 -172 213 -262 247 -21 8 -65 19 -98 25 -67 10 -418 8 -450 -4 -38 -14 -90 -37 -188 -85 -79 -39 -106 -59 -144 -104 -106 -126 -133 -295 -99 -621 19 -174 33 -210 115 -294 73 -76 93 -85 271 -121 153 -32 288 -27 480 17 148 33 257 100 341 207 50 65 84 75 95 29 10 -40 69 -126 116 -168 62 -56 113 -74 259 -90 140 -16 263 -9 384 21 55 14 181 71 214 98 21 16 85 107 99 139 9 21 18 28 35 25 21 -3 22 -8 28 -127 5 -106 8 -126 25 -138 15 -11 61 -14 234 -11 196 3 218 5 250 24 l35 20 5 212 c6 260 3 253 138 264 48 3 112 9 143 13 53 7 56 6 78 -21 89 -117 102 -137 99 -157 -2 -11 -26 -39 -55 -61 -46 -37 -52 -45 -52 -82 -1 -28 6 -50 23 -73 32 -43 119 -107 170 -125 199 -68 534 -36 656 63 79 65 159 112 183 109 19 -3 23 -12 30 -63 12 -86 20 -108 43 -120 30 -15 399 -3 447 15 33 13 43 12 85 -2 41 -15 103 -17 496 -16 437 0 450 1 515 22 66 23 66 23 79 72 10 37 13 137 12 399 -1 335 -8 435 -32 435 -6 0 -7 22 -3 58 3 31 8 108 11 171 l5 114 -27 24 c-26 22 -34 23 -193 23 l-166 0 -50 -35z m366 -34 c15 -19 19 -39 19 -109 0 -117 -5 -122 -124 -121 -50 0 -111 6 -135 12 -50 13 -54 21 -65 124 -6 48 -3 63 14 91 l21 34 125 -4 c118 -3 127 -4 145 -27z m-1113 -43 c9 -9 12 -88 12 -294 0 -156 4 -285 8 -288 5 -3 46 45 92 106 46 62 91 119 101 129 22 22 160 42 264 37 73 -3 80 -5 83 -25 4 -29 -34 -108 -113 -228 -35 -55 -65 -104 -65 -110 0 -16 62 -131 154 -284 47 -80 86 -148 86 -153 0 -4 -12 -15 -27 -25 -23 -15 -51 -18 -191 -18 l-164 0 -33 39 c-18 22 -51 74 -72 115 -45 90 -93 156 -104 144 -4 -4 -12 -66 -18 -137 -5 -71 -14 -133 -18 -137 -6 -6 -238 -14 -300 -10 -25 2 -36 72 -29 195 4 67 9 299 12 516 3 216 10 402 15 412 7 13 25 18 77 21 159 8 218 7 230 -5z m-3986 -29 c80 -17 117 -36 186 -96 90 -79 133 -135 139 -183 9 -69 5 -70 -203 -70 l-183 0 -33 28 c-58 50 -86 62 -135 62 -49 0 -82 -16 -115 -55 -15 -17 -17 -44 -18 -192 0 -196 10 -262 49 -305 26 -29 31 -30 102 -30 l74 1 43 46 c56 62 55 79 -7 100 -27 9 -54 22 -60 29 -6 7 -12 52 -13 100 -4 123 -15 118 254 114 193 -3 219 -5 235 -21 16 -16 18 -38 18 -190 -1 -166 -2 -174 -27 -222 -28 -54 -104 -132 -153 -158 -162 -87 -326 -118 -496 -92 -91 13 -114 21 -184 61 -88 51 -157 118 -186 179 -49 107 -71 334 -49 515 23 189 67 262 197 326 42 22 96 44 118 50 53 15 379 17 447 3z m1178 -293 c124 -27 210 -82 226 -146 4 -14 10 -29 14 -35 4 -5 18 -39 30 -75 19 -53 23 -86 24 -180 0 -104 -2 -120 -27 -173 -48 -105 -78 -134 -202 -196 -45 -22 -65 -25 -207 -29 -148 -4 -163 -3 -241 21 -87 28 -102 38 -159 109 -90 110 -107 184 -73 324 65 272 82 308 180 361 l60 32 155 1 c96 0 180 -5 220 -14z m817 -5 c19 -12 34 -31 38 -50 9 -40 19 -45 52 -26 135 78 180 95 257 95 79 0 86 -11 86 -150 0 -158 5 -153 -157 -160 -138 -7 -156 -12 -198 -62 l-27 -32 7 -206 c7 -190 6 -207 -11 -220 -14 -12 -48 -15 -160 -13 -79 1 -151 6 -163 12 -30 17 -32 60 -23 448 7 261 12 356 22 368 10 12 36 15 129 15 97 0 121 -3 148 -19z m1201 4 c54 -19 77 -32 130 -73 46 -36 85 -102 76 -126 -9 -24 -37 -28 -174 -28 -108 0 -133 3 -167 21 -55 28 -97 17 -101 -26 -3 -25 2 -34 30 -50 18 -10 67 -25 108 -32 41 -7 91 -17 110 -23 68 -22 210 -131 239 -186 14 -26 14 -65 0 -94 -18 -37 -113 -106 -221 -161 l-100 -50 -121 -1 c-124 -1 -220 16 -284 49 -15 8 -33 15 -40 15 -23 0 -113 98 -113 123 0 34 33 44 168 51 92 4 128 1 188 -14 91 -24 127 -16 122 27 -4 38 -46 59 -175 90 -109 27 -165 55 -242 121 -32 27 -35 34 -39 96 l-4 67 50 48 c72 69 130 115 182 145 43 24 53 26 190 26 102 0 158 -5 188 -15z m1916 -18 c14 -10 19 -37 26 -137 19 -252 6 -608 -22 -637 -12 -11 -46 -15 -151 -16 -117 -2 -139 0 -153 15 -16 15 -19 54 -26 330 -9 364 -5 426 32 445 35 18 270 18 294 0z m-5352 -61 c22 -27 23 -49 1 -68 -47 -40 -83 -28 -83 29 0 72 40 92 82 39z m4882 -18 c11 -43 7 -543 -5 -555 -19 -19 -53 5 -87 61 -18 29 -32 57 -32 63 0 6 -9 21 -19 35 -26 32 -71 118 -71 133 0 12 28 61 104 180 21 33 45 70 52 83 8 12 23 22 33 22 11 0 21 -9 25 -22z"/>
        <path d="M2608 4875 c-33 -31 -43 -97 -35 -237 6 -113 19 -138 72 -138 54 0 82 35 91 116 18 153 1 233 -56 267 -37 22 -40 22 -72 -8z"/>
        </g>
    </svg>
    `)
};
const defaultImgSrc_png = "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEicpyIovkBboaA3DOVcPNZQQ47-GSa5AidzIeUbL2N8iue6yM1XIxd0BL5W8e2ty7ntqz4K8ovfmT7DV1c3_NXVFWWDLeKYMpbD_C1wK1qh4Y1zGLh_tHUi5d1pHtDxxQKunZLAkL3ibt5gjhI3KQX9cHtQMn0m9liFgtLc00VQH4YHc5I6aAO-mw84w8Q/s600/end_cover_photo.png";

// Default cover photo
const defaultImgSrc = "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiU8RYSJ0I45O63GlKYXw5-U_r7GwP48_st9F1LG7_Z3STuILVQxMO4qLgzP_wxg0v_77s-YwidwwZQIDS1K6SUmY-W3QMwcIyEvt28cLalvCVQu4qWTQIm-B_FvgEmCCe6ydGld4fQgMMd2xNdqMMFtuHgeVXB4gRPco3XP90OOKHpf6HyZ6AeEZqNJQo/s1600/IMG20241101141924.jpg";

// Array to hold all slideshows data
let slideshows = [];

// DOM Element Arrays
const mySlideshowContainer = [];
const slideshowOuterContainer = [];
const slideshowContainer = [];
const progressBarContainer = [];
const coverPhotoContainer = [];
const photoOverlay = [];
const slideContainers = [];
const toggleNavigationButton = [];
const settingsButton = [];
const previousPhoto = [];
const toggleSlideshowButton = [];
const nextPhoto = [];
const fullscreenButton = [];
const enterFullscreenIcon = [];
const exitFullscreenIcon = [];
const playIcon = [];
const pauseIcon = [];
const toggleTooltip = [];
const qualitySliderElement = [];
const qualityValueElement = [];
const speedSliderElement = [];
const speedValueElement = [];
const navigationControl = [];
const navigationControlButtons = []; // Navigation control buttons array
const descriptionControlStyle = []; // Controll style of image description
const sliderContainer = []; // New sliderContainer array
const autoQualityCheckbox = []; // Quality checkbox selection
const preloadAllButton = [];
var controllButton = []; // Navigation control controllButton
var descriptionStyle = []; // Controll style of image description in all containers

/**
 * @brief   A Least Recently Used (LRU) cache implementation with size-based eviction.
 *
 * @details This class manages a cache that automatically evicts the least recently used 
 *          items when the total size exceeds the defined `maxSize`. Items are stored 
 *          with their respective sizes, allowing the cache to efficiently manage memory 
 *          usage. Common operations include adding, retrieving, and deleting items while 
 *          maintaining a strict size limit.
 *
 * @class   LRUCacheBySize
 *
 * @param   {number} maxSize The maximum allowed size of the cache in bytes.
 *
 * @methods 
 * - `set(key, value, size)` Adds a key-value pair to the cache. Evicts the least recently 
 *   used items if the cache exceeds the maximum size.
 * - `get(key)` Retrieves a value by its key. Marks the accessed item as recently used.
 * - `has(key)` Checks if a key exists in the cache.
 * - `delete(key)` Removes a key-value pair from the cache and adjusts the size.
 * - `clear()` Clears all items from the cache and resets the size.
 *
 * @example
 * const cache = new LRUCacheBySize(1024 * 1024); // 1MB max size
 * cache.set('image1', img1, 400000); // Add an image with a size of 400KB
 * const image = cache.get('image1'); // Retrieve the cached image
 *
 * @note    The size of each item must be explicitly provided during insertion. The cache 
 *          uses a `Map` to store items and their metadata, ensuring O(1) access and update times.
 */
    class LRUCacheBySize {
    constructor(maxSize) {
        this.cache = new Map(); // Store cached items
        this.maxSize = maxSize; // Max size in bytes
        this.currentSize = 0;   // Current total size in bytes
    }

    // Set a key-value pair in the cache
    set(key, value, size) {
    if (typeof size !== "number" || isNaN(size)) {
        console.warn(`Skipping cache entry for ${key} — invalid size.`);
        return; // Don't add items with undefined or invalid size
    }

    if (this.cache.has(key)) {
        this.currentSize -= this.cache.get(key).size;
        this.cache.delete(key);
    }

    while (this.currentSize + size > this.maxSize) {
        const oldestKey = this.cache.keys().next().value;
        const oldestItem = this.cache.get(oldestKey);
        this.currentSize -= oldestItem.size;
        this.cache.delete(oldestKey);
    }

    this.cache.set(key, { value, size });
    this.currentSize += size;
}

    // Get a value by its key
    get(key) {
        if (!this.cache.has(key)) return null;

        const item = this.cache.get(key);

        // Move accessed item to the end to mark it as recently used
        this.cache.delete(key);
        this.cache.set(key, item);

        return item.value;
    }

    // Check if a key exists
    has(key) {
        return this.cache.has(key);
    }

    // Delete a key-value pair
    delete(key) {
        if (this.cache.has(key)) {
            const item = this.cache.get(key);
            this.currentSize -= item.size;
            this.cache.delete(key);
        }
    }

    // Clear the cache
    clear() {
        this.cache.clear();
        this.currentSize = 0;
    }
}

const imageCache = new LRUCacheBySize(50 * 1024 * 1024); // Cache size limit: 50MB

// Call the function to generate the slideshow containers
generateSlideshowContainers(defaultImgSrc);


/**
 * @brief   Generates slideshow containers dynamically based on available titles and cover photos.
 *
 * @details This function iterates through the available slideshow titles, retrieves the corresponding cover photo
 *          for each slideshow, and inserts the slideshow container into the DOM. If no valid cover photo is found,
 *          a default image source is used. The function also minimizes image source sizes and logs all slideshow titles.
 *
 * @param   defaultImgSrc    The default image source to be used if no valid cover photo is found.
 *
 * @return  None.
 */
function generateSlideshowContainers(defaultImgSrc) {
    // Generate slideshow containers by iterating through available titles and assigning cover photos, using a default if necessary.
    while (typeof window[`slideshowTitle${slideshowIndex}`] !== 'undefined') {
        // Access the variable
        const SlideshowTitle = window[`slideshowTitle${slideshowIndex}`];
        let coverPhoto = window[`CoverPhoto${slideshowIndex}`];
        
        // Check if the cover photo is valid, if not set it to a default source
        if (!coverPhoto || coverPhoto.trim() === "") {
            coverPhoto = defaultImgSrc;  // Set the image source to the predefined URL
        }

        // At least one Slideshow found - Minimize post image source sizes
        updateImageSources(1);

        // Collect titles
        slideshowTitles.push(SlideshowTitle);

        // Insert the slideshow container
        insertSlideshowContainer(SlideshowTitle, coverPhoto, slideshowIndex); 
        
        // Move to the next slideshow index
        slideshowIndex++;
    }

    // Log the titles of the slideshows that will be created
    console.log('All slideshows:', slideshowTitles);

    // Call the function to initialize slideshows
    initializeSlideshows(numberOfSlideshows, defaultImgSrc);
}


/**
 * @brief   Updates the source URL of all images based on the specified size.
 *
 * @details This function finds all images within elements having the class 'tr-caption-container' and updates their
 *          `src` attributes to reflect a new size. The size is specified as a parameter, and the function uses a regular
 *          expression to modify the source URL, replacing the previous size with the given size.
 *
 * @param   size  The new size value to be applied to the image sources.
 *
 * @return  None.
 */
function updateImageSources(size) {
    // Select all images inside elements with the class 'tr-caption-container'
    const images = document.querySelectorAll('.tr-caption-container img[src]');
    
    for (let i = 0; i < images.length; i++) {
        let imgSrc = images[i].getAttribute('src');

        // Replace /sXXX/ or /sXXX-rw/ with /s<size>-rw/ to use WebP format (-rw suffix enables WebP)
        const newSrc = imgSrc.replace(/\/s\d+(-rw)?\//, `/s${size}-rw/`);

        // Update the src attribute with the new WebP-enabled image URL
        images[i].setAttribute('src', newSrc);
    }
}


/**
 * @brief   Dynamically inserts a slideshow container into the DOM.
 *
 * @details This function creates and inserts a complete slideshow container structure, which includes the slideshow
 *          image display, navigation controls, progress bar, and settings for quality and speed adjustments.
 *          The slideshow is inserted after the corresponding script tag in the DOM. It uses the provided slideshow
 *          title and cover photo for initialization, and dynamically generates a unique set of HTML elements for each
 *          slideshow instance, identified by an index.
 *
 * @param   slideshowTitle  The title for the slideshow that is displayed on the cover photo.
 * @param   coverPhoto      The URL of the image displayed as the cover photo for the slideshow.
 * @param   index           The unique index to identify each slideshow instance and dynamically generate its elements.
 *
 * @return  None.
 */
function insertSlideshowContainer(slideshowTitle, coverPhoto, index) {
    console.log(`Inserting slideshow container for index ${index}: Title=${slideshowTitle}, Cover Photo=${coverPhoto}`);
    
    // Create a new div element as a holder (wrapper) for the slideshow container
    var wrapperDiv = document.createElement('div');
    wrapperDiv.id = `slideShow-${index}`; // Set a unique ID for each slideshow div
    wrapperDiv.className = 'my-slideshow-wrapper'; // Add a class for the slideshow wrapper (holder)

    // Add the full slideshow structure, dynamically generating the slides
    wrapperDiv.innerHTML = `
        <div class='my-slideshow-container' id="mySlideshowContainer-${index}" style="display: block;">
            <div class='slideshow-outer-container' id="slideshowOuterContainer-${index}">
                <div class='slideshow-container' id="slideshowContainer-${index}">
                
                    <!-- Progress Bar Container (Red Timeline) -->
                    <div class="overlay-progress-container" id="overlayProgressContainer-${index}" 
                            onmouseenter="toggleProgressBarVisibility(${index}, '5px', 'hover')" 
                            onmouseleave="toggleProgressBarVisibility(${index}, '0px', 'hover')">
                        <div class="progress-container" id="progressBarContainer-${index}">
                            <div class="progress-bar" id="progressBar-${index}"></div>
                        </div>
                    </div>

                    <!-- Invisible Overlay for Click Events -->
                    <div class="overlay-container" id="overlayContainer-${index}" style="position: absolute; top: 0; left: 0; width: 100%; height: 0; display: flex; z-index: 1;">
                        <!-- Left Section for Previous Slide -->
                        <div class="overlay-left" style="flex: 1;" onclick="enqueueManualSlide(${index}, -1)"></div>
                        <!-- Middle Section for Play/Pause Slideshow and Fullscreen Toggle on Double-click -->
                        <div class="overlay-middle" style="flex: 1;" onclick="handleClick(${index})"></div>
                        <!-- Right Section for Next Slide -->
                        <div class="overlay-right" style="flex: 1;" onclick="enqueueManualSlide(${index}, 1)"></div>
                    </div>

                    <!-- Cover Photo (Displayed initially) -->
                    <div class="cover-photo-container" id="coverPhotoContainer-${index}">
                        <img alt="Cover Photo" src="${coverPhoto}" id="coverPhotoElement-${index}" />
                        <div class="photo-overlay" id="photoOverlay-${index}">
                            <span class="my-title">${postTitle}</span>
                        </div>
                    </div>


                    <!-- First image (Previous) -->
                    <div class='mySlides slide1' id="slide1-${index}">
                        <div class='uppertext'></div>
                        <div class='date'></div>
                        <img alt='' src=''/>
                        <div class='text' id="descriptionControllStyle0-${index}"></div>
                    </div>
                    <!-- Second image (Current) -->
                    <div class='mySlides slide2' id="slide2-${index}">
                        <div class='uppertext'></div>
                        <div class='date'></div>
                        <img alt='' src=''/>
                        <div class='text' id="descriptionControllStyle1-${index}"></div>
                    </div>
                    <!-- Third image (Next) -->
                    <div class='mySlides slide3' id="slide3-${index}">
                        <div class='uppertext'></div>
                        <div class='date'></div>
                        <img alt='Next Image' src=''/>
                        <div class='text' id="descriptionControllStyle2-${index}"></div>
                    </div>
                </div>

                <!-- Navigation control (previous/next buttons) -->
                <div class='navigation-controll' id="navigationControl-${index}" style="z-index: 2;">

                    <!-- Toggle Navigation Button -->
                    <span data-is-tooltip-wrapper="true">
                        <button aria-label="Toggle Navigation" id="toggleNavigationButton-${index}"style="display: none;">
                            <svg id="toggleIcon-${index}" height="24px" viewBox="0 0 24 24" width="24px" style="display: block;">
                                <path d="M3 12h18M3 6h18M3 18h18" stroke="#000" stroke-width="2" stroke-linecap="round" />
                            </svg>
                            <div class="tooltip">Meni</div>
                        </button>
                    </span>

                    <!-- Settings button (appears on hover) -->
                    <span data-is-tooltip-wrapper="true" class="toggle-target" id="navigationControlButton0-${index}"style="display: none;">
                        <button aria-label="Settings" id="settingsButton-${index}">
                            <!-- Settings Icon -->
                            <svg id="settingsIcon-${index}" height="24px" viewBox="0 0 24 24" width="24px" style="display: block;">
                                <path stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 21h-4l-.551-2.48a6.991 6.991 0 0 1-1.819-1.05l-2.424.763-2-3.464 1.872-1.718a7.055 7.055 0 0 1 0-2.1L3.206 9.232l2-3.464 2.424.763A6.992 6.992 0 0 1 9.45 5.48L10 3h4l.551 2.48a6.992 6.992 0 0 1 1.819 1.05l2.424-.763 2 3.464-1.872 1.718a7.05 7.05 0 0 1 0 2.1l1.872 1.718-2 3.464-2.424-.763a6.99 6.99 0 0 1-1.819 1.052L14 21z"/>
                                <circle cx="12" cy="12" r="3" stroke="#000000" stroke-width="2"/>
                            </svg>
                            <div class="tooltip">Nastavitve</div>
                        </button>
                    </span>

                    <span data-is-tooltip-wrapper='true' class="toggle-target" id="navigationControlButton1-${index}"style="display: none;">
                        <button aria-label='Prejšnja' id='previousPhoto-${index}'>
                            <span aria-hidden='true'>
                                <svg height='24px' viewBox='0 0 24 24' width='24px'>
                                    <path d='M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z'/>
                                </svg>
                            </span>
                            <div class='tooltip' style='display: none; opacity: 0;'>Prejšnja</div>
                        </button>
                    </span>

                    <span data-is-tooltip-wrapper='true' class="toggle-target" id="navigationControlButton2-${index}"style="display: none;">
                        <button aria-label='Predvajaj' id='toggleSlideshowButton-${index}'>
                            <span aria-hidden='true' id='toggleIcon-${index}'>
                                <svg height='24px' viewBox='0 0 24 24' width='24px'>
                                    <path d='M8 5v14l11-7z' id='playIcon-${index}' style='display: block;'/>
                                    <path d='M6 19h4V5H6v14zm8-14v14h4V5h-4z' id='pauseIcon-${index}' style='display: none;'/>
                                </svg>
                            </span>
                            <div class='tooltip' id='toggleTooltip-${index}' style='display: none; opacity: 0;'>Predvajaj</div>
                        </button>
                    </span>

                    <span data-is-tooltip-wrapper='true' class="toggle-target" id="navigationControlButton3-${index}"style="display: none;">
                        <button aria-label='Naprej' id='nextPhoto-${index}'>
                            <span aria-hidden='true'>
                                <svg height='24px' viewBox='0 0 24 24' width='24px'>
                                    <path d='M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z'/>
                                </svg>
                            </span>
                            <div class='tooltip' style='display: none; opacity: 0;'>Naprej</div>
                        </button>
                    </span>

                    <span data-is-tooltip-wrapper="true" class="toggle-target" id="navigationControlButton4-${index}"style="display: none;">
                        <button aria-label="Fullscreen" id="fullscreenButton-${index}">
                            <!-- Enter Fullscreen Icon -->
                            <svg id="enterFullscreenIcon-${index}" height="24px" viewBox="0 0 24 24" width="24px" style="display: block;">
                                <path d="M4 4h5V2H2v7h2V4zm16 0v5h2V2h-7v2h5zM9 18H4v-5H2v7h7v-2zm11-5v5h-5v2h7v-7h-2z"></path>
                            </svg>
                            <!-- Exit Fullscreen Icon -->
                            <svg id="exitFullscreenIcon-${index}" height="24px" viewBox="0 0 24 24" width="24px" style="display: none;">
                                <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"></path>
                            </svg>
                            <div class="tooltip">Celozaslonsko</div>
                        </button>
                    </span>
                </div>

                <!-- Slider Container inside the slideshow, positioned at bottom-right --> 
                <div class='slider-container' id='sliderContainer-${index}' style="display: none; flex-direction: column; gap: 10px;">

                    <!-- Row for Quality Title and Auto Checkbox Title, aligned symmetrically above slider and checkbox -->
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <!-- Quality Title centered above the slider -->
                        <label for='qualitySliderElement' style="text-align: center; flex-basis: 70%;">Kvaliteta: <span id='qualityValueElement-${index}'>${initQuality}</span></label>
                        
                        <!-- Auto Checkbox Title centered above the checkbox -->
                        <label for='autoQualityCheckbox-${index}' style="text-align: center; flex-basis: 30%;">Auto</label>
                    </div>
                    
                    <!-- Row for Quality Slider and Auto Checkbox -->
                    <div style="display: flex; align-items: center;">
                        <!-- Quality Slider with 70% width -->
                        <input id='qualitySliderElement-${index}' max='11' min='1' step='1' type='range' value='${initQuality}' style="flex-basis: 70%;"/>
                        
                        <!-- Auto Checkbox with 30% width -->
                        <input type='checkbox' id='autoQualityCheckbox-${index}' checked style="flex-basis: 30%;"/>
                    </div>
                    
                    <!-- Row for Speed Slider -->
                    <div style="display: flex; flex-direction: column;">
                        <label for='speedSliderElement'>Hitrost: <span id='speedValueElement-${index}'>${initSpeed}</span>s</label>
                        <input id="speedSliderElement-${index}" max="${maxSpeed}" min="${minSpeed}" step="${stepSpeed}" type="range" value="${initSpeed}" />
                        </div>

                    <div style="display: flex; flex-direction: column;">
                        <!-- Button to Preload All Images as the last element -->
                        <button id="preloadAllButton-${index}" style="margin-top: 10px; width: 100%; background-color: transparent; color: gray; font-size: 12px; border: 3px solid gray; border-radius: 5px; line-height: 1;">Predpriprava slik</button>
                    </div>

                </div>
            </div>
        </div>
    `;

    // Insert the wrapper div into the DOM after the corresponding script tag
    var scriptTags = document.getElementsByTagName('script');
    var targetScriptTag;

    // Find the target script tag that contains the specific index
    for (var i = 0; i < scriptTags.length; i++) {
        if (scriptTags[i].innerText.includes('var slideshowTitle' + index)) {
            targetScriptTag = scriptTags[i];
            numberOfSlideshows.push(index);   // Number of slideshows
            break;
        }
    }

    // If the target script tag is found, insert the container
    if (targetScriptTag) {
        targetScriptTag.parentNode.insertBefore(wrapperDiv, targetScriptTag.nextSibling);
    }
}


/**
 * @brief   Initializes the slideshow data and DOM elements for all slideshows.
 *
 * @details This function initializes the slideshow data, populates the slideshow arrays with default values,
 *          and collects DOM elements related to the slideshow. The function is called for each slideshow
 *          in the `numberOfSlideshows` array.
 *
 * @param   numberOfSlideshows  Array that contains the indices of the slideshows to be initialized.
 * @param   defaultImgSrc       The default image source to be used for missing cover photos.
 *
 * @return  None.
 */
function initializeSlideshows(numberOfSlideshows, defaultImgSrc) {
    // Create the slideshows with default values for elements in the array
    numberOfSlideshows.forEach(index => {
        slideshows[index] = {
            startIndex: 1,
            maxResults: 25,
            imageBuffer: [],
            shuffledImages: [],
            currentBatchIndex: 0,
            activeSlide: 0,
            hideTimeout: null,
            slideshowTimeout: null,
            clickCount: -1, // Flag for menu layout
            slideshowSpeed: 3000, // Default speed (3 seconds)
            qualityValue: 7,      // Quality value
            isSlideshowRunning: false, // Flag for slideshow running state
            wasSlideshowRunning: false, // Flag for slideshow running state
            pauseSlideshowFlag: false,
            previousBackgroundColor: null,  // Variable to store the original background color of navigation button
            isSlideshowReady: false,  // Flag to track if all slideshows are initialized
            currentTime: 0,  // Store current time in milliseconds
            lastClickTime: 0,  // To store the time of the last click
            clickTimer: 0, // Timer for single-click detection
            progressBarHeightKey: '0px', // Progress bar status
            coverPhotoHidden: false,  // Track, that cover photo in hidden just once
            connectionErrorTimeout: null,  // Define a variable to store the timeout reference
            imageIsReady: true,  // Track when image is prepared (Initialize as true to ensure smooth start with manual slide functionality)
            attempts: 0, // Track internet quality
            manualAttempts: 0, // Track internet quality for manual sliding
            isProcessingQueue: false,  // Track it actions from manual sliding are proccesing
            errorFlag: true,  // Error flag (show or hide connection status message)
            textClickCount: 0, // Flag for image description container style
        };
    });

    // Populate the DOM element arrays
    numberOfSlideshows.forEach(index => {
        mySlideshowContainer.push(document.getElementById(`mySlideshowContainer-${index}`));
        slideshowOuterContainer.push(document.getElementById(`slideshowOuterContainer-${index}`));
        slideshowContainer.push(document.getElementById(`slideshowContainer-${index}`));
        progressBarContainer.push(document.getElementById(`progressBarContainer-${index}`));
        coverPhotoContainer.push(document.getElementById(`coverPhotoContainer-${index}`));
        photoOverlay.push(document.getElementById(`photoOverlay-${index}`));

        // Slide containers for each slideshow (contains three slides per slideshow)
        slideContainers.push([
            document.getElementById(`slide1-${index}`),
            document.getElementById(`slide2-${index}`),
            document.getElementById(`slide3-${index}`)
        ]);

        toggleNavigationButton.push(document.getElementById(`toggleNavigationButton-${index}`));
        settingsButton.push(document.getElementById(`settingsButton-${index}`));
        previousPhoto.push(document.getElementById(`previousPhoto-${index}`));
        toggleSlideshowButton.push(document.getElementById(`toggleSlideshowButton-${index}`));
        nextPhoto.push(document.getElementById(`nextPhoto-${index}`));
        fullscreenButton.push(document.getElementById(`fullscreenButton-${index}`));
        enterFullscreenIcon.push(document.getElementById(`enterFullscreenIcon-${index}`));
        exitFullscreenIcon.push(document.getElementById(`exitFullscreenIcon-${index}`));
        playIcon.push(document.getElementById(`playIcon-${index}`));
        pauseIcon.push(document.getElementById(`pauseIcon-${index}`));
        toggleTooltip.push(document.getElementById(`toggleTooltip-${index}`));
        qualitySliderElement.push(document.getElementById(`qualitySliderElement-${index}`));
        qualityValueElement.push(document.getElementById(`qualityValueElement-${index}`));
        speedSliderElement.push(document.getElementById(`speedSliderElement-${index}`));
        speedValueElement.push(document.getElementById(`speedValueElement-${index}`));
        navigationControl.push(document.getElementById(`navigationControl-${index}`));
        sliderContainer.push(document.getElementById(`sliderContainer-${index}`));
        autoQualityCheckbox.push(document.getElementById(`autoQualityCheckbox-${index}`));
        preloadAllButton.push(document.getElementById(`preloadAllButton-${index}`));

        
        controllButton = [
            `navigationControlButton0-${index}`,
            `navigationControlButton1-${index}`,
            `navigationControlButton2-${index}`,
            `navigationControlButton3-${index}`,
            `navigationControlButton4-${index}`
        ].map(id => document.getElementById(id));

        navigationControlButtons.push(controllButton);

        descriptionStyle = [
            `descriptionControllStyle0-${index}`,
            `descriptionControllStyle1-${index}`,
            `descriptionControllStyle2-${index}`
        ].map(id => document.getElementById(id));

        descriptionControlStyle.push(descriptionStyle);
    });
}


/*######### Onresize functions  #########*/

/**
 * @brief   Adjusts the quality of the slideshow based on container size when autoQualityCheckbox is selected.
 *
 * @details This function checks if the auto-quality checkbox is selected, and if so, it dynamically adjusts the font size, 
 *          padding, and image size based on the current dimensions of the slideshow container. It also updates the 
 *          quality slider based on the container's width and applies the appropriate color to the slider.
 *
 * @param   index  The index of the active slideshow to adjust the quality settings for.
 *
 * @return  None.
 */
function autoSetQuality(index) {
    if (autoQualityCheckbox[index].checked) {
        // Get the width of the slideshow container in pixels
        containerWidth = slideshowContainer[index].offsetWidth; // Detects the width in pixels
        containerHeight = slideshowContainer[index].offsetHeight; // Detects the height in pixels

        // Dynamically adjust font size based on container width
        const fontSize = Math.max(containerWidth / 40, 12); // Font size is containerWidth/10 but caps at 6em

        // Dynamically adjust padding with a lower limit
        const padding = Math.max(containerWidth / 60, 8); // Padding based on container width, but minimum 8px

        // Apply font size to text elements
        const textElements = slideshowContainer[index].querySelectorAll('.text, .uppertext, .date');
        textElements.forEach(textElement => {
            if (textElement.classList.contains('date')) {
                // Keep date smaller in ratio
                const dateFont = Math.round(fontSize * 0.7777); // e.g., 14px if base 18px
                textElement.style.fontSize = `${dateFont}px`;
                textElement.style.padding = `${Math.round(padding * 0.7777)}px`;

                // Set bottom negative equal to font size
                textElement.style.bottom = `-${dateFont}px`;
            } else {
                // Normal text/uppertext
                textElement.style.fontSize = `${fontSize}px`; // Set font-size to the calculated value
                textElement.style.padding = `${padding}px`; // Set padding to the calculated value
            }
        });

        // Assign the bigger value to a third variable
        const containerSize = Math.max(containerWidth, containerHeight); // Determine the larger value

        // Update size of images according to container size using WebP (-rw)
        slideshows[index].shuffledImages.forEach(img => {
            img.src = img.src.replace(/\/s\d+(-rw)?\/|\/w\d+-h\d+\//, `/s${containerSize}-rw/`);
        });

        // Update the quality slider value based on the container width
        qualitySliderElement[index].value = Math.ceil(containerWidth / 400);
        qualityValueElement[index].textContent = Math.ceil(containerWidth / 400);
    }
    updateSliderColor(index);
}


/**
 * @brief   Updates the color and state of the quality slider based on the container size and auto-quality setting.
 *
 * @details This function checks whether the auto-quality checkbox is selected. If it is, the quality slider is disabled 
 *          and its color is set to gray. If not, the slider is enabled, and its color is updated based on a comparison 
 *          of the container's size and the slideshow's quality value. If the quality value is less than the container size, 
 *          the slider color is set to green; if greater, it is set to red; otherwise, it is reset to the default color.
 *
 * @param   index  The index of the slideshow to update.
 */
    function updateSliderColor(index) {
    if (autoQualityCheckbox[index].checked) {
        qualitySliderElement[index].disabled = true;  // Disable the slider
        qualitySliderElement[index].style.accentColor = 'gray';
    }
    else {
        qualitySliderElement[index].disabled = false;  // Enable the slider when unchecked

        // Get the width of the slideshow container in pixels
        containerWidth = slideshowContainer[index].offsetWidth; // Detects the width in pixels
        containerHeight = slideshowContainer[index].offsetHeight; // Detects the height in pixels

        // Assign the bigger value to a third variable
        const containerSize = Math.max(containerWidth, containerHeight); // Determine the larger value

        const comparisonValue = slideshows[index].qualityValue * 400;

        if (comparisonValue < containerSize) {
            qualitySliderElement[index].style.accentColor = 'green';  // Set to blue if comparisonValue < containerSize
        } else if (comparisonValue > containerSize) {
            qualitySliderElement[index].style.accentColor = 'red';   // Set to red if comparisonValue > containerSize
        } else {
            qualitySliderElement[index].style.accentColor = '';      // Reset to default if none of the conditions match
        }    
    }
}


/*######### Onload functions  #########*/

/**
 * @brief   Fetches and processes data for a slideshow.
 *
 * @details Constructs a blog feed URL based on the slideshow title or post ID 
 *          and retrieves image data using a fetch request. The function handles 
 *          special cases like "All pictures" (recursive loading) and processes 
 *          entries to populate the slideshow's image buffer. Updates the UI with 
 *          built slides or logs errors in case of failures.
 *
 * @param   index Index of the slideshow to fetch data for.
 */
function fetchData(index) {
    var feedUrl;
    const isRelive = window.BLOG_CONTEXT?.isRelive === true;
    // const postId = getPostIdFromAnchor();
    
    // Determine the feed URL based on the slideshow title
    if (slideshowTitles[index] === "All pictures") {
        feedUrl = isRelive
          ? `${WindowBaseUrl}/data/all-relive-posts.json`
          : `${WindowBaseUrl}/data/all-posts.json`;
    } else if (slideshowTitles[index] === "Make post slideshow" || slideshowTitles[index] === "Make trip slideshow") {
        feedUrl = `${WindowBaseUrl}/data/posts/${postId}.json`; // Get by postID
    } else {
        feedUrl = `${WindowBaseUrl}/data/posts/${encodeURIComponent(slideshowTitles[index])}.json`;
    }
    // console.log("feedUrl:",feedUrl)

    // Fetch the data from the constructed feed URL
    fetch(feedUrl)
        .then(response => response.json())
        .then(async (data) => {
            // The entries are in data.entry, if retrieving data by postId
            let entries = data.entry;

            if (slideshowTitles[index] !== "Make post slideshow" && slideshowTitles[index] !== "Make trip slideshow") {
                entries = data.feed.entry;
            }

            // If there's just one entry, wrap it into an array to handle it uniformly
            if (entries && !Array.isArray(entries)) {
                entries = [entries]; // Convert single entry into an array
            }

            // Process "All pictures" scenario
            if (slideshowTitles[index] === "All pictures") {
                setSlideshowQuality(index);

                if (!entries || entries.length === 0) {
                    console.log('No new entries, using existing imageBuffer:', slideshows[index].imageBuffer.length);
                    document.getElementById('imagesLoadedCount').textContent = slideshows[index].imageBuffer.length;
                } else {
                    // Date and labels filter
                    const startDate = localStorage.getItem('startDateRange'),
                          endDate = localStorage.getItem('endDateRange'),
                          selectedLabels = JSON.parse(localStorage.getItem('selectedLabels') || '{}'); // object grouped by prefix

                    // Log currently applied filters
                    console.log("Applied Filters:", {
                        startDate: startDate || 'none',
                        endDate: endDate || 'none',
                        selectedLabels: selectedLabels
                    });

                    if (startDate || endDate || Object.keys(selectedLabels).length > 0) {
                        entries = entries.filter(entry => {
                            const entryDate = new Date(entry.published?.$t || entry.published);

                            // Date filter
                            if (startDate && entryDate < new Date(startDate)) return false;
                            if (endDate && entryDate > new Date(endDate)) return false;

                            // Label filter (group-based AND logic)
                            if (Object.keys(selectedLabels).length > 0) {
                                const entryLabels = (entry.category || []).map(cat => cat.term.replace(/^\d+\.\s*/, ''));

                                for (const group in selectedLabels) {
                                    const groupLabels = selectedLabels[group];
                                    if (!groupLabels.some(label => entryLabels.includes(label))) {
                                        return false;
                                    }
                                }
                            }

                            return true;
                        });
                    }

                    // Procesiraj filtrirane vnose
                    for (let entry of entries) {
                        processEntry(index, entry);
                    }
                }

                const imgCount = slideshows[index].imageBuffer.length;

                if (imgCount === 0) {
                    // ✅ Ni slik po filtrih → prikaži sporočilo
                    const container = document.getElementById(`slideShow-${index}`);
                    container.innerHTML = `<p style="text-align:center; font-size:18px; padding:20px;">Ni slik za izbrane filtre</p>`;
                    console.warn('No images to display for selected filters');
                    return;
                }

                // Če slike obstajajo → zgradi slideshow
                console.log('Fetched', imgCount, 'images for All pictures');
                document.getElementById('imagesLoadedCount').textContent = imgCount;

                slideshows[index].shuffledImages = shuffleArray(slideshows[index].imageBuffer.slice(), index);
                buildSlides(index);
                return;
            }

            // Set the slideshow quality for the current index
            setSlideshowQuality(index);

            // Process each entry
            for (let entry of entries) {
                if (slideshowTitles[index] !== "Make trip slideshow") {
                    // Process the main entry if it's not "Make trip slideshow"
                    processEntry(index, entry);
                } else if (slideshowTitles[index] === "Make trip slideshow") {
                    if (entry.content && entry.content.$t) {
                        const content = entry.content.$t; // HTML content of the entry
                        const parser = new DOMParser();
                        const htmlDoc = parser.parseFromString(content, 'text/html');
                        const postTitle = entry.title?.$t || "Untitled Post"; // Ensure a valid post title
                        const captions = getCaptions(htmlDoc);

                        // Parse <img> elements
                        const images = [...htmlDoc.querySelectorAll('img')]
                        .slice(1) // Exclude the first <img> element
                        .map((img, idx) => ({
                            type: 'img',
                            src: img.getAttribute('src'),
                            caption: captions[idx + 1] || '', // Shift index to match remaining images
                            position: htmlDoc.body.innerHTML.indexOf(img.outerHTML), // Get the position of the <img> in the content
                            dataSkip: img.getAttribute('data-skip') || "3" // Default value if missing
                        }));

                        // Get saved slider value
                        const PhotosRange = localStorage.getItem('photosSliderValue') || initPhotos; // Default value if not set

                        // Filter images based on `data-skip`, but keep SVGs
                        const filteredImages = images.filter(image => {
                            const src = image.src || "";
                            
                            // Always keep SVG-created images
                            if (src.startsWith("data:image/svg+xml")) {
                                return true;
                            }

                            let dataSkip = image.dataSkip.toLowerCase();

                            // Replace text-based `data-skip` values with numeric equivalents
                            dataSkip = dataSkip.replace(/best/g, "0").replace(/cover/g, "-1").replace(/peak/g, "-2");

                            // Split into array
                            const dataSkipValues = dataSkip.split(";");

                            return dataSkipValues.some(value => {
                                if (!isNaN(value)) {
                                    const numericValue = parseFloat(value);

                                    // Exclude if the only tag is `-2` (peak)
                                    if (numericValue === -2) {
                                        return false;
                                    }

                                    return numericValue <= PhotosRange;
                                }
                                return false;
                            });
                        });

                        // Parse <script> elements containing post IDs
                        const scriptMatches = content.match(/<script>[\s\S]*?var\s+postID\d+\s*=\s*'([^']+)';[\s\S]*?<\/script>/g);
                        const scripts = scriptMatches
                            ? scriptMatches.map(script => {
                                    const match = script.match(/var\s+postID\d+\s*=\s*'([^']+)'/);
                                    return match
                                        ? {
                                            type: 'script',
                                            postId: match[1],
                                            scriptContent: script,
                                            position: htmlDoc.body.innerHTML.indexOf(script) // Get the position of the <script> in the content
                                        }
                                        : null;
                                }).filter(Boolean)
                            : [];

                        // Combine filtered images and scripts into a single array
                        const mixElements = [...filteredImages, ...scripts];

                        // Ensure the combined array is sorted by their position in the original content
                        mixElements.sort((a, b) => a.position - b.position);

                        // Log the sorted array, just for debug
                        // console.log(`Mixed elements:`, mixElements);

                        // Process each element based on its type
                        for (const element of mixElements) {
                            if (element.type === 'img') {
                                slideshows[index].imageBuffer.push({
                                    src: element.src,
                                    caption: element.caption,
                                    title: postTitle, // Ensure the correct title is passed
                                    date: postDate,
                                });
                            } else if (element.type === 'script') {
                                const additionalPostId = element.postId;
                                const additionalPostUrl = `${WindowBaseUrl}/data/posts/${additionalPostId}.json`;
                                

                                try {
                                    const additionalPostResponse = await fetch(additionalPostUrl);

                                    if (!additionalPostResponse.ok) {
                                        console.error(`Failed to fetch additional post with ID ${additionalPostId}: HTTP ${additionalPostResponse.status}`);
                                        continue;
                                    }

                                    const additionalPostData = await additionalPostResponse.json();
                                    let additionalEntries = additionalPostData.entry;

                                    if (additionalEntries && !Array.isArray(additionalEntries)) {
                                        additionalEntries = [additionalEntries];
                                    }

                                    // Ensure correct title extraction from additional post
                                    const additionalPostTitle = additionalPostData.entry?.title?.$t || `Post ID: ${additionalPostId}`;

                                    // Process each additional entry
                                    additionalEntries.forEach(additionalEntry => {
                                        processEntry(index, additionalEntry);
                                        // console.log(`Adding images from additional entry with post ID: ${additionalPostId}`);
                                        console.log(`Adding images from additional entry with title: ${additionalPostTitle}`);
                                    });
                                } catch (err) {
                                    console.error(`Error fetching additional post with ID ${additionalPostId}:`, err);
                                }
                            }
                        }
                    } else {
                        console.warn(`Entry content is missing or undefined for index: ${index}`);
                    }
                }
            }

            // Handle non-"All pictures" cases
            if (slideshowTitles[index] !== "All pictures") {
                if (slideshowTitles[index] === "Make post slideshow" || slideshowTitles[index] === "Make trip slideshow") {
                    console.log('Fetched', slideshows[index].imageBuffer.length, 'images for title:', postId);
                    document.getElementById('imagesLoadedCount').textContent = slideshows[index].imageBuffer.length;
                } else {
                    console.log('Fetched', slideshows[index].imageBuffer.length, 'images for title:', slideshowTitles[index]);
                    document.getElementById('imagesLoadedCount').textContent = slideshows[index].imageBuffer.length;
                }

                slideshows[index].shuffledImages = shuffleArray(slideshows[index].imageBuffer.slice(), index);
                buildSlides(index);
            }

            // Recursively fetch more data for "All pictures" (DISABLED: now single JSON file)
            // slideshows[index].startIndex += slideshows[index].maxResults;
            // fetchData(index); // Fetch the next batch of pictures

        })
        .catch(error => {
            console.error('Error fetching data:', error);
            console.error('Error: Possible typo in the post title. Please check for any mistakes.');

            // In case of an error, hide the current slideshow container
            const wrapperDiv = document.getElementById(`slideShow-${index}`);
            if (wrapperDiv) {
                wrapperDiv.style.display = 'none'; // Hide the slideshow div
            }
        });
}


/**
 * @brief   Extracts the post ID from the anchor tag.
 *
 * @details This function searches for an anchor (`<a>`) element with a `name` attribute in the document and 
 *          retrieves the value of the `name` attribute, which is assumed to be the post ID. If the anchor 
 *          tag is found, the post ID is returned; otherwise, `null` is returned.
 *
 * @return  The post ID extracted from the `name` attribute of the anchor tag, or `null` if no anchor is found.
 */
function getPostIdFromAnchor() {
    const anchor = document.querySelector('a[name]');
    if (anchor) {
        return anchor.getAttribute('name'); // Get the 'name' attribute value (the post ID)
    }
    return null;
}



/**
 * @brief   Shuffles an array of images or modifies the array based on slideshow type.
 *
 * @details This function shuffles an array of images using the Fisher-Yates algorithm if the slideshow is of type "All pictures". 
 *          For other slideshow types, it sets the first element of the array to a predefined image (`endImage`) and removes the 
 *          cover photo from the first index.
 *
 * @param   array  The array to be shuffled or modified.
 * @param   index  The index of the slideshow, used to determine the slideshow type.
 *
 * @return  Returns the shuffled or modified array.
 */
function shuffleArray(array, index) {
    // default ON unless user explicitly turned it off
    const randomizeImages = localStorage.getItem('randomizeImages') !== null
        ? localStorage.getItem('randomizeImages') === 'true'
        : true;

    if (slideshowTitles[index] === "All pictures") {
        if (randomizeImages) {
            // Fisher–Yates shuffle
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        } else {
            // Reverse so oldest comes first
            // array.reverse();
        }
    } else {
        // Set endImage as first element
        array.unshift(endImage);
    }
    return array;
}


/**
 * @brief   Builds and displays slides for a slideshow.
 *
 * @details Initializes the slideshow by setting up slides, enabling navigation 
 *          buttons, and making the overlay clickable for slideshow control. 
 *          Marks the slideshow as ready for interaction.
 *
 * @param   index Index of the slideshow to build and display.
 */
function buildSlides(index) {

    // Initialize all slides
    initializeSlides(index);

    // Unhide buttons after initialization of slideshow
    toggleNavigationButton[index].style.display = 'block'; // Show navigation bar
    toggleNavigation(index);

    // Now keylisteners can be initialized
    slideshows[index].isSlideshowReady = true;

    // Enable clickable overlay for slideshow controll
    const overlay = document.getElementById(`overlayContainer-${index}`);
    if (overlay) {
        overlay.style.height = '100%'; // Make overlay clickable
    }
    
    //showSlides(index); // Start the slideshow initially
}


/**
 * @brief   Initializes slides by preloading images and setting their content.
 *
 * @details Iterates through the slide containers of the specified slideshow index, 
 *          preloads images, and updates image sources, captions, and related content 
 *          based on the shuffled image data.
 *
 * @param   index Index of the slideshow whose slides are to be initialized.
 */
function initializeSlides(index) {
    for (let i = 0; i < slideContainers[index].length; i++) {
        const imageObj = slideshows[index].shuffledImages[i];

        // Check if the image exists and has a valid src before using it
        if (imageObj && imageObj.src) {
            // Preload next/prev images
            preloadImage(imageObj.src);

            const imgElement = slideContainers[index][i].querySelector('img');
            imgElement.src = imageObj.src;

            // Set captions
            slideContainers[index][i].querySelector('.text').textContent = imageObj.caption || '';
            slideContainers[index][i].querySelector('.uppertext').textContent = imageObj.title || '';
            slideContainers[index][i].querySelector('.date').textContent = imageObj.date || '';
        }
    }
}



// /**
//  * @brief   Preloads an image asynchronously.
//  *
//  * @details Creates a new `Image` object, sets its source to the provided URL, and 
//  *          resolves the promise when the image is successfully loaded. Rejects the 
//  *          promise if there is an error during loading.
//  *
//  * @param   src URL of the image to be preloaded.
//  *
//  * @return  A Promise that resolves with the loaded `Image` object or rejects if loading fails.
//  */
// function preloadImage(src) {
//     return new Promise((resolve, reject) => {
//         const img = new Image();
//         img.src = src;
//         img.onload = resolve;
//         img.onerror = reject;
//     });
// }


/**
 * @brief   Preloads an image and caches it, ensuring efficient memory usage.
 *
 * @details This function attempts to load an image asynchronously and stores it in a cache
 *          if successfully loaded. The cache uses an approximate size-based limit to manage
 *          memory usage. If the image is already in the cache, it returns the cached version
 *          directly. The function calculates the image size based on its dimensions and 
 *          stores it along with the image in the cache.
 *
 * @param   src The URL of the image to be preloaded.
 *
 * @return  A Promise that resolves with the loaded `Image` object, or rejects if loading fails.
 *
 * @note    The cache calculates the size as width × height × 4 bytes (RGBA), providing a rough
 *          estimate of memory usage. This ensures the cache remains within acceptable limits
 *          for performance and memory efficiency.
 */
async function preloadImage(src) {
    if (imageCache.has(src)) return imageCache.get(src); // Return cached image if available

    const loadPromise = new Promise((resolve, reject) => {
        const img = new Image();

        const onLoad = () => {
        const width = img.naturalWidth;
        const height = img.naturalHeight;

        if (!width || !height || isNaN(width) || isNaN(height)) {
            console.warn(`Skipping cache for ${src}: invalid image dimensions.`);
            resolve(img);
            cleanup();
            return;
        }

        const size = width * height * 4; // Estimate: 4 bytes per pixel
        imageCache.set(src, img, size);
        resolve(img);
        cleanup();
    };

        const onError = () => {
            reject(new Error(`Failed to load: ${src}`));
            cleanup();
        };

        const cleanup = () => {
            img.removeEventListener('load', onLoad);
            img.removeEventListener('error', onError);
        };

        img.addEventListener('load', onLoad);
        img.addEventListener('error', onError);
        img.src = src;
    });

    return loadPromise;
}


/**
 * @brief   Toggles the navigation layout and visibility in a slideshow.
 *
 * @details Changes the navigation control layout or visibility based on the click count:
 *          - First click: Switches the layout to vertical.
 *          - Second click: Hides all navigation buttons except the toggle button and changes background color.
 *          - Third click: Resets to the original horizontal layout, restores button visibility, and resets the click count.
 *
 * @param   index Index of the slideshow to toggle navigation for.
 */
function toggleNavigation(index) {
    if (slideshows[index].clickCount === 0) {
        // First click: Change layout from horizontal to vertical
        navigationControl[index].classList.add('vertical');
    } else if (slideshows[index].clickCount === 1) {
        // Second click: Hide all buttons except toggle button
        slideshows[index].previousBackgroundColor = navigationControl[index].style.backgroundColor;
        navigationControl[index].style.backgroundColor = 'rgba(255, 255, 255, 0.15)';
        navigationControlButtons[index].forEach(button => button && (button.style.display = 'none'));
    } else {
        // Third click: Reset everything (show all buttons and set layout to horizontal)
        navigationControl[index].style.backgroundColor = slideshows[index].previousBackgroundColor;
        navigationControl[index].classList.remove('vertical');
        navigationControlButtons[index].forEach(button => button && (button.style.display = 'inline-block'));
        slideshows[index].clickCount = -1;  // Reset counter
    }
    slideshows[index].clickCount++;
}


/**
 * @brief   Toggles the visibility and appearance of image descriptions in a slideshow.
 *
 * @details Cycles through three interactive states based on the number of times the toggle button is clicked:
 *          1. **First click:** Adds a semi-transparent dark background to all image descriptions to improve readability.
 *          2. **Second click:** Removes the background color, making it fully transparent.
 *          3. **Third click:** Hides all image descriptions and resets the click count to restart the cycle.
 *
 *          This function selects the description group corresponding to the provided slideshow index 
 *          and dynamically updates the styles of descriptions according to the current state.
 *
 * @param   index Index of the slideshow for which to toggle the descriptions.
 */
function toggleDescription(index) {
    // Retrieve the specific description group for the current slideshow index
    const descriptions = descriptionControlStyle[index];

    if (slideshows[index].descriptionClickCount === 0) {
        // First click: Set semi-transparent dark background for all descriptions
        descriptions.forEach(description => {
            description.style.backgroundColor = 'rgba(0, 0, 0, 0.55)';
            description.style.display = ''; // Ensure the description is visible
        });
    } else if (slideshows[index].descriptionClickCount === 1) {
        // Second click: Make the background of all descriptions fully transparent
        descriptions.forEach(description => {
            description.style.backgroundColor = 'rgba(0, 0, 0, 0)';
        });
    } else {
        // Third click: Hide all descriptions and reset the click count
        descriptions.forEach(description => {
            description.style.display = 'none'; // Hide the description
        });
        slideshows[index].descriptionClickCount = -1; // Reset the click counter
    }
    // Increment the click count
    slideshows[index].descriptionClickCount++;
}


/**
 * @brief   Sets the quality of the slideshow based on the container width.
 *
 * @details This function calculates the quality value of the slideshow based on the width of the outer container. 
 *          It sets the value of the quality slider and updates the displayed quality value accordingly. 
 *          Additionally, it calls a function to update the color of the slider based on the new value.
 *
 * @param   index  The index of the slideshow, used to identify the corresponding elements.
 */
function setSlideshowQuality(index) {                 
    // Ensure the element exists
    if (!slideshowContainer[index]) return; 

    // Get the current width of the outer container
    const containerWidth = slideshowContainer[index].offsetWidth;

    // Update the quality slider value based on the container width
    qualitySliderElement[index].value = Math.ceil(containerWidth / 400);
    qualityValueElement[index].textContent = Math.ceil(containerWidth / 400);

    // Call the function to update the slider color
    updateSliderColor(index);
}


/**
 * @brief   Processes a blog entry and extracts images and captions for the slideshow.
 *
 * @details This function parses the content of a blog entry, extracts image sources and captions, and stores them 
 *          in the `imageBuffer`. It also adjusts the image sizes based on the dimensions of the slideshow container.
 *          Images with a `data-skip` attribute greater than the current photo slider value are skipped. The images are 
 *          resized according to the larger dimension of the container (width or height) and added to the slideshow buffer 
 *          along with the associated caption and post title.
 *
 * @param   index   The index of the slideshow to process.
 * @param   entry   The blog entry object containing content and metadata.
 */
function processEntry(index, entry) {
    const content = entry.content.$t;
    const parser = new DOMParser();
    const htmlDoc = parser.parseFromString(content, 'text/html');
    const images = htmlDoc.getElementsByTagName('img');
    const postTitle = entry.title.$t;
    const postDateRaw = entry.published?.$t || '';
    const postDate = postDateRaw
        ? new Date(postDateRaw).toLocaleDateString('sl-SI')
        : '';
    const captions = getCaptions(htmlDoc);

    // Get the width and height of the slideshow container in pixels
    const containerWidth = slideshowContainer[index].offsetWidth; // Detects the width in pixels
    const containerHeight = slideshowContainer[index].offsetHeight; // Detects the height in pixels

    // Assign the bigger value to determine size
    const containerSize = Math.max(containerWidth, containerHeight); // Determine the larger value

    // Loop through the images and process their `data-skip` attribute
    for (let i = 1; i < images.length; i++) { // Start with 1 - do not include cover photo
        // Check if the image has a data-skip attribute with a value greater than value saved in initPhotos
        const PhotosRange = localStorage.getItem('photosSliderValue') || initPhotos; // Default value if not set
        // Extract the `data-skip` attribute content
        let dataSkip = images[i].getAttribute('data-skip');

        // Assign a default value to `data-skip` if undefined or "NA"
        if (dataSkip === "NA" || dataSkip === null || dataSkip === undefined) {
            dataSkip = "3"; // Assign a default value
        }

        // Replace "best" with "0" in the `data-skip` values
        dataSkip = dataSkip.replace(/best/g, "0");

        // Replace "cover" with "-1" in the `data-skip` values
        dataSkip = dataSkip.replace(/cover/g, "-1");

        // Replace "peak" with "-2" in the `data-skip` values
        dataSkip = dataSkip.replace(/peak/g, "-2");

        // Split `data-skip` values by semicolon
        const dataSkipValues = dataSkip.split(";");

        // Check if any value in `data-skip` matches or is within the PhotosRange
        const isWithinRange = dataSkipValues.some(value => {
            if (!isNaN(value)) {
                const numericValue = parseFloat(value); // Parse each value to a number

                // Exclude -2 (peaks) only if it is the ONLY value in dataSkipValues
                if (numericValue === -2) {
                    return false;
                }

                // For other ranges, check if the value is within the range
                return numericValue <= PhotosRange;
            }
            return false; // Non-numeric values are ignored
        });

        // Perform the desired action based on the range check
        if (isWithinRange) {
            // Replace image size with WebP-enabled format using -rw
            let imgSrc = images[i].getAttribute('src')
                .replace(/\/s\d+(-rw)?\/|\/w\d+-h\d+\//, `/s${containerSize}-rw/`);
            
            const caption = captions[i] || '';
            slideshows[index].imageBuffer.push({ src: imgSrc, caption, title: postTitle, date: postDate });
        }
    }        
}


/**
     * @brief   Extracts captions for images from the HTML document.
     *
     * @details This function processes an HTML document, finds all images, and attempts to associate captions with 
     *          each image. Captions are stored in elements with the class `tr-caption`, and the function matches each
     *          caption to the corresponding image based on their order in the document. If no caption is found for an 
     *          image, an empty string is assigned. The function returns an array of captions corresponding to the images.
     *
     * @param   htmlDoc   The HTML document object to extract captions from.
     *
     * @return  An array of captions, where each element corresponds to a caption for an image.
     */
function getCaptions(htmlDoc) {
    const images = htmlDoc.getElementsByTagName('img');
    const captionElements = htmlDoc.getElementsByClassName('tr-caption');
    const captions = [];
    let captionIndex = 0;

    for (let i = 0; i < images.length; i++) {
        let caption = '';
        while (captionIndex < captionElements.length) {
            const currentCaptionElement = captionElements[captionIndex];
            const nextImageElement = images[i + 1];
            if (!nextImageElement || currentCaptionElement.compareDocumentPosition(nextImageElement) & Node.DOCUMENT_POSITION_FOLLOWING) {
                caption = currentCaptionElement.textContent.trim();
                captionIndex++;
                break;
            }
            break;
        }
        captions.push(caption);
    }
    return captions;
}


/**
     * @brief   Adjusts the slideshow speed based on slider input.
     *
     * @details This function retrieves the value from a speed slider input element, converts it from seconds to milliseconds, 
     *          and updates the slideshow speed accordingly. The speed value is also displayed to the user.
     *
     * @param   index  The index of the slideshow for which the speed needs to be adjusted.
     *
     * @return  None.
     */
function updateSlideshowSpeed(index) {
    const speedInSeconds = speedSliderElement[index].value;
    slideshows[index].slideshowSpeed = speedInSeconds * 1000; // Convert to milliseconds
    speedValueElement[index].textContent = speedInSeconds; // Update the speed value display
}


/**
     * @brief   Retries initializing functions after DOMContentLoaded and slideshow setup.
     *
     * @details This function checks if the slideshow is ready. If so, it initializes the necessary event listeners 
     *          and starts observing the wrappers. If the slideshow is not yet initialized, it retries the process after a short delay.
     *
     * @param   index  The index of the slideshow to check and initialize.
     *
     * @return  None.
     */
function checkAndInitialize(index) {
    if (slideshows[index].isSlideshowReady) { // Check if the slideshow is ready and DOM is loaded
        initializeKeyboardListeners(index); // Set up keyboard listeners
        observeVisibleWrappers(); // Start observing wrappers
    } else {
        // Retry after a short delay if the slideshow is not yet ready
        console.log("Slideshow not fully initialized yet. Retrying...");
        setTimeout(() => checkAndInitialize(index), 500); // Retry after 500ms
    }
}


/**
     * @brief   Initializes keyboard listeners for slideshow control.
     *
     * @details This function sets up event listeners for keydown events to control various aspects of the slideshow.
     *          Each key press triggers specific actions, such as navigating through slides, toggling slideshow play/pause, 
     *          toggling fullscreen, changing quality settings, and more.
     *
     * @param   index  The index of the active slideshow to control with keyboard inputs.
     *
     * @return  None.
     */
function initializeKeyboardListeners(index) {
    document.addEventListener('keydown', ({ key, ctrlKey, metaKey, altKey }) => {
        // Allow browser shortcuts like Ctrl+F / Cmd+F
        if (ctrlKey || metaKey || altKey) return;

        // Determine which slideshow to control
        const index = activeFullscreenIndex !== null ? activeFullscreenIndex : currentSlideshowIndex;

        const actions = {
            ArrowRight: () => enqueueManualSlide(index, 1), // Next photo
            ArrowLeft: () => enqueueManualSlide(index, -1), // Previous photo
            s: () => (slideshows[index].isSlideshowRunning
                ? pauseSlideshow
                : resumeSlideshow)(index, SLIDESHOW_VISIBLE), // Toggle slideshow (start/pause)
            n: () => toggleNavigation(index), // Toggle navigation
            u: () => toggleDescription(index), // Toggle image description style
            f: () => toggleFullscreen(index), // Toggle fullscreen
            q: () => {
                autoQualityCheckbox[index].checked = !autoQualityCheckbox[index].checked;
                autoSetQuality(index);
            }, // Enable/disable auto quality
            p: () => preloadAllImages(index), // Preload all images
            t: () => toggleSlideshowOrImageVisibility(index), // Toggle slideshow or image visibility
            b: () => toggleProgressBarVisibility(index, 0, 'key'), // Toggle progressBar visibility
            e: () => {slideshows[index].errorFlag = !slideshows[index].errorFlag; console.log(`Error flag is now ${slideshows[index].errorFlag ? 'ON' : 'OFF'}`); }, // Toggle error flag
            '+': () => { speedSliderElement[index].value = Math.min(Number(speedSliderElement[index].value) + stepSpeed, maxSpeed); updateSlideshowSpeed(index); },
            '-': () => { speedSliderElement[index].value = Math.max(Number(speedSliderElement[index].value) - stepSpeed, minSpeed); updateSlideshowSpeed(index); },

            // Number controls
            '5': () => (slideshows[index].isSlideshowRunning
                ? pauseSlideshow
                : resumeSlideshow)(index, SLIDESHOW_VISIBLE), // Toggle slideshow (start/pause)
            '2': () => toggleNavigation(index), // Toggle navigation
            '7': () => toggleDescription(index), // Toggle image description style
            '1': () => toggleFullscreen(index), // Toggle fullscreen
            '9': () => {
                autoQualityCheckbox[index].checked = !autoQualityCheckbox[index].checked;
                autoSetQuality(index);
            }, // Enable/disable auto quality
            '0': () => preloadAllImages(index), // Preload all images
            '3': () => toggleProgressBarVisibility(index, 0, 'key'), // Toggle progressBar visibility
            '8': () => {slideshows[index].errorFlag = !slideshows[index].errorFlag; console.log(`Error flag is now ${slideshows[index].errorFlag ? 'ON' : 'OFF'}`); }, // Toggle error flag
            '4': () => { speedSliderElement[index].value = Math.min(Number(speedSliderElement[index].value) + stepSpeed, maxSpeed); updateSlideshowSpeed(index); },
            '6': () => { speedSliderElement[index].value = Math.max(Number(speedSliderElement[index].value) - stepSpeed, minSpeed); updateSlideshowSpeed(index); }
        };

        actions[key]?.(); // Execute action if the key is in the actions map
    });
}


/**
* @brief   Toggles the visibility and height of the progress bar for a slideshow.
*
* @details This function adjusts the height of the progress bar based on the specified mode. 
*          In 'hover' mode, it sets the progress bar to a specified height if it is initially hidden. 
*          In 'key' mode, it toggles the height of the progress bar between '0px' (hidden) and '5px' (visible). 
*          The function ensures the progress bar element exists before making any changes and logs an error if not found.
*
* @param   index  The index of the slideshow whose progress bar visibility needs to be toggled.
* @param   height The height to set the progress bar to when it is shown (e.g., '5px').
* @param   mode   The mode of operation, either 'hover' or 'key'. In 'hover', the height is set when hovered. 
*                 In 'key', it toggles the height between '0px' and '5px'.
*
* @return  None.
*/
function toggleProgressBarVisibility(index, height, mode) {
    const progressBar = document.getElementById(`progressBar-${index}`);
    if (!progressBar) {
        console.error(`Progress container for slideshow ${index} not found.`);
        return;
    }
    // Manage height and state of progress bar
    if ((mode == 'hover') && (slideshows[index].progressBarHeightKey == '0px')) {
        progressBar.style.height = height;
    } else if (mode == 'key') {
        progressBar.style.height = progressBar.style.height === '0px' ? 
            (slideshows[index].progressBarHeightKey = '5px') : 
            (slideshows[index].progressBarHeightKey = '0px');
    }
}


/**
* @brief   Toggles the visibility of slideshows and images.
*
* @details This function checks the current visibility of slideshows and switches between showing slideshows
*          or images based on the current visibility state. It also updates the button's SVG and text to indicate
*          the current mode (either "Presentation" mode with slideshows or "Image" mode with images). The function
*          will also pause the slideshow and hide all slideshows when switching to image view, and resume the slideshow
*          when switching back to presentation mode. The function utilizes a set of DOM elements (e.g., myPostContainers, separators, tables)
*          to toggle their visibility accordingly.
*
* @param   index  The index of the current slideshow to manage (used for pausing the slideshow).
*
* @return  None.
*/
function toggleSlideshowOrImageVisibility(index) {
    const separators = document.querySelectorAll('.separator');
    const myPostContainers = document.querySelectorAll('.my-post-container');
    const tables = document.querySelectorAll('table.tr-caption-container');

    // Update image sources to normal size
    updateImageSources(1200);

    // Flag to track if any slideshow is visible
    let isSlideshowVisible = false;

    // Iterate over all slideshows to check visibility
    mySlideshowContainer.forEach(function(slideshowDiv) {
        if (slideshowDiv.style.display === "block") {
            isSlideshowVisible = true; // Set to true if any slideshow is visible
        }
    });

    // Toggle based on whether slideshows are currently visible or not
    if (isSlideshowVisible) {
        // Pause slideshow if switch on images
        pauseSlideshow(index, SLIDESHOW_VISIBLE);

        // Hide all slideshows and show images
        mySlideshowContainer.forEach(function(slideshowDiv) {
            slideshowDiv.style.display = "none"; // Hide all slideshows
        });
        myPostContainers.forEach(function(myPostContainer) {
            myPostContainer.style.display = 'block'; // Show post containers
        });
        separators.forEach(function(separator) {
            separator.style.display = 'block'; // Show separators
        });
        tables.forEach(function(table) {
            table.style.display = 'table'; // Show tables
        });

        // Change SVG and button text for "Presentation" mode
        toggleButton.innerHTML = `
            <svg version="1.1" id="Icons" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" xml:space="preserve" width="80px" height="60px" fill="#000000">
                <g id="SVGRepo_iconCarrier"> 
                    <style type="text/css"> .st0{fill:none;stroke:#000000;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;} </style> 
                    <polyline class="st0" points="25,11 27,13 25,15 "></polyline> 
                    <polyline class="st0" points="7,11 5,13 7,15 "></polyline> 
                    <path class="st0" d="M29,23H3c-1.1,0-2-0.9-2-2V5c0-1.1,0.9-2,2-2h26c1.1,0,2,0.9,2,2v16C31,22.1,30.1,23,29,23z"></path> 
                    <circle class="st0" cx="16" cy="28" r="1"></circle> 
                    <circle class="st0" cx="10" cy="28" r="1"></circle> 
                    <circle class="st0" cx="22" cy="28" r="1"></circle> 
                </g>
            </svg>
        `;
    } else {
        // Show all slideshows and hide images
        mySlideshowContainer.forEach(function(slideshowDiv) {
            slideshowDiv.style.display = "block"; // Show all slideshows
        });
        myPostContainers.forEach(function(myPostContainer) {
            myPostContainer.style.display = 'none'; // Hide post containers
        });
        separators.forEach(function(separator) {
            separator.style.display = 'none'; // Hide separators
        });
        tables.forEach(function(table) {
            table.style.display = 'none'; // Hide tables
        });

        // Change SVG and button text for "Image" mode
        toggleButton.innerHTML = `
            <svg fill="#000000" width="120px" height="120px" viewBox="0 0 36 36" version="1.1" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                <g id="SVGRepo_iconCarrier"> 
                    <path fill="#000000" d="M32.12,10H3.88A1.88,1.88,0,0,0,2,11.88V30.12A1.88,1.88,0,0,0,3.88,32H32.12A1.88,1.88,0,0,0,34,30.12V11.88A1.88,1.88,0,0,0,32.12,10ZM32,30H4V12H32Z" class="clr-i-outline clr-i-outline-path-1"></path>
                    <path fill="#000000" d="M8.56,19.45a3,3,0,1,0-3-3A3,3,0,0,0,8.56,19.45Zm0-4.6A1.6,1.6,0,1,1,7,16.45,1.6,1.6,0,0,1,8.56,14.85Z" class="clr-i-outline clr-i-outline-path-2"></path>
                    <path fill="#000000" d="M7.9,28l6-6,3.18,3.18L14.26,28h2l7.46-7.46L30,26.77v-2L24.2,19a.71.71,0,0,0-1,0l-5.16,5.16L14.37,20.5a.71.71,0,0,0-1,0L5.92,28Z" class="clr-i-outline clr-i-outline-path-3"></path>
                    <path fill="#000000" d="M30.14,3h0a1,1,0,0,0-1-1h-22a1,1,0,0,0-1,1h0V4h24Z" class="clr-i-outline clr-i-outline-path-4"></path>
                    <path fill="#000000" d="M32.12,7V7a1,1,0,0,0-1-1h-26a1,1,0,0,0-1,1h0V8h28Z" class="clr-i-outline clr-i-outline-path-5"></path> 
                    <rect x="0" y="0" width="36" height="36" fill-opacity="0"></rect> 
                </g>
            </svg>
        `;
    }
}


/**
 * @brief   Preloads all images for a specified slideshow.
 *
 * @details This function iterates over all shuffled images in a slideshow and preloads each image by calling 
 *          a helper function `preloadImage`. Once all images are successfully preloaded, a message is logged to 
 *          the console. If any error occurs during the preloading process, an error message is logged.
 *
 * @param   index  The index of the slideshow whose images need to be preloaded.
 *
 * @return  A Promise that resolves when all images have been preloaded or rejects if an error occurs.
 */
function preloadAllImages(index) {
    return Promise.all(slideshows[index].shuffledImages.map(img => preloadImage(img.src)))
        .then(() => {
            console.log("All images preloaded");
            if (coverPhotoContainer[index]) {
                // Show the overlay with the "Slike so pripravljene" message
                photoOverlay[index].style.display = 'block';
                photoOverlay[index].innerHTML = '<span class="connection-error">Slike so pripravljene</span>';
                photoOverlay[index].style.color = 'white';
                photoOverlay[index].style.zIndex = '2'; // Set the z-index to 2
                
                // Hide the overlay and change the message after 1 second
                setTimeout(() => {
                    photoOverlay[index].style.display = 'none'; // Hide the overlay
                    photoOverlay[index].innerHTML = '<span class="connection-error">Ojoj, internetna povezava ne omogoča take hitrosti pri nastavljeni kvaliteti slik</span>';
                }, 2000); // 2 second timeout
            }
        })
        .catch(error => console.error("Error preloading images:", error));
}


/**
 * @brief   Toggles fullscreen mode for a specific slideshow.
 *
 * @details This function checks if the document is currently in fullscreen mode. If it is, it exits fullscreen and
 *          removes the fullscreen class from all relevant slideshow containers. If it is not in fullscreen, it requests
 *          fullscreen for the specified slideshow, adds the fullscreen class, and forces landscape orientation on mobile.
 *          Additionally, the function toggles the light theme for the slideshow and calls `autoSetQuality` with a slight delay.
 *
 * @param   index  The index of the slideshow that should enter or exit fullscreen mode.
 *
 * @return  None.
 */
function toggleFullscreen(index) {
    const wrapper = document.querySelector(`#slideshowOuterContainer-${index}`);
    if (!wrapper) return;

    if (document.fullscreenElement) {
        // Exit fullscreen
        document.exitFullscreen().then(() => {
            activeFullscreenIndex = null; // Reset fullscreen index

            // Unlock orientation on mobile
            if (screen.orientation && screen.orientation.unlock) {
                screen.orientation.unlock();
            }
        });

        [progressBarContainer[index], slideshowContainer[index], slideshowOuterContainer[index], mySlideshowContainer[index]]
            .forEach(el => el.classList.remove('fullscreen')); // Remove fullscreen class
    } else {
        // Enter fullscreen
        wrapper.requestFullscreen().then(() => {
            activeFullscreenIndex = index; // Set the active fullscreen slideshow

            // Force landscape orientation on mobile
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {
                    console.warn('Orientation lock not supported on this device/browser.');
                });
            }
        });

        [progressBarContainer[index], slideshowContainer[index], slideshowOuterContainer[index], mySlideshowContainer[index]]
            .forEach(el => el.classList.add('fullscreen')); // Add fullscreen class
    }

    // Toggle light theme
    if (document.fullscreenElement) {
        slideshowContainer[index].classList.remove('light-theme'); // Remove light theme if in fullscreen
    } else {
        slideshowContainer[index].classList.add('light-theme'); // Add light theme if not in fullscreen
    }

    // Delay execution of autoSetQuality
    setTimeout(() => autoSetQuality(index), 250);
}


/**
 * @brief   Pauses the slideshow by clearing the timeout.
 *
 * @details This function stops the slideshow by clearing the timeout that controls the slide transitions. It also tracks 
 *          the state of the slideshow (whether it was running or not) before pausing. The slideshow state is updated, 
 *          and the toggle button is updated to reflect the paused state of the slideshow.
 *
 * @param   index              The index of the slideshow to be paused.
 * @param   isSlideshowHidden  A flag indicating whether the slideshow is hidden or not.
 *
 * @return  None.
 */
    function pauseSlideshow(index, isSlideshowHidden) {
    if(!isSlideshowHidden){
        // Track state
        slideshows[index].wasSlideshowRunning = slideshows[index].isSlideshowRunning;
    }
    clearTimeout(slideshows[index].slideshowTimeout);
    slideshows[index].isSlideshowRunning = false;
    updateToggleButton(index, slideshows[index].isSlideshowRunning); // Update button on pause
}


/**
 * @brief   Updates the toggle button icon and tooltip based on the slideshow state.
 *
 * @details This function changes the icon and tooltip of the toggle button based on whether the slideshow is playing or paused.
 *          If the slideshow is playing, it will display the pause icon and update the tooltip to "Ustavi" (Stop).
 *          If the slideshow is paused, it will display the play icon and update the tooltip to "Predvajaj" (Play).
 *
 * @param   index      The index of the slideshow whose toggle button needs to be updated.
 * @param   isPlaying  A boolean indicating whether the slideshow is currently playing or paused.
 *
 * @return  None.
 */
function updateToggleButton(index, isPlaying) {
    if (isPlaying) {
        playIcon[index].style.display = "none";
        pauseIcon[index].style.display = "block";
        toggleTooltip[index].textContent = "Ustavi";
    } else {
        playIcon[index].style.display = "block";
        pauseIcon[index].style.display = "none";
        toggleTooltip[index].textContent = "Predvajaj";
    }
}


/**
 * @brief   Resumes the slideshow by restarting the timeout and updating the state.
 *
 * @details This function resumes the slideshow if it was previously paused. It updates the state to indicate that the slideshow
 *          is running, changes the toggle button to reflect the play state, and restarts the slideshow by calling `showSlides`.
 *          The slideshow will not resume if it was hidden and was not previously running.
 *
 * @param   index              The index of the slideshow to be resumed.
 * @param   isSlideshowHidden  A boolean indicating whether the slideshow is hidden or not.
 *
 * @return  None.
 */
function resumeSlideshow(index, isSlideshowHidden) {       
    if(!(isSlideshowHidden && (slideshows[index].wasSlideshowRunning == false)) ) {
        slideshows[index].isSlideshowRunning = true;
        updateToggleButton(index, slideshows[index].isSlideshowRunning); // Update button on resume
        showSlides(index); // Restart the slideshow
    }
}


/**
 * @brief   Starts the automatic slideshow by calling the unified slide function.
 *
 * @details This function initiates the automatic sliding of images by invoking the `changeSlide` function. The slide change 
 *          is done with a direction of 1 (next slide) and without manually triggering the slide change.
 *
 * @param   index  The index of the slideshow for which the automatic slide change is triggered.
 *
 * @return  None.
 */
async function showSlides(index) {
    changeSlide(index, 1, false);
}


/**
 * @brief   Changes the slide in the slideshow based on the given direction and mode.
 *
 * @details This function handles the logic for changing the slides in the slideshow. It supports both automatic 
 *          and manual slide changes. The direction determines whether the next or previous slide is shown, 
 *          and the `isManual` flag indicates whether the slide change was triggered by the user or automatically.
 *
 * @param   index      The index of the slideshow whose slide is to be changed.
 * @param   direction  The direction to change the slide (1 for next, -1 for previous). Default is 1.
 * @param   isManual   A flag indicating whether the slide change is triggered manually (true) or automatically (false). Default is false.
 *
 * @return  None.
 */
async function changeSlide(index, direction = 1, isManual = false) {              
    // Hide the cover photo - do it once
    if (!slideshows[index].coverPhotoHidden) {
        if (coverPhotoContainer[index]) {
            // Remove the photo if it exists
            if (coverPhotoContainer[index].querySelector('img')) {
                coverPhotoContainer[index].removeChild(coverPhotoContainer[index].querySelector('img'));
            }
            slideshows[index].coverPhotoHidden = true;

            // Prepare message for bad internet connection
            photoOverlay[index].style.display = 'none'; // Hide the overlay
            photoOverlay[index].innerHTML = '<span class="connection-error">Ojoj, internetna povezava ne omogoča take hitrosti pri nastavljeni kvaliteti slik</span>';
            photoOverlay[index].style.color = 'white';
            photoOverlay[index].style.zIndex = '2'; // Set the z-index to 2
        } else {
            console.error('Cover photo container not found.');
        }
    }

    if (slideshows[index].isSlideshowRunning){                 
        clearTimeout(slideshows[index].slideshowTimeout); // Clear the existing automatic timeout to reset it
    }

    // Immediately fade out the active slide
    slideContainers[index][slideshows[index].activeSlide].classList.remove('fade-in');
    slideContainers[index][slideshows[index].activeSlide].classList.add('fade-out'); // Quick fade-out

    // Update slideshows[index].activeSlide for the next iteration before using it
    if (direction === 1) {
        slideshows[index].activeSlide = (slideshows[index].activeSlide + 1) % 3;  // Move forward
    } else {
        slideshows[index].activeSlide = (slideshows[index].activeSlide + 2) % 3;  // Move backward
    }

    // Calculate the previous and next slide container indices
    const prevSlide = (slideshows[index].activeSlide + 2) % 3;  // Previous container (always 2 slides before active)
    const nextSlide = (slideshows[index].activeSlide + 1) % 3;  // Next container (always 1 slide after active)

    // Update the current batch index based on the direction (forward or backward)
    slideshows[index].currentBatchIndex = (slideshows[index].currentBatchIndex + direction + slideshows[index].shuffledImages.length) % slideshows[index].shuffledImages.length;

    // Calculate the previous and next image indices based on the current batch index
    const prevIndex = (slideshows[index].currentBatchIndex - 1 + slideshows[index].shuffledImages.length) % slideshows[index].shuffledImages.length;
    const nextIndex = (slideshows[index].currentBatchIndex + 1) % slideshows[index].shuffledImages.length;

    // After a quick fade-out, proceed to the next steps
    setTimeout(() => {
        // Update only the current slide container with the new image
        updateSlide(index, slideContainers[index][slideshows[index].activeSlide], slideshows[index].shuffledImages[slideshows[index].currentBatchIndex], 'current');

        // Update either the next or previous slide based on the direction of navigation
        if (direction === 1) {
            // If moving forward, update the next slide
            updateSlide(index, slideContainers[index][nextSlide], slideshows[index].shuffledImages[nextIndex], 'next');
            // Start preloading the next image in the background
            preloadThisImage(index, nextIndex);
        } else {
            // If moving backward, update the previous slide
            updateSlide(index, slideContainers[index][prevSlide], slideshows[index].shuffledImages[prevIndex], 'prev');
            // Start preloading the previous image in the background
            preloadThisImage(index, prevIndex);
        }

        // Adjust the slideshow container's height based on the current active slide
        //adjustSlideshowHeight(slideContainers[index][slideshows[index].activeSlide]);

        // After resizing the window, fade in the next slide slowly
        slideContainers[index][slideshows[index].activeSlide].classList.remove('fade-out');
        slideContainers[index][slideshows[index].activeSlide].classList.add('fade-in');

    }, 10); // Delay for fade-out (matches the quick fade-out time)
    if (slideshows[index].isSlideshowRunning){ 
        // Reset the slideshow timeout to continue auto-sliding after manual action
        slideshows[index].slideshowTimeout = setTimeout(() => attemptChangeSlide(index), slideshows[index].slideshowSpeed);
    }

    updateProgressBar(index); // Update the progress bar after changing the slide
}


/**
 * @brief   Updates the slide in a specific container with a new image and its details.
 *
 * @details This function asynchronously loads a new image and updates the slide content, 
 *          including the image source, caption, and upper text. It also handles errors by retrying 
 *          to load the next or previous image if the current one fails to load. 
 *          If the slideshow reaches the end, the slideshow is paused.
 *
 * @param   index          The index of the slideshow being updated.
 * @param   slideContainer The container element of the current slide where the image and text are displayed.
 * @param   entry          The image entry containing the image source, caption, and title to be displayed.
 * @param   direction      The direction ('next' or 'prev') to determine if the next or previous image should be loaded.
 *
 * @return  None.
 */
async function updateSlide(index, slideContainer, entry, direction) {
    const imgElement = slideContainer.querySelector('img');
    const captionElement = slideContainer.querySelector('.text');
    const upperTextElement = slideContainer.querySelector('.uppertext');
    const dateElement = slideContainer.querySelector('.date');

    // Stop slideshow if the flag is set
    if (slideshows[index].pauseSlideshowFlag) {
        pauseSlideshow(index, SLIDESHOW_VISIBLE);
        slideshows[index].pauseSlideshowFlag = false;
    }

    try {
        // Preload the image asynchronously
        await preloadImage(entry.src);

        // Update the slide once the image is loaded
        imgElement.src = entry.src; // Set the valid image source
        captionElement.textContent = entry.caption || ''; // Set caption

        // Set upper text based on the entry title
        if (slideshowTitles[index] === "All pictures") {
            upperTextElement.textContent = entry.title || ''; // Set the title from the entry object
            dateElement.textContent = entry.date || ''; // Set date if available
        } else {
            upperTextElement.textContent = ''; // Clear if not applicable
            dateElement.textContent = '';
        }

        // Set flag to stop slideshow if it reaches the end
        if ((imgElement.src === endImage.src) && slideshows[index].isSlideshowRunning) {
            slideshows[index].pauseSlideshowFlag = true;
        }
    } catch (error) {
        console.warn(`Failed to load image: ${entry.src}. Attempting next/previous.`);

        // Handle image load failure and decide next step
        const nextEntry = getNextOrPreviousEntry(index, entry, direction);

        if (nextEntry) {
            // Recursively attempt to load the next/previous image
            await updateSlide(index, slideContainer, nextEntry, direction);
        } else {
            // Use placeholder if no valid entry is found
            setPlaceholderImage(imgElement, captionElement, upperTextElement, dateElement);
        }
    }


}


/**
 * @brief   Retrieves the next or previous entry in the slideshow based on the specified direction.
 *
 * @details This function calculates the next or previous entry in the slideshow based on the provided direction 
 *          ('next' or 'prev'). It ensures that when the end or beginning of the slideshow is reached, it loops back 
 *          to the first or last entry, respectively, providing a continuous slideshow experience.
 *
 * @param   index        The index of the slideshow to which the current entry belongs.
 * @param   currentEntry The current entry (image) in the slideshow whose next or previous counterpart is needed.
 * @param   direction    The direction of the desired entry ('next' or 'prev').
 *
 * @return  The next or previous entry in the slideshow, or null if the direction is invalid.
 */
function getNextOrPreviousEntry(index, currentEntry, direction) {
    const images = slideshows[index].shuffledImages;
    const currentIndex = images.indexOf(currentEntry);

    if (direction === 'next') {
        return images[(currentIndex + 1) % images.length];
    } else if (direction === 'prev') {
        return images[(currentIndex - 1 + images.length) % images.length];
    }
    return null;
}


/**
 * @brief   Sets a placeholder image and related text for an image element.
 *
 * @details This function updates the `src` of the provided image element to a default placeholder image. 
 *          It also sets default text for the caption and upper text elements, ensuring that these elements 
 *          display placeholder content when no valid image or caption is available.
 *
 * @param   imgElement      The image element where the placeholder image will be set.
 * @param   captionElement  The caption element where the placeholder caption will be displayed.
 * @param   upperTextElement The upper text element where placeholder text will be shown.
 * @param   dateElement     The date element where placeholder date text will be shown.
 *
 * @return  None.
 */
function setPlaceholderImage(imgElement, captionElement, upperTextElement, dateElement) {
    imgElement.src = defaultImgSrc; // Default placeholder
    captionElement.textContent = "FOTO: Matej"; // Placeholder caption
    upperTextElement.textContent = "Cima dell'Uomo (3010 m)"; // Placeholder upper text
    dateElement.textContent = ""; // Placeholder date
}


/**
 * @brief   Preloads a specific image for a slideshow.
 *
 * @details This function preloads a specific image in the slideshow based on the provided indices.
 *          It utilizes the `preloadImage` function to asynchronously load the image. 
 *          Once the image is successfully loaded, the `imageIsReady` flag for the slideshow is set to true, 
 *          indicating that the image is ready to be displayed.
 *
 * @param   index      The index of the slideshow containing the image to be preloaded.
 * @param   photoIndex The index of the image within the slideshow to preload.
 *
 * @return  None.
 */
async function preloadThisImage(index, photoIndex) {
    try {
        // Preload the specified image
        await Promise.all([
            preloadImage(slideshows[index].shuffledImages[photoIndex].src),
        ]);
        // Mark the image as ready once it is loaded
        slideshows[index].imageIsReady = true;
    } catch (err) {
        console.error("Error loading images:", err);
    }
}


/**
 * @brief   Updates the progress bar based on the current image index in the slideshow.
 *
 * @details This function calculates the progress percentage based on the current image index, adjusting for the batch and ensuring 
 *          that the progress bar corresponds to 100% when the first image is reached. The width of the progress bar is updated 
 *          accordingly, providing a visual indication of the slideshow's progress.
 *
 * @param   index  The index of the slideshow for which the progress bar needs to be updated.
 *
 * @return  None.
 */
function updateProgressBar(index) {
    const progressBar = document.getElementById(`progressBar-${index}`);
    // Shift so 0 corresponds to 100%, without an extra offset
    const adjustedIndex = (slideshows[index].currentBatchIndex - 1 + slideshows[index].shuffledImages.length) % slideshows[index].shuffledImages.length;
    const progressPercentage = ((adjustedIndex + 1) / slideshows[index].shuffledImages.length) * 100;
    progressBar.style.width = `${progressPercentage}%`; // Update progress bar width        
}


/**
 * @brief   Attempts to change the slide if the image is ready for display.
 *
 * @details This function checks if the image for the current slide is ready. If the image is ready, it proceeds to change the slide 
 *          by calling the `changeSlide` function. If the image is not ready, it increases the attempt count and retries after 50 ms, 
 *          showing an error overlay in the meantime. This prevents the slideshow from advancing until the image has been fully loaded.
 *
 * @param   index  The index of the slideshow where the slide change should occur.
 *
 * @return  None.
 */
    function attemptChangeSlide(index) {  
    if (slideshows[index].imageIsReady) {
        if (slideshows[index].isProcessingQueue) {
            // Stop auto sliding if actions from manual sliding are proccesing
            return;
        }  
        slideshows[index].imageIsReady = false; // Reset the flag to avoid immediate re-calls
        changeSlide(index, 1, false); // Call the function only if the image is ready
        slideshows[index].attempts = 0;
    } else {
        slideshows[index].attempts++;
        showConnectionError(index); // Show the error overlay
        console.log("Retry");
        setTimeout(() => attemptChangeSlide(index), 100); // Retry after 50 ms
    }        
}


/**
 * @brief   Displays a connection error overlay with a color-coded message.
 *
 * @details This function manages an overlay message to indicate a connection error during slideshow operation. 
 *          The message color dynamically changes based on the number of attempts to load the image:
 *            - Red: For over 15 auto-attempts or 30 manual attempts.
 *            - Yellow: For more than 5 auto-attempts or 15 manual attempts.
 *            - White: For any attempts greater than 0 but within lower thresholds.
 * 
 *          The overlay is visible for 2 seconds, and any pre-existing timeout is cleared to ensure 
 *          consistent behavior. The function respects the slideshow's `errorFlag`, only displaying the 
 *          message when the flag is set.
 *
 * @param   index  The index of the slideshow instance showing the connection error.
 *
 * @return  None.
 */
function showConnectionError(index) {
    if(slideshows[index].errorFlag) {
        // Show the overlay
        photoOverlay[index].style.display = '';

        // Set color
        switch (true) {
            case (slideshows[index].attempts > 15):
            case (slideshows[index].manualAttempts > 30):
                photoOverlay[index].style.color = 'red';
                break;
            case (slideshows[index].attempts > 5):
            case (slideshows[index].manualAttempts > 15):
                photoOverlay[index].style.color = 'yellow';
                break;
            case (slideshows[index].attempts > 0):
            case (slideshows[index].manualAttempts > 5):
                photoOverlay[index].style.color = 'white';
                break;
        }

        // Clear any existing timeout
        clearTimeout(slideshows[index].connectionErrorTimeout);

        // Set a new timeout to hide the overlay
        slideshows[index].connectionErrorTimeout = setTimeout(() => {
            photoOverlay[index].style.display = 'none'; // Hide the overlay
            slideshows[index].connectionErrorTimeout = null; // Reset the timeout reference
        }, 2000); // 2000ms = 2 seconds
    }
}


/**
 * @brief   Monitors the visibility of slideshow wrapper divs and updates the active slideshow index.
 *
 * @details This function uses the IntersectionObserver API to track when a slideshow wrapper is visible in the viewport.
 *          It triggers an update to the `currentSlideshowIndex` if more than 50% of a wrapper is visible, ensuring 
 *          the active slideshow is only updated when not in fullscreen mode. The highest intersection ratio is tracked 
 *          to determine the most visible wrapper.
 *
 * @return  None.
 */
function observeVisibleWrappers() {
    const observerOptions = {
        root: null, // Viewport
        rootMargin: '0px',
        threshold: 0.5 // Trigger when 50% of the wrapper is visible
    };

    const observer = new IntersectionObserver((entries) => {
        let mostVisibleIndex = -1;
        let highestIntersectionRatio = 0;

        entries.forEach((entry) => {
            const wrapperId = entry.target.id; // E.g., "slideShow-0", "slideShow-1"
            const index = Number(wrapperId.split('-')[1]); // Extract the index from the ID

            if (entry.isIntersecting && entry.intersectionRatio > highestIntersectionRatio) {
                mostVisibleIndex = index;
                highestIntersectionRatio = entry.intersectionRatio;
            }
        });

        // Update the currently visible slideshow index only if not in fullscreen mode
        if (mostVisibleIndex !== -1 && activeFullscreenIndex === null) {
            currentSlideshowIndex = mostVisibleIndex;
        }
    }, observerOptions);

    // Observe all wrapper divs
    const wrapperDivs = document.querySelectorAll('.my-slideshow-wrapper'); // Select all slideshow wrappers
    wrapperDivs.forEach((wrapper) => observer.observe(wrapper));
}


/*######### Event listeners functions  #########*/

/**
 * @brief   Creates and inserts a toggle button element into the DOM.
 *
 * @details This function checks if the `mySlideshowContainer` is not empty, 
 *          and then creates a toggle button to switch between different display modes. 
 *          The button is styled and includes an SVG icon. The button is inserted into the document 
 *          body and placed just before a target div with the class `.peak-tag` if it exists.
 *
 * @return  None.
 */
function createToggleButton() {
    // Check if mySlideshowContainer is not empty
    if (mySlideshowContainer.length > 0) {
        // Find the target div with class 'peak-tag'
        var targetDiv = document.querySelector(".peak-tag");

        // Exit early if target div is not found
        if (!targetDiv) {
            console.warn("Target div not found!");
            return; // Prevent button from being created or displayed
        }

        // Create the container element
        const container = document.createElement("div");
        container.style.display = "flex";

        // Create content element
        const content = document.createElement("div");
        content.style.flexGrow = "1"; // Allow content to grow and take space

        // Init the button element
        toggleButton = document.createElement("button");
        toggleButton.style.backgroundColor = "#f3891d"; 
        toggleButton.style.borderRadius = "5px"; 
        toggleButton.style.cursor = "pointer"; 
        toggleButton.style.padding = "12px"; 
        toggleButton.style.display = "flex"; 
        toggleButton.style.alignItems = "center"; 
        toggleButton.style.justifyContent = "center"; 
        toggleButton.style.width = "80px"; 
        toggleButton.style.height = "60px"; 

        // Create SVG element
        toggleButton.innerHTML = `
            <svg fill="#000000" width="80px" height="60px" viewBox="0 0 36 36" version="1.1" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                <g id="SVGRepo_iconCarrier"> 
                    <path d="M32.12,10H3.88A1.88,1.88,0,0,0,2,11.88V30.12A1.88,1.88,0,0,0,3.88,32H32.12A1.88,1.88,0,0,0,34,30.12V11.88A1.88,1.88,0,0,0,32.12,10ZM32,30H4V12H32Z" class="clr-i-outline clr-i-outline-path-1"></path>
                    <path d="M8.56,19.45a3,3,0,1,0-3-3A3,3,0,0,0,8.56,19.45Zm0-4.6A1.6,1.6,0,1,1,7,16.45,1.6,1.6,0,0,1,8.56,14.85Z" class="clr-i-outline clr-i-outline-path-2"></path>
                    <path d="M7.9,28l6-6,3.18,3.18L14.26,28h2l7.46-7.46L30,26.77v-2L24.2,19a.71.71,0,0,0-1,0l-5.16,5.16L14.37,20.5a.71.71,0,0,0-1,0L5.92,28Z" class="clr-i-outline clr-i-outline-path-3"></path>
                    <path d="M30.14,3h0a1,1,0,0,0-1-1h-22a1,1,0,0,0-1,1h0V4h24Z" class="clr-i-outline clr-i-outline-path-4"></path>
                    <path d="M32.12,7V7a1,1,0,0,0-1-1h-26a1,1,0,0,0-1,1h0V8h28Z" class="clr-i-outline clr-i-outline-path-5"></path> 
                    <rect x="0" y="0" width="36" height="36" fill-opacity="0"></rect> 
                </g>
            </svg>
        `; // Added new SVG to the button's innerHTML

        // Append content and button to the container
        container.appendChild(content);
        container.appendChild(toggleButton);

        // Append the container to the body
        document.body.appendChild(container);

        // Insert the button after the target div
        targetDiv.insertAdjacentElement("beforebegin", container);
    }
}


/**
 * @brief   Hides all images (both separators and tables) on the page.
 *
 * @details This function hides all images represented by elements with the 
 *          `.separator` class and all tables with the class `.tr-caption-container`.
 *          It checks if the `mySlideshowContainer` is not empty before proceeding.
 *
 * @return  None.
 */
function hideAllImages() {
    // Check if mySlideshowContainer is not empty
    if (mySlideshowContainer.length > 0) {
        // Find all separators and tables
        const myPostContainers = document.querySelectorAll('.my-post-container');
        const separators = document.querySelectorAll('.separator');
        const tables = document.querySelectorAll('table.tr-caption-container');

        myPostContainers.forEach(function(myPostContainer) {
            myPostContainer.style.display = 'none'; // Hide post containers
        });

        // Set display to 'none' for all separators (images in divs)
        separators.forEach(function(separator) {
            separator.style.display = 'none';
        });

        // Set display to 'none' for all tables (captioned images in tables)
        tables.forEach(function(table) {
            table.style.display = 'none';
        });
    }
}


/**
 * @brief   Updates the image quality based on the slider value.
 *
 * @details This function retrieves the quality value from the quality slider for a specific slideshow and updates 
 *          the image quality for all images in the slideshow's buffer. If the quality value is 11, the quality is 
 *          set to the maximum level (`/s0/`). For other values, the quality is adjusted by multiplying the value by 
 *          400 and updating the image source accordingly.
 *
 * @param   index  The index of the slideshow whose image quality needs to be updated.
 *
 * @return  None.
 */
function updateImageQuality(index) {
    slideshows[index].qualityValue = qualitySliderElement[index].value;
    qualityValueElement[index].textContent = slideshows[index].qualityValue;

    slideshows[index].imageBuffer.forEach(img => {
        // If qualityValue === '11', set quality to max with WebP (-rw) suffix
        const newQuality = (slideshows[index].qualityValue === '11') 
            ? '/s0-rw/' 
            : `/s${slideshows[index].qualityValue * 400}-rw/`;
        
        img.src = img.src.replace(/\/s\d+(-rw)?\/|\/w\d+-h\d+\//, newQuality);
    });
}


/**
 * @brief   Manages the queuing of manual slide navigation requests.
 *
 * @details This function ensures that manual slide navigation requests are processed sequentially. 
 *          It maintains a queue of requests for each slideshow, enforcing a limit to prevent overload. 
 *          New requests are added to the queue unless the queue is full, and the processing 
 *          of requests starts if it is not already in progress.
 *
 * @param   index      The index of the slideshow for which the manual slide navigation is requested.
 * @param   direction  The direction of the slide navigation (-1 for previous, 1 for next).
 *
 * @return  None.
 */
    function enqueueManualSlide(index, direction) {
    // Initialize callQueue if it doesn't exist yet
    const queue = slideshows[index].callQueue || (slideshows[index].callQueue = []);

    // If the queue already has 5 calls, discard the new request
    if (queue.length >= 5) {
        console.log("Queue is full. Discarding additional requests.");
        return;
    }

    // Add the direction to the queue
    queue.push(direction);

    // Start processing the queue if not already processing
    if (!slideshows[index].isProcessingQueue) {
        processQueue(index);
    }
}


/**
 * @brief Processes the call queue for manual slide changes.
 *
 * @details This function checks if the queue for manual slide change requests is empty. 
 *          If not, it sets the slideshow as processing and starts handling queued requests by calling the `checkAndExecute` function.
 *
 * @param index The index of the slideshow for which the queue is being processed.
 *
 * @return None.
 */
function processQueue(index) {
    const queue = slideshows[index].callQueue;

    // If the queue is empty, mark processing as complete
    if (queue.length === 0) {
        slideshows[index].isProcessingQueue = false;
        return;
    }

    slideshows[index].isProcessingQueue = true;

    // Start checking readiness and processing the queue
    checkAndExecute(index);
}


/**
 * @brief Checks if the next queued call can be executed and processes it.
 *
 * @details This function ensures that the current image is ready before executing the next slide change request. 
 *          If the image is not ready, it retries after a short delay. Once a request is processed, it continues to the next 
 *          one in the queue until the queue is empty.
 *
 * @param index The index of the slideshow being processed.
 *
 * @return None.
 */
function checkAndExecute(index) {
    const queue = slideshows[index].callQueue;

    if (slideshows[index].imageIsReady) {
        slideshows[index].imageIsReady = false;

        // Get the next direction from the queue and execute the slide change
        const direction = queue.shift();
        changeSlide(index, direction, true); // Call the unified slide function with manual=true
        slideshows[index].manualAttempts = 0;

        // After processing the current call, continue with the next one if the queue is not empty
        if (queue.length > 0) {
            checkAndExecute(index);
        } else {
            slideshows[index].isProcessingQueue = false; // Mark processing as complete
        }
    } else {
        // If image is not ready, retry after a short delay
        slideshows[index].manualAttempts++;
        if(slideshows[index].manualAttempts > 5){
            showConnectionError(index); // Show error overlay indicating loading issue
        }
        console.log("M_Retry");
        setTimeout(() => checkAndExecute(index), 100); // Retry every 100ms if the image is not ready
    }
}


/**
 * @brief Toggles the visibility of the slider settings and manages auto-hide functionality.
 *
 * @details This function checks the current visibility state of the slider settings container 
 *          and toggles its display. If the settings are shown, it refreshes the auto-hide 
 *          timer to ensure the settings auto-hide after a certain period. If the settings are 
 *          hidden, it clears the auto-hide timer to prevent unnecessary hiding actions.
 *
 * @param index The index of the slideshow for which the slider settings visibility is being toggled.
 *
 * @return None.
 */
function openSettings(index) {
    const isHidden = sliderContainer[index].style.display === 'none' || sliderContainer[index].style.display === '';
    sliderContainer[index].style.display = isHidden ? 'block' : 'none';
    isHidden ? refreshAutoHide(index) : clearTimeout(slideshows[index].hideTimeout);
}


/**
 * @brief   Resets the auto-hide timer for the slider container.
 *
 * @details This function clears any existing auto-hide timeout for the slider container of a specific slideshow 
 *          and sets a new timeout. The slider container will be hidden after 2.5 seconds of inactivity.
 *
 * @param   index  The index of the slideshow whose slider container should be auto-hidden.
 *
 * @return  None.
 */
function refreshAutoHide(index) {
    clearTimeout(slideshows[index].hideTimeout);
    slideshows[index].hideTimeout = setTimeout(() => sliderContainer[index].style.display = 'none', 2500);
}


/**
 * @brief   Updates the fullscreen icons based on the current fullscreen state.
 *
 * @details This function checks whether the document is in fullscreen mode and updates the display 
 *          of the "enter fullscreen" and "exit fullscreen" icons accordingly. The correct icon is shown 
 *          to reflect the fullscreen state of the slideshow.
 *
 * @param   index  The index of the slideshow whose fullscreen icons need to be updated.
 *
 * @return  None.
 */
function updateFullscreenIcons(index) {
    if (document.fullscreenElement) {
        // In fullscreen mode, show the "exit fullscreen" icon
        enterFullscreenIcon[index].style.display = 'none';
        exitFullscreenIcon[index].style.display = 'block';
    } else {
        // Not in fullscreen mode, show the "enter fullscreen" icon
        enterFullscreenIcon[index].style.display = 'block';
        exitFullscreenIcon[index].style.display = 'none';
    }
}


/**
 * @brief   Displays a tooltip for a control button after a short delay.
 *
 * @details This function triggers a delayed display of a tooltip associated with a specific control button. 
 *          It sets a timeout to show the tooltip, ensuring a smooth user experience by only displaying 
 *          the tooltip when the button is hovered over for a sufficient duration.
 *
 * @param   controllButton  The DOM element representing the control button whose tooltip is to be displayed.
 *
 * @return  None.
 */
function showTooltip(controllButton) {
    controllButton.tooltipTimeout = setTimeout(() => {
        const tooltip = controllButton.querySelector('.tooltip');
        tooltip.style.display = 'block'; // Make the tooltip visible
        tooltip.style.opacity = '1';    // Apply fade-in effect
    }, 300); // Delay in milliseconds before showing the tooltip
}


/**
 * @brief   Hides the tooltip for a control button with a fade-out effect.
 *
 * @details This function cancels any pending tooltip display timeout and applies a fade-out animation 
 *          to the tooltip. Once the fade-out animation is complete, the tooltip is hidden to ensure 
 *          a seamless user interface interaction.
 *
 * @param   controllButton  The DOM element representing the control button whose tooltip is to be hidden.
 *
 * @return  None.
 */
function hideTooltip(controllButton) {
    clearTimeout(controllButton.tooltipTimeout); // Cancel pending tooltip display
    const tooltip = controllButton.querySelector('.tooltip');
    tooltip.style.opacity = '0'; // Trigger fade-out effect
    setTimeout(() => {
        tooltip.style.display = 'none'; // Hide tooltip after fade-out completes
    }, 300); // Duration of the fade-out effect in milliseconds
}


/**
 * @brief   Handles both single and double-click actions on the slideshow.
 *
 * @details This function distinguishes between single and double-click events on the slideshow.
 *          If a double-click is detected (within a defined time threshold), it triggers a double-click action, 
 *          such as toggling the fullscreen mode. If a single-click is detected, it triggers the appropriate 
 *          single-click action, such as clicking a specific button for the slideshow.
 *
 * @param   index  The index of the slideshow that the click action applies to.
 *
 * @return  None.
 */
function handleClick(index) {
    slideshows[index].currentTime = Date.now(); // Get current time in milliseconds
    // Check if the time between clicks is less than the threshold for double-click
    if (slideshows[index].currentTime - slideshows[index].lastClickTime <= doubleClickThreshold) {
        // Clear the single-click action timer, if any, as the double-click takes precedence
        if (slideshows[index].clickTimer) {
            clearTimeout(slideshows[index].clickTimer);
            slideshows[index].clickTimer = null; // Reset the click timer
        }
        // Call your double-click function here (toggle fullscreen)
        toggleFullscreen(index);
    } else {
        // Set a timer to perform the single-click action after the double-click threshold
        slideshows[index].clickTimer = setTimeout(() => {
            // Perform the single-click action, like clicking the button
            document.getElementById(`toggleSlideshowButton-${index}`).click();
        }, doubleClickThreshold);
    }

    // Update last click time for this slideshow
    slideshows[index].lastClickTime = slideshows[index].currentTime;
}


window.addEventListener('DOMContentLoaded', () => {
    // Call functions for creating buttons and hiding images
    createToggleButton();
    hideAllImages();

    numberOfSlideshows.forEach(index => {
        qualitySliderElement[index].addEventListener('input', () => { updateImageQuality(index); updateSliderColor(index); });
        speedSliderElement[index].addEventListener('input', () => updateSlideshowSpeed(index));
        toggleSlideshowButton[index].addEventListener('click', () => slideshows[index].isSlideshowRunning ? pauseSlideshow(index, SLIDESHOW_VISIBLE) : resumeSlideshow(index, SLIDESHOW_VISIBLE));
        previousPhoto[index].addEventListener('click', () => enqueueManualSlide(index, -1));  // Attach event listeners with the enqueue function
        nextPhoto[index].addEventListener('click', () => enqueueManualSlide(index, 1));       // Attach event listeners with the enqueue function
        toggleNavigationButton[index].addEventListener('click', () => toggleNavigation(index));
        settingsButton[index].addEventListener('click', () => openSettings(index));
        fullscreenButton[index].addEventListener('click', () => toggleFullscreen(index));
        sliderContainer[index].addEventListener('mouseenter', () => clearTimeout(slideshows[index].hideTimeout));
        sliderContainer[index].addEventListener('mouseleave', () => refreshAutoHide(index));
        autoQualityCheckbox[index].addEventListener('change', () => autoSetQuality(index));
        preloadAllButton[index].addEventListener('click', () => preloadAllImages(index));
        if (typeof toggleButton !== "undefined" && toggleButton) {
            toggleButton.addEventListener('click', () => toggleSlideshowOrImageVisibility(index));
        }
    })

    document.addEventListener('fullscreenchange', () => { for (let index = 0; index < slideshows.length; index++) { updateFullscreenIcons(index); } });
    document.addEventListener('visibilitychange', () => { for (let index = 0; index < slideshows.length; index++) { document.visibilityState === 'hidden' ? pauseSlideshow(index, SLIDESHOW_HIDDEN) : resumeSlideshow(index, SLIDESHOW_HIDDEN); } });

    // Add event listeners for mouse enter and leave on control buttons
    controllButton.forEach(button => {
        button.addEventListener('mouseenter', () => showTooltip(button));
        button.addEventListener('mouseleave', () => hideTooltip(button));
    });      
});


// Onload event
window.addEventListener('load', function () {
    numberOfSlideshows.forEach(index => {
        fetchData(index);
        updateSlideshowSpeed(index); // Initialize the speed on load for each slideshow

        // Check slideshow readiness after the window is fully loaded
        checkAndInitialize(index); // Start checking if the slideshow is ready and initialize once done
    });
});


// Onresize event
window.onresize = () => {
    numberOfSlideshows.forEach(index => {
        autoSetQuality(index);  // Call updateSliderColor for each slideshow or if auto selected also resize images
    });
};
