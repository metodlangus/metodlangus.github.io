    const blogUrl = "https://gorski-uzitki.blogspot.com/";
    const initPhotos = 1; // Determine range of photos to be shown on slideshows and in posts
    const initMapPhotos = -1; // Determine range of photos to be shown on map


    const initSpeed = 3;
    const maxSpeed = 10;
    const minSpeed = 1.75; 
    const stepSpeed = 0.25;
    const initQuality = 4;
    const SLIDESHOW_HIDDEN = true;
    const SLIDESHOW_VISIBLE = false;

    let slideshowIndex = 0;
    var slideshowTitles = [];
    var numberOfSlideshows = [];
    var toggleButton;
    const imageLoadStatus = new Map();
    let activeFullscreenIndex = null; // Track the index of the fullscreen slideshow
    let currentSlideshowIndex = 0; // Index of current most visible slideshow
    const doubleClickThreshold = 300; // Time in milliseconds to detect a double-click
    // SVG path end image with Triglav silhouette
    const endImage = {
        type: 'image',
        src: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
        <svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="1800.000000pt" height="1350.000000pt" viewBox="0 0 1800.000000 1350.000000" preserveAspectRatio="xMidYMid meet" >
          <g transform="translate(0.000000,1800.000000) scale(0.135000,-0.135000)" fill="#626262" stroke="none">
            <path d="M5725 12119 c-4 -5 -18 -14 -31 -19 -15 -6 -24 -18 -24 -30 0 -11 -7 -23 -15 -26 -11 -4 -15 -21 -15 -59 0 -57 19 -85 58 -85 11 0 24 -4 27 -10 9 -15 68 -12 106 6 71 32 84 43 87 70 4 27 3 27 -40 19 -78 -14 -120 -11 -132 7 -16 26 6 45 37 31 12 -6 40 -8 62 -4 53 8 57 33 14 77 -28 29 -40 34 -80 34 -26 0 -51 -5 -54 -11z"/>
            <path d="M1710 10986 c0 -28 4 -35 23 -38 20 -3 23 -11 33 -93 24 -196 34 -291 34 -322 0 -33 1 -33 48 -33 l47 0 48 83 c26 45 73 123 102 172 30 50 58 97 63 105 32 62 56 90 77 90 13 0 25 7 28 18 2 9 8 25 12 35 7 16 0 18 -86 15 l-94 -3 -3 -28 c-2 -15 4 -34 13 -43 14 -14 14 -19 2 -38 -8 -11 -36 -59 -62 -106 -73 -129 -74 -130 -95 -130 -21 0 -26 23 -34 178 -5 91 -4 93 20 102 18 7 24 17 24 40 l0 30 -100 0 -100 0 0 -34z"/>
            <path d="M4289 10996 c-7 -14 -9 -36 -5 -50 5 -21 12 -26 36 -26 42 0 60 38 36 75 -21 32 -53 32 -67 1z"/>
            <path d="M2300 10844 c-53 -30 -60 -39 -60 -81 0 -46 34 -78 113 -103 62 -20 67 -24 67 -50 0 -32 -14 -40 -75 -40 -32 0 -51 7 -73 25 -52 43 -78 29 -88 -49 -6 -42 -5 -46 15 -46 12 0 30 5 40 12 15 9 25 9 46 0 36 -17 90 -15 128 4 133 67 112 162 -47 208 -31 9 -42 17 -44 35 -2 13 2 28 10 32 21 14 82 10 104 -6 23 -18 73 -20 79 -2 2 6 6 29 10 50 5 34 4 37 -19 37 -14 0 -28 -4 -31 -10 -3 -5 -17 -10 -30 -10 -13 0 -27 5 -30 10 -11 18 -69 10 -115 -16z"/>
            <path d="M2724 10850 c-82 -36 -146 -150 -129 -229 13 -62 89 -121 154 -121 63 0 152 60 129 88 -14 16 -48 15 -72 -3 -42 -32 -126 -6 -126 39 0 28 29 35 146 38 l119 3 3 40 c3 53 -32 113 -83 142 -48 27 -86 28 -141 3z m99 -59 c14 -6 28 -19 32 -31 11 -36 -11 -50 -80 -50 -79 0 -93 20 -45 62 32 30 53 34 93 19z"/>
            <path d="M3145 10853 c-16 -8 -43 -27 -59 -42 -86 -79 -87 -240 -2 -292 39 -24 61 -24 100 0 42 26 61 15 52 -31 -6 -35 -32 -66 -73 -87 -25 -13 -108 -14 -138 -2 -26 11 -55 -4 -55 -28 0 -14 14 -23 49 -35 67 -22 120 -20 178 5 88 37 121 83 142 196 11 55 28 121 53 206 7 21 20 44 29 51 10 7 23 24 28 39 13 34 3 39 -70 35 -47 -3 -54 -6 -59 -28 -8 -30 -30 -29 -75 6 -37 28 -58 29 -100 7z m127 -86 c36 -45 17 -133 -38 -176 -36 -28 -75 -27 -104 4 -29 31 -31 76 -7 128 36 76 108 98 149 44z"/>
            <path d="M3625 10859 c-11 -5 -33 -13 -48 -19 -24 -8 -26 -13 -17 -30 9 -17 17 -19 70 -13 66 6 110 -12 110 -46 0 -25 -24 -33 -74 -26 -57 9 -146 -25 -169 -64 -25 -42 -22 -93 7 -124 37 -40 68 -43 121 -13 l46 25 9 -24 c9 -23 15 -25 78 -25 67 0 68 0 80 32 6 17 11 32 9 33 -1 0 -14 6 -30 13 -25 11 -27 15 -21 54 4 24 11 51 15 60 16 31 11 114 -8 130 -50 43 -129 60 -178 37z m66 -199 c42 -23 8 -73 -60 -86 -68 -14 -99 49 -38 79 38 19 71 21 98 7z"/>
            <path d="M4196 10839 c-5 -24 -1 -35 15 -48 l22 -17 -22 -100 c-55 -249 -61 -263 -112 -279 -29 -9 -39 -22 -39 -52 0 -19 5 -23 30 -23 77 0 138 62 160 163 5 23 16 71 25 107 23 90 55 241 55 263 0 14 -10 17 -64 17 -63 0 -64 0 -70 -31z"/>
            <path d="M4524 10850 c-82 -36 -146 -150 -129 -229 13 -62 89 -121 154 -121 63 0 152 60 129 88 -14 16 -38 15 -77 -4 -43 -22 -98 -11 -113 21 -21 45 0 54 135 57 l122 3 3 40 c3 53 -32 113 -83 142 -48 27 -86 28 -141 3z m99 -59 c30 -12 44 -46 27 -66 -18 -22 -136 -21 -144 1 -10 27 39 71 81 73 6 1 23 -3 36 -8z"/>
            <path d="M9765 10529 c-27 -10 -69 -19 -91 -19 -24 0 -47 -6 -53 -14 -13 -16 -85 -23 -293 -32 -87 -3 -128 -2 -128 5 0 6 -4 11 -10 11 -5 0 -10 -18 -10 -40 0 -27 -5 -43 -15 -46 -13 -5 -15 -37 -15 -203 1 -181 2 -198 21 -220 11 -13 23 -21 26 -17 4 4 6 38 4 77 -4 100 10 132 66 159 25 12 55 19 66 16 11 -3 33 2 48 10 15 7 52 14 82 14 35 0 59 5 66 14 8 9 40 16 84 20 40 3 106 10 147 15 41 6 83 11 93 11 31 2 33 31 3 57 -15 12 -34 23 -42 23 -8 0 -14 4 -14 8 0 5 -11 14 -25 20 -21 10 -24 15 -16 31 6 10 24 24 41 31 16 7 30 16 30 21 0 4 10 11 23 15 29 8 58 34 51 45 -9 15 -86 8 -139 -12z m-126 -133 c10 -11 7 -17 -11 -30 -45 -32 -120 -11 -104 29 7 20 99 21 115 1z m-193 -52 c13 -52 -66 -84 -106 -44 -22 22 -26 56 -7 63 6 3 33 6 59 6 43 1 48 -1 54 -25z"/>
            <path d="M2662 9907 c-14 -17 -10 -42 12 -66 17 -18 17 -23 1 -93 -43 -193 -65 -260 -93 -283 -16 -14 -23 -29 -20 -45 3 -24 6 -25 77 -25 74 0 75 0 82 30 6 21 4 34 -7 46 -16 18 -14 35 30 214 8 33 21 90 30 128 8 37 18 72 22 78 4 6 0 15 -7 20 -22 14 -115 11 -127 -4z"/>
            <path d="M4347 9913 c-15 -15 -6 -61 14 -75 l21 -14 -26 -99 c-15 -55 -33 -129 -41 -165 -10 -45 -22 -71 -39 -85 -14 -11 -26 -33 -28 -50 l-3 -30 60 -3 c32 -2 69 -1 81 2 28 7 40 51 19 72 -19 19 -19 57 -1 97 8 18 19 61 24 97 6 36 18 94 27 130 9 36 19 80 22 98 l5 32 -64 0 c-36 0 -68 -3 -71 -7z"/>
            <path d="M3927 9849 c-20 -17 -37 -40 -37 -51 0 -13 -10 -24 -30 -31 -25 -9 -30 -17 -30 -44 0 -19 6 -36 16 -41 13 -8 13 -19 -5 -109 -12 -56 -21 -108 -21 -117 0 -26 38 -56 70 -56 32 0 79 18 82 32 4 27 0 33 -27 38 -29 5 -30 7 -27 55 1 27 7 54 12 59 6 6 10 24 10 41 0 37 17 62 45 67 29 5 34 63 5 78 -15 8 -19 17 -15 35 3 14 7 36 10 50 7 34 -12 32 -58 -6z"/>
            <path d="M9135 9800 c-16 -17 -39 -33 -50 -36 -12 -3 -67 -52 -123 -110 -56 -57 -108 -104 -115 -104 -19 0 -447 -434 -447 -453 0 -8 -7 -17 -15 -21 -20 -7 -20 -64 1 -104 12 -24 14 -51 10 -118 -3 -48 -10 -92 -16 -98 -5 -5 -10 -27 -10 -47 0 -21 -4 -41 -10 -44 -5 -3 -18 -25 -28 -48 -10 -23 -26 -48 -35 -56 -10 -7 -17 -22 -17 -32 0 -10 -9 -23 -20 -29 -11 -6 -20 -15 -20 -20 0 -14 -75 -122 -100 -145 -11 -10 -20 -22 -20 -27 0 -5 -18 -31 -40 -57 -22 -26 -40 -51 -40 -54 0 -4 -12 -20 -28 -35 -15 -15 -37 -43 -49 -62 -12 -20 -33 -46 -47 -59 -14 -14 -26 -30 -26 -36 0 -7 -10 -20 -21 -31 -12 -10 -39 -41 -60 -69 -21 -27 -52 -65 -68 -84 -17 -18 -31 -38 -31 -44 0 -5 -20 -29 -45 -53 -25 -23 -45 -49 -45 -56 0 -8 -20 -34 -45 -58 -25 -24 -45 -50 -45 -57 0 -7 -12 -23 -26 -36 -14 -12 -39 -40 -55 -62 -15 -22 -44 -57 -64 -79 -19 -21 -35 -43 -35 -49 0 -6 -20 -30 -45 -54 -25 -23 -45 -49 -45 -56 0 -7 -20 -33 -45 -57 -25 -24 -45 -50 -45 -57 0 -7 -13 -25 -30 -40 -16 -14 -30 -33 -30 -41 0 -8 -20 -33 -45 -56 -25 -24 -45 -50 -45 -57 0 -8 -13 -26 -30 -39 -16 -14 -29 -32 -30 -41 0 -8 -16 -30 -35 -49 -19 -19 -35 -38 -35 -43 0 -8 -31 -47 -107 -137 -18 -20 -33 -45 -33 -54 0 -9 -7 -19 -15 -22 -8 -4 -15 -13 -15 -21 0 -20 98 66 99 87 1 9 30 45 66 80 36 35 65 70 65 76 0 7 27 41 60 76 33 34 60 68 60 73 0 6 25 35 55 65 30 30 55 59 55 65 0 6 14 24 30 40 17 16 30 34 30 41 0 7 20 32 45 56 24 24 45 48 45 55 0 7 22 36 50 65 27 29 50 57 50 62 0 5 21 33 48 62 92 104 122 141 122 152 0 6 20 30 45 54 24 24 45 48 45 54 0 7 16 29 35 50 19 22 35 42 35 46 0 4 21 32 48 62 81 94 147 176 151 188 2 6 17 24 32 39 16 16 29 34 29 42 0 7 20 33 45 57 25 24 45 48 45 54 0 9 24 37 133 160 26 29 47 58 47 65 0 18 72 87 100 96 22 7 23 6 14 -26 -13 -55 -11 -299 4 -338 7 -18 13 -58 14 -90 2 -455 0 -554 -15 -591 -10 -25 -14 -73 -12 -168 1 -96 -2 -138 -11 -150 -8 -9 -14 -27 -14 -38 0 -21 -71 -98 -120 -130 -14 -9 -38 -30 -55 -45 -47 -45 -145 -113 -200 -140 -27 -13 -53 -28 -56 -33 -4 -4 -28 -10 -55 -13 -27 -2 -58 -8 -69 -13 -11 -5 -56 -12 -100 -15 -133 -8 -144 -10 -157 -23 -6 -6 -24 -12 -38 -12 -19 0 -40 -15 -73 -51 -47 -51 -47 -52 -45 -112 4 -84 14 -85 81 -9 30 34 35 46 28 61 -19 35 11 59 86 66 63 6 306 8 591 4 64 -1 141 1 170 6 46 7 52 10 52 31 0 34 -33 48 -94 39 -28 -3 -58 -7 -66 -7 -8 -1 -24 -7 -35 -14 -40 -28 -125 -11 -125 24 0 18 128 152 146 152 5 0 25 16 44 35 19 19 42 35 51 35 9 0 19 6 22 14 7 17 54 26 66 12 5 -6 11 -22 13 -35 4 -35 22 -36 52 -4 29 31 35 87 12 118 -18 25 -5 52 42 88 36 26 37 29 34 85 -2 31 -6 81 -8 109 -5 43 -3 54 10 59 18 7 22 49 5 59 -5 4 -10 35 -11 68 -1 282 -10 451 -23 471 -11 15 -15 52 -15 144 0 88 -4 129 -14 145 -8 13 -13 43 -12 71 2 39 7 53 30 72 15 13 34 24 42 24 8 0 14 8 15 18 1 33 10 67 19 76 15 15 12 62 -5 76 -8 7 -12 17 -9 22 4 5 -3 23 -15 39 -12 16 -21 43 -21 62 0 19 -7 40 -15 47 -11 9 -15 35 -15 108 0 148 10 165 263 420 116 116 217 212 225 212 7 0 46 34 86 75 40 41 80 75 89 75 10 0 25 -9 34 -20 10 -11 22 -20 28 -20 5 0 54 -43 108 -95 53 -52 102 -95 108 -95 6 0 32 -22 59 -50 27 -27 55 -50 62 -50 8 0 29 -16 48 -35 19 -19 39 -35 46 -35 6 0 18 -7 25 -17 16 -18 115 -93 124 -93 3 0 19 -10 35 -22 21 -15 30 -30 30 -49 0 -15 4 -30 9 -33 4 -3 11 -35 13 -71 3 -36 10 -71 16 -78 7 -8 11 -339 14 -970 3 -900 4 -959 21 -968 14 -8 17 -25 17 -99 0 -51 4 -90 10 -90 5 0 10 -33 12 -72 4 -96 22 -94 26 2 1 41 7 84 12 95 5 11 11 45 12 75 3 49 6 55 26 58 33 5 141 -71 231 -163 41 -41 79 -75 85 -75 6 0 38 -27 71 -60 33 -33 65 -60 72 -60 7 0 26 -14 44 -31 17 -16 41 -34 52 -40 12 -5 35 -19 50 -31 26 -21 39 -23 142 -23 108 0 114 1 134 25 27 33 28 80 1 80 -11 0 -20 -6 -20 -14 0 -8 -7 -22 -16 -30 -21 -22 -136 -22 -154 -1 -7 8 -21 15 -31 15 -10 0 -33 13 -51 29 -18 15 -43 32 -56 35 -12 4 -30 18 -38 32 -9 13 -22 24 -29 24 -7 0 -41 27 -75 60 -34 33 -68 60 -74 60 -6 0 -41 29 -76 65 -35 36 -69 65 -75 65 -6 0 -42 31 -80 68 -39 38 -79 72 -89 76 -18 6 -19 18 -12 313 5 169 11 316 16 328 6 16 23 25 67 35 70 16 93 34 93 72 0 25 -3 28 -34 28 -18 0 -39 7 -46 15 -7 8 -21 15 -32 15 -24 0 -58 77 -59 134 -2 207 -11 335 -25 346 -21 19 -21 578 1 586 16 6 95 -66 95 -87 0 -11 55 -73 248 -278 45 -48 82 -92 82 -97 0 -5 47 -56 105 -114 58 -58 105 -111 105 -118 0 -8 47 -61 105 -118 58 -57 105 -109 105 -114 0 -6 54 -66 120 -134 66 -68 120 -127 120 -132 0 -5 65 -74 145 -154 80 -80 145 -149 145 -155 0 -6 61 -71 135 -145 74 -74 138 -144 141 -155 10 -29 246 -265 266 -265 27 0 29 15 8 43 -11 14 -20 32 -20 40 0 8 -7 17 -15 21 -8 3 -15 12 -15 21 0 9 -7 26 -15 39 -9 13 -15 28 -14 32 1 5 1 20 0 33 -1 20 -3 22 -16 11 -13 -11 -20 -9 -43 13 -16 15 -33 27 -39 27 -13 0 -413 401 -413 415 0 6 -54 64 -120 130 -66 66 -120 124 -120 130 0 6 -54 64 -120 130 -66 66 -120 126 -120 133 0 7 -40 53 -90 103 -49 49 -90 93 -90 99 0 6 -54 66 -120 134 -66 68 -120 127 -120 131 0 5 -39 51 -87 102 -209 222 -243 260 -243 272 0 6 -20 32 -45 58 -25 25 -45 51 -45 58 0 7 -7 18 -15 25 -8 7 -15 18 -15 24 0 14 -161 176 -175 176 -6 0 -40 29 -75 65 -35 36 -70 65 -76 65 -7 0 -46 34 -88 75 -42 41 -82 75 -89 75 -7 0 -35 23 -62 50 -27 28 -53 50 -59 50 -5 0 -33 21 -62 48 -113 100 -140 119 -175 126 -30 5 -39 2 -64 -24z m-585 -1227 c0 -50 -4 -65 -16 -70 -31 -12 -49 11 -52 65 -2 41 1 55 18 72 33 33 50 11 50 -67z"/>
            <path d="M1824 9745 c-91 -40 -151 -157 -124 -241 17 -54 34 -70 96 -93 50 -19 55 -19 101 -4 50 16 93 48 93 69 0 23 -48 25 -89 3 -26 -13 -48 -18 -63 -14 -51 16 -74 59 -45 83 7 7 66 13 133 14 l119 3 3 37 c4 46 -32 107 -81 137 -39 24 -96 26 -143 6z m121 -71 c9 -9 15 -26 13 -38 -3 -19 -10 -21 -76 -24 -61 -2 -73 0 -79 14 -17 45 104 86 142 48z"/>
            <path d="M2139 9758 c0 -2 -2 -17 -5 -35 -3 -27 0 -32 19 -35 26 -4 27 -20 3 -123 -11 -50 -23 -76 -40 -90 -14 -11 -26 -33 -28 -50 l-3 -30 67 -3 c37 -2 77 2 88 8 24 13 27 52 5 70 -19 16 -18 39 3 119 15 55 22 66 52 82 42 23 73 24 90 5 13 -17 4 -85 -27 -204 -11 -40 -17 -74 -15 -77 3 -3 31 -5 63 -5 55 0 60 2 74 30 20 38 19 39 -11 50 -30 12 -30 15 4 140 15 55 17 80 10 95 -31 60 -71 70 -134 34 -39 -21 -64 -19 -64 6 0 12 -14 15 -75 15 -41 0 -75 -1 -76 -2z"/>
            <path d="M2830 9734 c-13 -34 -13 -44 4 -44 7 0 19 -6 25 -14 10 -12 5 -20 -31 -43 -82 -54 -81 -51 -43 -113 19 -30 35 -59 35 -63 0 -5 9 -22 21 -38 24 -34 67 -39 92 -11 24 27 22 62 -3 62 -20 0 -80 80 -80 107 0 18 91 103 118 109 17 5 22 13 22 40 l0 34 -75 0 c-72 0 -76 -1 -85 -26z"/>
            <path d="M3072 9735 c-17 -36 -15 -45 8 -45 30 0 35 -24 17 -83 -8 -29 -18 -65 -22 -80 -3 -16 -20 -41 -36 -57 -21 -19 -30 -35 -27 -51 3 -23 7 -24 83 -27 66 -2 82 0 92 14 20 27 16 55 -8 61 -20 5 -21 11 -15 59 6 55 33 124 48 124 4 0 8 7 8 15 0 8 -7 15 -16 15 -14 0 -16 7 -11 40 l5 40 -57 0 c-52 0 -59 -2 -69 -25z"/>
            <path d="M3265 9729 c-19 -17 -35 -35 -35 -40 0 -6 88 -2 96 5 1 1 5 16 9 34 6 28 4 32 -14 32 -11 0 -36 -14 -56 -31z"/>
            <path d="M3460 9745 c-23 -8 -35 -19 -35 -31 0 -17 10 -20 79 -24 61 -4 81 -9 90 -22 14 -24 -5 -54 -30 -50 -51 10 -110 2 -152 -20 -39 -20 -48 -31 -59 -66 -15 -54 -2 -97 38 -117 35 -19 57 -19 93 0 39 20 63 19 76 -5 8 -16 21 -20 58 -20 56 0 81 15 84 50 2 19 -2 26 -19 28 -27 4 -28 13 -8 107 25 119 19 141 -49 169 -45 19 -116 19 -166 1z m108 -218 c3 -24 -2 -30 -41 -47 -56 -25 -97 -15 -97 24 0 36 36 57 90 54 41 -3 45 -6 48 -31z"/>
            <path d="M4520 9748 c0 -7 -3 -23 -6 -35 -4 -16 0 -23 15 -28 31 -10 25 -27 -20 -55 -65 -40 -66 -49 -18 -145 46 -92 67 -108 115 -86 18 8 24 19 24 41 0 20 -5 30 -14 30 -15 0 -53 45 -75 88 -11 20 -7 27 36 73 26 28 59 53 74 56 20 4 28 12 31 34 3 16 2 31 0 34 -3 3 -41 5 -84 5 -56 0 -78 -4 -78 -12z"/>
            <path d="M4835 9731 c-70 -40 -91 -67 -105 -133 -20 -102 8 -163 90 -190 155 -51 321 146 235 281 -47 76 -133 92 -220 42z m135 -61 c42 -42 30 -108 -30 -168 -42 -42 -67 -48 -99 -25 -50 38 -34 150 27 201 24 19 79 15 102 -8z"/>
            <path d="M5199 9758 c0 -2 -2 -17 -5 -35 -3 -27 0 -32 19 -35 26 -4 27 -20 3 -123 -11 -50 -23 -76 -40 -90 -14 -11 -26 -33 -28 -50 l-3 -30 67 -3 c37 -2 77 2 88 8 24 13 27 52 5 70 -19 16 -18 39 3 119 15 55 22 66 52 82 42 23 73 24 90 5 13 -17 4 -85 -27 -204 -11 -40 -17 -74 -15 -77 3 -3 31 -5 63 -5 55 0 60 2 74 30 20 38 19 39 -11 50 -30 12 -30 15 5 144 l21 79 -26 34 c-30 40 -65 43 -120 12 -39 -21 -64 -19 -64 6 0 12 -14 15 -75 15 -41 0 -75 -1 -76 -2z"/>
            <path d="M5784 9745 c-91 -40 -151 -157 -124 -241 17 -54 34 -70 96 -93 50 -19 55 -19 101 -4 50 16 93 48 93 69 0 23 -48 25 -89 3 -26 -13 -48 -18 -63 -14 -51 16 -74 59 -45 83 7 7 66 13 133 14 l119 3 3 37 c4 46 -32 107 -81 137 -39 24 -96 26 -143 6z m121 -71 c9 -9 15 -26 13 -38 -3 -19 -9 -21 -77 -21 -85 0 -97 11 -55 50 32 30 93 34 119 9z"/>
            <path d="M6215 9747 c-100 -58 -135 -108 -135 -191 0 -77 30 -119 107 -149 39 -15 47 -16 90 -1 58 19 105 61 101 89 -4 29 -39 29 -71 0 -57 -54 -137 -20 -137 57 0 106 97 174 167 118 53 -41 79 -25 98 58 6 31 5 32 -23 32 -17 0 -32 -6 -35 -12 -3 -10 -11 -10 -39 0 -42 15 -96 15 -123 -1z"/>
            <path d="M8268 8870 c-27 -28 -48 -54 -48 -59 0 -4 -13 -24 -30 -42 -16 -19 -30 -39 -30 -45 0 -5 -13 -23 -30 -39 -16 -16 -30 -33 -30 -38 0 -5 -13 -26 -30 -47 -16 -21 -30 -41 -30 -44 0 -4 -13 -20 -30 -36 -16 -16 -30 -36 -30 -43 0 -8 -9 -22 -20 -32 -11 -10 -20 -22 -20 -28 0 -5 -15 -27 -32 -48 -56 -64 -78 -97 -78 -111 0 -7 -13 -24 -30 -38 -16 -14 -30 -30 -30 -37 0 -7 -13 -28 -30 -46 -16 -19 -30 -39 -30 -44 0 -6 -9 -18 -20 -28 -11 -10 -20 -23 -20 -29 0 -6 -18 -31 -40 -56 -22 -25 -40 -50 -40 -56 0 -7 -7 -14 -15 -18 -8 -3 -15 -14 -15 -24 0 -10 -16 -33 -35 -52 -19 -19 -35 -38 -35 -42 0 -11 -72 -109 -93 -127 -10 -7 -17 -22 -17 -32 0 -10 -6 -22 -12 -26 -17 -10 -88 -116 -88 -130 0 -6 -7 -13 -15 -16 -8 -4 -26 -25 -41 -49 -15 -23 -33 -49 -41 -56 -7 -7 -13 -19 -13 -26 0 -6 -13 -23 -30 -36 -16 -14 -29 -32 -30 -41 0 -9 -9 -24 -20 -34 -11 -10 -20 -23 -20 -30 0 -6 -11 -22 -25 -35 -14 -13 -25 -27 -25 -31 0 -11 -71 -114 -81 -117 -5 -2 -9 -11 -9 -21 0 -9 -13 -29 -28 -44 -16 -15 -39 -49 -52 -75 -13 -26 -30 -53 -37 -60 -14 -15 -18 -42 -5 -42 12 0 72 64 72 77 0 6 20 31 45 55 24 24 45 48 45 54 0 6 13 27 30 45 16 19 30 39 30 45 0 5 14 23 30 39 17 16 30 34 30 40 0 6 14 24 30 40 17 16 30 34 30 40 0 6 14 25 30 43 17 18 30 39 30 46 0 7 9 21 20 31 11 10 20 22 20 28 0 5 15 27 33 48 55 65 77 97 77 111 0 8 14 24 30 36 17 13 30 29 30 36 0 7 13 29 30 47 16 19 30 39 30 45 0 5 14 23 30 39 17 16 30 33 30 38 0 5 14 26 30 47 17 21 30 42 30 48 0 5 7 12 15 16 8 3 15 13 15 23 0 9 14 32 31 49 17 18 36 41 43 52 40 69 120 181 132 186 8 3 14 10 14 15 0 12 117 188 131 197 5 3 9 13 9 22 0 10 14 28 30 42 17 14 30 32 30 41 0 8 14 28 30 44 17 16 30 34 30 40 0 7 9 20 20 30 11 10 20 23 20 30 0 6 11 22 25 35 14 13 25 32 25 42 0 10 7 21 15 24 8 4 15 14 15 23 0 10 14 30 30 46 17 16 30 33 30 38 0 4 11 23 25 41 28 37 31 46 13 46 -7 0 -34 -23 -60 -50z"/>
            <path d="M4841 7257 c-16 -20 -3 -27 54 -27 28 0 55 3 58 7 15 14 -18 33 -58 33 -23 0 -48 -6 -54 -13z"/>
            <path d="M5610 7205 c-4 -5 -7 -21 -6 -35 1 -23 4 -25 56 -25 52 0 55 1 57 27 1 15 -3 31 -9 34 -17 11 -89 10 -98 -1z"/>
            <path d="M6094 7208 c-7 -11 10 -16 86 -23 111 -11 670 -16 670 -6 0 24 -73 30 -403 34 -191 2 -350 0 -353 -5z"/>
            <path d="M7656 7213 c-3 -4 -6 -21 -6 -40 0 -31 2 -33 36 -33 35 0 35 1 32 37 -3 33 -7 38 -30 40 -14 1 -29 -1 -32 -4z"/>
            <path d="M990 7200 c-8 -5 -25 -10 -38 -10 -23 0 -39 -21 -28 -39 4 -6 18 -3 35 7 28 16 31 15 74 -6 25 -12 50 -29 57 -37 17 -21 37 -19 57 5 17 19 30 20 478 20 389 1 463 3 479 15 11 8 40 15 65 15 55 0 43 20 -16 27 -83 10 -1148 13 -1163 3z"/>
            <path d="M2473 7198 c-16 -21 -23 -47 -17 -63 5 -12 29 -15 125 -15 102 0 121 2 126 16 11 28 -25 44 -99 44 -52 0 -70 4 -74 15 -7 18 -48 20 -61 3z"/>
            <path d="M2776 7175 c-17 -18 -17 -19 6 -36 19 -15 45 -19 148 -21 207 -3 228 2 186 41 -23 21 -36 24 -173 28 -134 5 -151 4 -167 -12z"/>
            <path d="M7823 7183 c-10 -3 -10 -9 0 -24 11 -18 25 -19 209 -19 187 0 198 1 198 19 0 14 -10 20 -46 25 -54 7 -343 7 -361 -1z"/>
            <path d="M11505 7173 c-15 -15 -15 -17 2 -33 24 -24 93 -36 93 -17 0 16 -37 51 -62 60 -10 3 -24 -1 -33 -10z"/>
            <path d="M707 7169 c-29 -17 -9 -29 48 -29 58 0 78 13 46 29 -25 14 -71 14 -94 0z"/>
            <path d="M3567 7173 c-4 -3 -7 -12 -7 -20 0 -10 31 -13 145 -13 138 0 145 1 145 20 0 19 -7 20 -138 20 -76 0 -142 -3 -145 -7z"/>
            <path d="M4260 7160 c0 -17 7 -20 50 -20 43 0 50 3 50 20 0 17 -7 20 -50 20 -43 0 -50 -3 -50 -20z"/>
            <path d="M4710 7160 c0 -19 7 -20 119 -20 66 0 122 4 126 9 12 20 -37 31 -139 31 -99 0 -106 -1 -106 -20z"/>
            <path d="M11176 7162 c-15 -18 -15 -20 1 -34 10 -9 28 -19 41 -22 12 -4 22 -12 22 -17 0 -17 54 -9 76 12 30 28 69 17 83 -23 14 -41 35 -30 39 20 2 31 -2 46 -17 61 -19 19 -33 21 -124 21 -88 0 -106 -3 -121 -18z"/>
            <path d="M11044 7157 c-11 -29 0 -102 16 -102 19 0 22 106 3 112 -7 3 -16 -2 -19 -10z"/>
            <path d="M10465 7141 c-3 -5 2 -17 11 -25 13 -14 50 -16 259 -16 226 0 301 8 225 25 -16 4 -32 11 -35 16 -8 12 -452 12 -460 0z"/>
            <path d="M10207 7124 c-16 -16 9 -24 73 -24 66 0 97 11 64 24 -21 8 -129 8 -137 0z"/>
            <path d="M12735 7123 c-38 -2 -79 -8 -90 -13 -11 -5 -31 -10 -45 -12 -17 -2 -25 -9 -25 -23 0 -18 8 -20 62 -23 67 -3 91 -22 78 -62 -10 -33 16 -33 46 1 26 29 27 34 14 49 -13 15 -13 19 8 38 13 12 33 22 45 22 13 0 22 6 22 15 0 9 -8 14 -22 13 -13 -1 -54 -3 -93 -5z"/>
            <path d="M750 7082 c0 -21 29 -32 86 -32 68 0 91 14 49 30 -31 12 -135 13 -135 2z"/>
            <path d="M2756 7074 c-22 -22 -36 -50 -29 -58 3 -3 28 -6 55 -6 54 0 63 17 29 58 -23 26 -34 28 -55 6z"/>
            <path d="M3327 7084 c-9 -9 3 -34 17 -34 6 0 28 -9 49 -20 38 -21 111 -27 122 -11 14 24 -166 86 -188 65z"/>
            <path d="M5345 7073 c-67 -34 -81 -68 -25 -56 25 4 34 0 57 -26 20 -22 36 -31 58 -31 31 0 65 28 65 54 0 18 -33 46 -56 46 -10 0 -28 7 -38 15 -23 17 -22 17 -61 -2z"/>
            <path d="M5924 7076 c-16 -12 -16 -15 -4 -20 65 -21 346 -34 363 -17 6 6 21 11 34 11 16 0 23 6 23 20 0 19 -7 20 -198 20 -156 0 -202 -3 -218 -14z"/>
            <path d="M3577 7073 c-4 -3 -7 -23 -7 -44 0 -34 3 -38 31 -44 36 -8 44 -2 33 22 -4 10 -9 23 -9 28 -6 37 -30 56 -48 38z"/>
            <path d="M4147 7034 c-4 -4 -7 -22 -7 -41 0 -31 2 -33 33 -33 20 0 39 8 50 20 26 31 22 50 -12 50 -16 0 -36 2 -43 5 -8 3 -17 2 -21 -1z"/>
            <path d="M4357 7034 c-16 -16 9 -24 73 -24 66 0 97 11 64 24 -21 8 -129 8 -137 0z"/>
            <path d="M4950 7025 c0 -12 16 -15 80 -15 64 0 80 3 80 15 0 12 -16 15 -80 15 -64 0 -80 -3 -80 -15z"/>
            <path d="M5802 7018 c-7 -7 -12 -23 -12 -36 0 -20 4 -23 33 -20 28 3 32 7 35 36 3 28 0 32 -20 32 -13 0 -29 -5 -36 -12z"/>
            <path d="M6452 6998 l3 -33 103 0 c105 0 128 9 80 33 -16 7 -28 17 -28 23 0 5 -36 9 -81 9 l-80 0 3 -32z"/>
            <path d="M7515 7020 c-3 -5 -21 -10 -39 -10 -58 0 -90 -61 -41 -80 26 -10 68 0 80 19 4 7 53 11 127 11 102 0 128 3 164 21 23 11 48 27 54 35 11 12 -11 14 -163 14 -106 0 -178 -4 -182 -10z"/>
            <path d="M5166 6902 c-3 -3 -1 -11 5 -19 7 -8 34 -13 75 -13 60 0 87 11 63 26 -14 8 -136 14 -143 6z"/>
            <path d="M3398 6838 c-18 -9 -41 -19 -50 -22 -10 -3 -18 -12 -18 -21 0 -12 14 -15 78 -15 66 1 81 4 107 25 36 30 27 42 -37 47 -32 2 -59 -3 -80 -14z"/>
            <path d="M12036 6802 c-7 -11 243 -262 261 -262 30 0 6 31 -111 148 -118 117 -138 132 -150 114z"/>
            <path d="M3132 6763 c-26 -10 2 -23 53 -23 54 0 79 12 49 24 -18 7 -83 7 -102 -1z"/>
            <path d="M2881 6722 c-6 -2 -7 -10 -4 -18 4 -10 23 -14 70 -14 55 0 64 2 61 17 -2 13 -15 17 -60 17 -32 1 -62 0 -67 -2z"/>
            <path d="M814 6671 c-21 -22 60 -29 412 -37 195 -4 222 -3 228 11 3 9 0 18 -7 20 -16 6 -627 11 -633 6z"/>
            <path d="M2588 6649 c-43 -22 -51 -49 -15 -49 21 0 137 56 137 66 0 12 -90 -1 -122 -17z"/>
            <path d="M10115 6631 c-9 -8 -5 -32 8 -45 21 -21 79 -46 107 -46 14 0 35 -7 46 -15 51 -38 173 9 174 68 0 13 -8 17 -40 17 -22 0 -40 -4 -40 -9 0 -5 -13 -12 -30 -16 -16 -4 -30 -11 -30 -16 0 -21 -55 -4 -67 20 -6 13 -20 29 -30 35 -18 10 -90 16 -98 7z"/>
            <path d="M1655 6582 c-2 -3 -2 -9 1 -13 7 -12 141 -11 149 1 3 6 -2 10 -12 11 -93 4 -134 4 -138 1z"/>
            <path d="M2130 6582 c-5 -2 -10 -8 -10 -13 0 -5 34 -9 76 -9 56 0 75 3 71 13 -3 11 -109 18 -137 9z"/>
            <path d="M7225 6480 c-3 -5 -14 -10 -24 -10 -30 0 -80 -51 -107 -109 -14 -31 -37 -70 -50 -88 -13 -17 -24 -36 -24 -41 0 -6 -34 -44 -75 -86 -60 -61 -81 -76 -105 -76 -16 0 -30 -4 -30 -9 0 -5 -9 -13 -20 -16 -22 -7 -28 -52 -10 -85 8 -15 15 -17 41 -10 17 5 43 17 57 26 42 28 127 117 157 164 15 25 40 61 55 80 15 19 30 52 34 73 7 35 64 107 85 107 5 0 20 11 35 25 15 14 33 25 40 25 7 0 21 9 31 20 18 20 17 20 -33 20 -28 0 -54 -4 -57 -10z"/>
            <path d="M11073 6483 c4 -3 26 -10 49 -14 91 -17 141 -29 152 -38 6 -5 34 -12 61 -15 28 -3 84 -10 125 -16 108 -13 131 -20 156 -47 30 -32 42 -23 39 29 -3 58 -2 56 -27 64 -41 14 -62 15 -218 21 -85 2 -159 9 -164 14 -6 5 -48 9 -95 9 -46 0 -81 -3 -78 -7z"/>
            <path d="M11735 6300 c3 -5 37 -10 75 -10 38 0 72 5 75 10 4 6 -23 10 -75 10 -52 0 -79 -4 -75 -10z"/>
            <path d="M11942 6278 c3 -30 6 -33 38 -33 29 0 34 3 32 20 -6 30 -22 45 -49 45 -21 0 -24 -4 -21 -32z"/>
            <path d="M8595 5545 c-109 -53 -109 -66 3 -182 94 -98 136 -157 128 -178 -4 -11 -21 -15 -66 -15 -55 0 -66 -4 -114 -40 -29 -22 -60 -40 -69 -40 -22 0 -31 -17 -37 -70 -4 -37 -9 -46 -27 -48 -24 -4 -28 6 -38 89 -3 31 -12 64 -18 73 -16 22 -109 36 -243 36 -114 0 -164 -13 -218 -55 -32 -24 -64 -18 -103 20 l-36 35 -196 0 -196 0 -48 -46 c-26 -25 -50 -58 -54 -72 -4 -15 -8 -153 -8 -307 l0 -280 38 -77 c44 -88 107 -151 171 -170 44 -13 71 -13 556 -3 231 5 319 10 330 19 29 25 50 25 97 1 27 -14 59 -25 73 -24 14 0 207 4 430 8 343 6 413 10 457 24 51 17 53 17 90 -3 34 -18 56 -20 203 -20 142 0 175 3 227 21 34 11 66 26 72 33 5 6 15 117 22 246 7 129 16 240 21 247 12 16 127 28 140 15 6 -6 14 -64 19 -129 19 -277 60 -358 207 -406 110 -36 439 -40 550 -6 36 10 45 10 68 -6 24 -15 48 -17 238 -12 135 3 225 9 249 18 33 11 44 10 85 -4 40 -15 95 -17 392 -18 527 -1 557 0 616 22 89 34 83 2 84 459 1 402 1 404 -21 434 -21 28 -22 34 -11 98 15 87 15 215 1 257 -7 19 -22 36 -36 42 -13 5 -87 9 -164 9 -127 0 -145 -2 -192 -24 -95 -44 -97 -48 -97 -197 0 -114 2 -130 18 -136 25 -9 52 -34 52 -48 0 -7 -18 -20 -40 -29 l-40 -16 -59 40 c-56 39 -61 40 -141 40 -81 0 -246 -23 -285 -40 -79 -35 -97 -39 -117 -29 -19 10 -20 17 -13 169 l7 158 -25 26 c-26 26 -27 26 -196 26 l-170 0 -60 -40 c-68 -45 -67 -43 -79 -187 -10 -112 -21 -137 -55 -124 -54 21 -137 41 -168 41 -60 0 -63 8 -70 135 -5 109 -7 117 -32 143 l-27 27 -153 0 c-124 -1 -158 -4 -184 -18 -18 -9 -40 -17 -49 -17 -9 0 -32 -11 -50 -25 l-32 -25 -4 -115 c-3 -109 -4 -116 -28 -132 -67 -49 -120 -53 -161 -13 l-31 29 11 95 c6 52 11 128 11 168 0 65 -3 77 -23 96 -22 21 -33 22 -188 22 l-164 0 -57 -37 c-31 -20 -59 -46 -62 -57 -3 -12 -6 -72 -7 -134 l-1 -114 31 -19 c37 -22 52 -51 30 -58 -8 -2 -29 -19 -47 -38 l-34 -33 3 -240 c2 -159 0 -243 -7 -250 -13 -13 -252 16 -271 32 -26 22 -11 48 70 116 138 118 128 98 128 258 0 120 -2 140 -18 156 -14 13 -53 23 -147 35 -87 12 -130 22 -134 31 -3 8 14 32 39 56 41 38 87 88 148 161 68 81 85 127 59 153 -21 21 -179 15 -238 -8 -35 -14 -74 -20 -128 -20 -58 0 -88 5 -117 20 -60 31 -202 28 -270 -5z m678 -19 c9 -7 17 -20 17 -28 0 -15 -122 -161 -170 -203 -18 -17 -39 -21 -127 -23 -66 -3 -114 0 -131 8 -28 12 -195 191 -200 214 -2 7 10 19 26 25 38 16 128 1 205 -33 32 -14 68 -26 80 -26 23 0 83 19 106 34 22 14 123 44 151 45 14 0 33 -6 43 -13z m3215 -26 c127 -12 132 -17 132 -133 0 -123 -4 -127 -128 -127 -120 0 -170 14 -178 49 -3 14 -10 36 -15 49 -5 13 -9 45 -9 73 0 63 21 83 100 98 3 0 47 -4 98 -9z m-2553 -20 c14 -15 18 -38 19 -114 1 -126 -4 -132 -122 -129 -105 2 -172 21 -189 54 -19 35 -17 159 3 187 14 21 22 22 143 22 115 0 130 -2 146 -20z m1554 -64 c11 -9 12 -54 6 -262 -7 -258 -4 -314 20 -314 7 0 31 28 51 63 55 90 135 187 159 192 101 21 138 25 220 25 86 0 95 -2 106 -21 9 -18 7 -30 -11 -68 -13 -25 -33 -59 -45 -76 -52 -72 -115 -187 -115 -211 0 -14 8 -38 19 -52 10 -15 44 -76 76 -137 32 -60 75 -133 96 -162 74 -100 53 -114 -171 -116 -133 -2 -158 0 -180 16 -13 9 -50 64 -80 122 -58 109 -104 170 -120 160 -6 -4 -10 -61 -10 -129 0 -84 -4 -128 -13 -140 -11 -16 -31 -18 -166 -18 -84 0 -156 3 -159 7 -8 8 -10 914 -3 1040 l6 90 45 6 c63 9 252 -1 269 -15z m-832 -1 c19 -13 21 -26 24 -145 3 -103 7 -133 19 -140 8 -5 51 -10 95 -10 88 -1 108 -10 125 -56 15 -37 4 -161 -17 -193 -15 -23 -19 -23 -109 -19 -88 5 -96 4 -106 -15 -12 -24 -3 -199 12 -228 17 -31 66 -49 151 -56 67 -5 83 -10 94 -27 16 -25 20 -199 5 -226 -14 -26 -124 -34 -272 -22 -112 10 -120 12 -166 45 -56 42 -151 140 -153 159 -1 7 -3 24 -4 38 -1 14 -8 57 -14 95 -6 39 -11 102 -11 140 0 98 -13 115 -89 115 -40 0 -63 5 -71 15 -7 9 -13 48 -14 96 -1 74 1 82 23 100 16 13 39 19 72 19 68 0 75 16 82 165 5 114 7 121 32 142 24 21 36 23 148 23 92 0 128 -4 144 -15z m-2911 -345 c7 -19 17 -133 23 -253 13 -242 21 -276 70 -296 65 -27 116 8 136 94 12 53 12 83 -4 250 -10 104 -16 197 -14 206 9 32 67 42 207 36 111 -5 132 -8 149 -26 19 -19 20 -34 21 -401 1 -367 0 -382 -18 -396 -15 -10 -55 -14 -162 -14 -147 0 -158 3 -166 45 -5 31 -40 29 -78 -5 -65 -58 -178 -75 -291 -43 -49 14 -72 27 -115 70 -30 30 -54 58 -54 64 0 6 -11 25 -24 42 -41 56 -46 104 -44 378 2 201 6 260 17 273 12 14 34 16 175 14 l161 -3 11 -35z m1392 31 c220 -10 213 -6 220 -155 l5 -105 -30 -28 c-16 -15 -84 -74 -151 -131 -119 -100 -142 -125 -127 -140 3 -4 48 -10 98 -13 155 -11 221 -21 240 -37 14 -12 17 -32 17 -103 0 -126 21 -119 -340 -118 -358 1 -468 8 -487 34 -8 12 -13 48 -13 100 0 113 -3 108 261 340 58 51 75 77 64 95 -4 6 -64 10 -149 10 -117 0 -146 3 -156 15 -7 9 -15 49 -18 90 -6 93 8 131 52 144 39 11 286 12 514 2z m817 -36 l25 -24 -1 -263 c-1 -145 -4 -307 -8 -360 -8 -133 -8 -133 -164 -133 -80 0 -133 5 -154 13 -29 13 -32 19 -39 69 -11 87 9 674 24 701 12 21 18 22 153 22 135 0 141 -1 164 -25z m2679 9 c3 -9 6 -183 6 -388 0 -343 -1 -374 -17 -388 -14 -13 -46 -16 -150 -16 -184 -1 -174 -13 -181 206 -4 149 10 505 23 569 6 27 20 30 181 32 112 1 133 -1 138 -15z m-490 -70 c3 -9 6 -138 6 -289 0 -351 -6 -360 -116 -169 -114 197 -113 180 -23 329 40 66 80 125 88 132 22 17 38 16 45 -3z m-1133 -166 c3 -26 9 -85 15 -165 8 -106 4 -109 -133 -88 -54 8 -104 15 -110 15 -30 0 -53 40 -53 90 0 56 24 90 62 90 52 0 139 25 160 46 25 25 57 31 59 12z m-2568 -28 c20 -16 46 -22 114 -26 116 -7 133 -11 133 -32 0 -9 -52 -69 -117 -132 -65 -64 -124 -124 -131 -134 -8 -9 -21 -16 -30 -14 -15 3 -17 24 -20 168 -1 90 0 170 2 177 7 18 19 16 49 -7z"/>
            <path d="M6385 5505 c-27 -20 -54 -44 -60 -53 -13 -24 -9 -240 6 -258 6 -8 19 -14 29 -14 10 0 20 -10 24 -22 4 -17 -1 -29 -22 -45 -34 -29 -63 -29 -88 -2 -10 11 -37 29 -58 40 -76 37 -307 16 -430 -39 -58 -26 -60 -26 -80 -6 -13 13 -16 44 -16 179 0 209 15 195 -208 195 l-163 0 -64 -37 c-35 -20 -67 -44 -71 -52 -11 -27 -23 -409 -17 -561 5 -133 4 -147 -13 -168 l-19 -23 -40 31 c-132 104 -154 145 -85 156 44 7 87 43 96 81 13 51 -67 153 -156 199 -103 53 -154 64 -297 64 l-132 0 -85 -40 c-47 -22 -109 -49 -138 -61 -29 -12 -68 -29 -86 -37 -43 -22 -64 -9 -79 51 -15 61 -18 65 -61 77 -74 20 -158 9 -259 -36 -46 -21 -74 -17 -118 14 -39 26 -45 27 -191 30 -146 3 -152 3 -180 -20 -16 -13 -48 -36 -71 -50 -40 -26 -42 -30 -47 -90 -4 -35 -7 -83 -9 -108 -2 -41 -4 -45 -27 -45 -19 0 -27 7 -34 30 -17 56 -65 154 -85 174 -66 66 -260 111 -482 111 l-116 0 -87 -44 c-84 -43 -189 -120 -250 -185 -42 -44 -69 -41 -95 12 -25 52 -26 66 -6 103 20 40 19 60 -10 121 -41 89 -172 213 -262 247 -21 8 -65 19 -98 25 -67 10 -418 8 -450 -4 -38 -14 -90 -37 -188 -85 -79 -39 -106 -59 -144 -104 -106 -126 -133 -295 -99 -621 19 -174 33 -210 115 -294 73 -76 93 -85 271 -121 153 -32 288 -27 480 17 148 33 257 100 341 207 50 65 84 75 95 29 10 -40 69 -126 116 -168 62 -56 113 -74 259 -90 140 -16 263 -9 384 21 55 14 181 71 214 98 21 16 85 107 99 139 9 21 18 28 35 25 21 -3 22 -8 28 -127 5 -106 8 -126 25 -138 15 -11 61 -14 234 -11 196 3 218 5 250 24 l35 20 5 212 c6 260 3 253 138 264 48 3 112 9 143 13 53 7 56 6 78 -21 89 -117 102 -137 99 -157 -2 -11 -26 -39 -55 -61 -46 -37 -52 -45 -52 -82 -1 -28 6 -50 23 -73 32 -43 119 -107 170 -125 199 -68 534 -36 656 63 79 65 159 112 183 109 19 -3 23 -12 30 -63 12 -86 20 -108 43 -120 30 -15 399 -3 447 15 33 13 43 12 85 -2 41 -15 103 -17 496 -16 437 0 450 1 515 22 66 23 66 23 79 72 10 37 13 137 12 399 -1 335 -8 435 -32 435 -6 0 -7 22 -3 58 3 31 8 108 11 171 l5 114 -27 24 c-26 22 -34 23 -193 23 l-166 0 -50 -35z m366 -34 c15 -19 19 -39 19 -109 0 -117 -5 -122 -124 -121 -50 0 -111 6 -135 12 -50 13 -54 21 -65 124 -6 48 -3 63 14 91 l21 34 125 -4 c118 -3 127 -4 145 -27z m-1113 -43 c9 -9 12 -88 12 -294 0 -156 4 -285 8 -288 5 -3 46 45 92 106 46 62 91 119 101 129 22 22 160 42 264 37 73 -3 80 -5 83 -25 4 -29 -34 -108 -113 -228 -35 -55 -65 -104 -65 -110 0 -16 62 -131 154 -284 47 -80 86 -148 86 -153 0 -4 -12 -15 -27 -25 -23 -15 -51 -18 -191 -18 l-164 0 -33 39 c-18 22 -51 74 -72 115 -45 90 -93 156 -104 144 -4 -4 -12 -66 -18 -137 -5 -71 -14 -133 -18 -137 -6 -6 -238 -14 -300 -10 -25 2 -36 72 -29 195 4 67 9 299 12 516 3 216 10 402 15 412 7 13 25 18 77 21 159 8 218 7 230 -5z m-3986 -29 c80 -17 117 -36 186 -96 90 -79 133 -135 139 -183 9 -69 5 -70 -203 -70 l-183 0 -33 28 c-58 50 -86 62 -135 62 -49 0 -82 -16 -115 -55 -15 -17 -17 -44 -18 -192 0 -196 10 -262 49 -305 26 -29 31 -30 102 -30 l74 1 43 46 c56 62 55 79 -7 100 -27 9 -54 22 -60 29 -6 7 -12 52 -13 100 -4 123 -15 118 254 114 193 -3 219 -5 235 -21 16 -16 18 -38 18 -190 -1 -166 -2 -174 -27 -222 -28 -54 -104 -132 -153 -158 -162 -87 -326 -118 -496 -92 -91 13 -114 21 -184 61 -88 51 -157 118 -186 179 -49 107 -71 334 -49 515 23 189 67 262 197 326 42 22 96 44 118 50 53 15 379 17 447 3z m1178 -293 c124 -27 210 -82 226 -146 4 -14 10 -29 14 -35 4 -5 18 -39 30 -75 19 -53 23 -86 24 -180 0 -104 -2 -120 -27 -173 -48 -105 -78 -134 -202 -196 -45 -22 -65 -25 -207 -29 -148 -4 -163 -3 -241 21 -87 28 -102 38 -159 109 -90 110 -107 184 -73 324 65 272 82 308 180 361 l60 32 155 1 c96 0 180 -5 220 -14z m817 -5 c19 -12 34 -31 38 -50 9 -40 19 -45 52 -26 135 78 180 95 257 95 79 0 86 -11 86 -150 0 -158 5 -153 -157 -160 -138 -7 -156 -12 -198 -62 l-27 -32 7 -206 c7 -190 6 -207 -11 -220 -14 -12 -48 -15 -160 -13 -79 1 -151 6 -163 12 -30 17 -32 60 -23 448 7 261 12 356 22 368 10 12 36 15 129 15 97 0 121 -3 148 -19z m1201 4 c54 -19 77 -32 130 -73 46 -36 85 -102 76 -126 -9 -24 -37 -28 -174 -28 -108 0 -133 3 -167 21 -55 28 -97 17 -101 -26 -3 -25 2 -34 30 -50 18 -10 67 -25 108 -32 41 -7 91 -17 110 -23 68 -22 210 -131 239 -186 14 -26 14 -65 0 -94 -18 -37 -113 -106 -221 -161 l-100 -50 -121 -1 c-124 -1 -220 16 -284 49 -15 8 -33 15 -40 15 -23 0 -113 98 -113 123 0 34 33 44 168 51 92 4 128 1 188 -14 91 -24 127 -16 122 27 -4 38 -46 59 -175 90 -109 27 -165 55 -242 121 -32 27 -35 34 -39 96 l-4 67 50 48 c72 69 130 115 182 145 43 24 53 26 190 26 102 0 158 -5 188 -15z m1916 -18 c14 -10 19 -37 26 -137 19 -252 6 -608 -22 -637 -12 -11 -46 -15 -151 -16 -117 -2 -139 0 -153 15 -16 15 -19 54 -26 330 -9 364 -5 426 32 445 35 18 270 18 294 0z m-5352 -61 c22 -27 23 -49 1 -68 -47 -40 -83 -28 -83 29 0 72 40 92 82 39z m4882 -18 c11 -43 7 -543 -5 -555 -19 -19 -53 5 -87 61 -18 29 -32 57 -32 63 0 6 -9 21 -19 35 -26 32 -71 118 -71 133 0 12 28 61 104 180 21 33 45 70 52 83 8 12 23 22 33 22 11 0 21 -9 25 -22z"/>
            <path d="M2608 4875 c-33 -31 -43 -97 -35 -237 6 -113 19 -138 72 -138 54 0 82 35 91 116 18 153 1 233 -56 267 -37 22 -40 22 -72 -8z"/>
          </g>
        </svg>
      `)
    };
    const defaultImgSrc_png = "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEicpyIovkBboaA3DOVcPNZQQ47-GSa5AidzIeUbL2N8iue6yM1XIxd0BL5W8e2ty7ntqz4K8ovfmT7DV1c3_NXVFWWDLeKYMpbD_C1wK1qh4Y1zGLh_tHUi5d1pHtDxxQKunZLAkL3ibt5gjhI3KQX9cHtQMn0m9liFgtLc00VQH4YHc5I6aAO-mw84w8Q/s600/end_cover_photo.png";
    
    // Default cover photo
    const defaultImgSrc = "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgOeImsdWR0X78A0DBrMxPaz8JnOzELaQisEXya9i1FR0IJRLKxk-aqHFnA7evS4gqsbyvfKr0KuXrXTP6uZ8F10bYls4zfDU7qOgD9dG7HZBm3UJRsFc9nv4jXscecg0hbLt1V4vG8Px4hemML8-HAnkmYITUeOyP-PrIChGugMmX6UtRca6zgq1LFCIbm/s600/20230427_132541.jpg";

    // Array to hold all slideshows data
    let slideshows = [];

    // DOM Element Arrays
    const mySlideshowContainer = [];
    const slideshowOuterContainer = [];
    const slideshowContainer = [];
    const progressBarContainer = [];
    const coverPhotoContainer = [];
    const photoOverlay = [];
    const slideContainers = [];
    const toggleNavigationButton = [];
    const settingsButton = [];
    const previousPhoto = [];
    const toggleSlideshowButton = [];
    const nextPhoto = [];
    const fullscreenButton = [];
    const enterFullscreenIcon = [];
    const exitFullscreenIcon = [];
    const playIcon = [];
    const pauseIcon = [];
    const toggleTooltip = [];
    const qualitySliderElement = [];
    const qualityValueElement = [];
    const speedSliderElement = [];
    const speedValueElement = [];
    const navigationControl = [];
    const navigationControlButtons = []; // Navigation control buttons array
    const descriptionControlStyle = []; // Controll style of image description
    const sliderContainer = []; // New sliderContainer array
    const autoQualityCheckbox = []; // Quality checkbox selection
    const preloadAllButton = [];
    var controllButton = []; // Navigation control controllButton
    var descriptionStyle = []; // Controll style of image description in all containers

    /**
     * @brief   A Least Recently Used (LRU) cache implementation with size-based eviction.
     *
     * @details This class manages a cache that automatically evicts the least recently used 
     *          items when the total size exceeds the defined `maxSize`. Items are stored 
     *          with their respective sizes, allowing the cache to efficiently manage memory 
     *          usage. Common operations include adding, retrieving, and deleting items while 
     *          maintaining a strict size limit.
     *
     * @class   LRUCacheBySize
     *
     * @param   {number} maxSize The maximum allowed size of the cache in bytes.
     *
     * @methods 
     * - `set(key, value, size)` Adds a key-value pair to the cache. Evicts the least recently 
     *   used items if the cache exceeds the maximum size.
     * - `get(key)` Retrieves a value by its key. Marks the accessed item as recently used.
     * - `has(key)` Checks if a key exists in the cache.
     * - `delete(key)` Removes a key-value pair from the cache and adjusts the size.
     * - `clear()` Clears all items from the cache and resets the size.
     *
     * @example
     * const cache = new LRUCacheBySize(1024 * 1024); // 1MB max size
     * cache.set('image1', img1, 400000); // Add an image with a size of 400KB
     * const image = cache.get('image1'); // Retrieve the cached image
     *
     * @note    The size of each item must be explicitly provided during insertion. The cache 
     *          uses a `Map` to store items and their metadata, ensuring O(1) access and update times.
     */
     class LRUCacheBySize {
        constructor(maxSize) {
            this.cache = new Map(); // Store cached items
            this.maxSize = maxSize; // Max size in bytes
            this.currentSize = 0;   // Current total size in bytes
        }

        // Set a key-value pair in the cache
        set(key, value, size) {
        if (typeof size !== "number" || isNaN(size)) {
            console.warn(`Skipping cache entry for ${key} — invalid size.`);
            return; // Don't add items with undefined or invalid size
        }

        if (this.cache.has(key)) {
            this.currentSize -= this.cache.get(key).size;
            this.cache.delete(key);
        }

        while (this.currentSize + size > this.maxSize) {
            const oldestKey = this.cache.keys().next().value;
            const oldestItem = this.cache.get(oldestKey);
            this.currentSize -= oldestItem.size;
            this.cache.delete(oldestKey);
        }

        this.cache.set(key, { value, size });
        this.currentSize += size;
    }

        // Get a value by its key
        get(key) {
            if (!this.cache.has(key)) return null;

            const item = this.cache.get(key);

            // Move accessed item to the end to mark it as recently used
            this.cache.delete(key);
            this.cache.set(key, item);

            return item.value;
        }

        // Check if a key exists
        has(key) {
            return this.cache.has(key);
        }

        // Delete a key-value pair
        delete(key) {
            if (this.cache.has(key)) {
                const item = this.cache.get(key);
                this.currentSize -= item.size;
                this.cache.delete(key);
            }
        }

        // Clear the cache
        clear() {
            this.cache.clear();
            this.currentSize = 0;
        }
    }

    const imageCache = new LRUCacheBySize(50 * 1024 * 1024); // Cache size limit: 50MB

    // Call the function to generate the slideshow containers
    generateSlideshowContainers(defaultImgSrc);


    /**
     * @brief   Generates slideshow containers dynamically based on available titles and cover photos.
     *
     * @details This function iterates through the available slideshow titles, retrieves the corresponding cover photo
     *          for each slideshow, and inserts the slideshow container into the DOM. If no valid cover photo is found,
     *          a default image source is used. The function also minimizes image source sizes and logs all slideshow titles.
     *
     * @param   defaultImgSrc    The default image source to be used if no valid cover photo is found.
     *
     * @return  None.
     */
    function generateSlideshowContainers(defaultImgSrc) {
        // Generate slideshow containers by iterating through available titles and assigning cover photos, using a default if necessary.
        while (typeof window[`slideshowTitle${slideshowIndex}`] !== 'undefined') {
            // Access the variable
            const SlideshowTitle = window[`slideshowTitle${slideshowIndex}`];
            let coverPhoto = window[`CoverPhoto${slideshowIndex}`];
            
            // Check if the cover photo is valid, if not set it to a default source
            if (!coverPhoto || coverPhoto.trim() === "") {
                coverPhoto = defaultImgSrc;  // Set the image source to the predefined URL
            }

            // At least one Slideshow found - Minimize post image source sizes
            updateImageSources(1);

            // Collect titles
            slideshowTitles.push(SlideshowTitle);

            // Insert the slideshow container
            insertSlideshowContainer(SlideshowTitle, coverPhoto, slideshowIndex); 
            
            // Move to the next slideshow index
            slideshowIndex++;
        }

        // Log the titles of the slideshows that will be created
        console.log('All slideshows:', slideshowTitles);

        // Call the function to initialize slideshows
        initializeSlideshows(numberOfSlideshows, defaultImgSrc);
    }


    /**
     * @brief   Updates the source URL of all images based on the specified size.
     *
     * @details This function finds all images within elements having the class 'tr-caption-container' and updates their
     *          `src` attributes to reflect a new size. The size is specified as a parameter, and the function uses a regular
     *          expression to modify the source URL, replacing the previous size with the given size.
     *
     * @param   size  The new size value to be applied to the image sources.
     *
     * @return  None.
     */
    function updateImageSources(size) {
        // Select all images inside elements with the class 'tr-caption-container'
        const images = document.querySelectorAll('.tr-caption-container img[src]');
        
        for (let i = 0; i < images.length; i++) {
            let imgSrc = images[i].getAttribute('src');

            // Use regex to change the src link
            // This regex will replace /s<digits>/ or /s<digits>-<any character>/ with /s<size>/
            const newSrc = imgSrc.replace(/\/s\d+(-rw)?\//, `/s${size}/`);

            // Update the src attribute
            images[i].setAttribute('src', newSrc);
        }
    }


    /**
     * @brief   Dynamically inserts a slideshow container into the DOM.
     *
     * @details This function creates and inserts a complete slideshow container structure, which includes the slideshow
     *          image display, navigation controls, progress bar, and settings for quality and speed adjustments.
     *          The slideshow is inserted after the corresponding script tag in the DOM. It uses the provided slideshow
     *          title and cover photo for initialization, and dynamically generates a unique set of HTML elements for each
     *          slideshow instance, identified by an index.
     *
     * @param   slideshowTitle  The title for the slideshow that is displayed on the cover photo.
     * @param   coverPhoto      The URL of the image displayed as the cover photo for the slideshow.
     * @param   index           The unique index to identify each slideshow instance and dynamically generate its elements.
     *
     * @return  None.
     */
    function insertSlideshowContainer(slideshowTitle, coverPhoto, index) {
        console.log(`Inserting slideshow container for index ${index}: Title=${slideshowTitle}, Cover Photo=${coverPhoto}`);
        
        // Create a new div element as a holder (wrapper) for the slideshow container
        var wrapperDiv = document.createElement('div');
        wrapperDiv.id = `slideShow-${index}`; // Set a unique ID for each slideshow div
        wrapperDiv.className = 'my-slideshow-wrapper'; // Add a class for the slideshow wrapper (holder)

        // Add the full slideshow structure, dynamically generating the slides
        wrapperDiv.innerHTML = `
            <div class='my-slideshow-container' id="mySlideshowContainer-${index}" style="display: block;">
                <div class='slideshow-outer-container' id="slideshowOuterContainer-${index}">
                    <div class='slideshow-container' id="slideshowContainer-${index}">
                    
                        <!-- Progress Bar Container (Red Timeline) -->
                        <div class="overlay-progress-container" id="overlayProgressContainer-${index}" 
                                onmouseenter="toggleProgressBarVisibility(${index}, '5px', 'hover')" 
                                onmouseleave="toggleProgressBarVisibility(${index}, '0px', 'hover')">
                            <div class="progress-container" id="progressBarContainer-${index}">
                                <div class="progress-bar" id="progressBar-${index}"></div>
                            </div>
                        </div>

                        <!-- Invisible Overlay for Click Events -->
                        <div class="overlay-container" id="overlayContainer-${index}" style="position: absolute; top: 0; left: 0; width: 100%; height: 0; display: flex; z-index: 1;">
                            <!-- Left Section for Previous Slide -->
                            <div class="overlay-left" style="flex: 1;" onclick="enqueueManualSlide(${index}, -1)"></div>
                            <!-- Middle Section for Play/Pause Slideshow and Fullscreen Toggle on Double-click -->
                            <div class="overlay-middle" style="flex: 1;" onclick="handleClick(${index})"></div>
                            <!-- Right Section for Next Slide -->
                            <div class="overlay-right" style="flex: 1;" onclick="enqueueManualSlide(${index}, 1)"></div>
                        </div>

                        <!-- Cover Photo (Displayed initially) -->
                        <div class="cover-photo-container" id="coverPhotoContainer-${index}">
                            <img alt="Cover Photo" src="${coverPhoto}" id="coverPhotoElement-${index}" />
                            <div class="photo-overlay" id="photoOverlay-${index}">
                                <span class="my-title">${postTitle}</span>
                            </div>
                        </div>


                        <!-- First image (Previous) -->
                        <div class='mySlides slide1' id="slide1-${index}">
                            <div class='uppertext'></div>
                            <img alt='' src=''/>
                            <div class='text' id="descriptionControllStyle0-${index}"></div>
                        </div>
                        <!-- Second image (Current) -->
                        <div class='mySlides slide2' id="slide2-${index}">
                            <div class='uppertext'></div>
                            <img alt='' src=''/>
                            <div class='text' id="descriptionControllStyle1-${index}"></div>
                        </div>
                        <!-- Third image (Next) -->
                        <div class='mySlides slide3' id="slide3-${index}">
                            <div class='uppertext'></div>
                            <img alt='Next Image' src=''/>
                            <div class='text' id="descriptionControllStyle2-${index}"></div>
                        </div>
                    </div>

                    <!-- Navigation control (previous/next buttons) -->
                    <div class='navigation-controll' id="navigationControl-${index}" style="z-index: 2;">

                        <!-- Toggle Navigation Button -->
                        <span data-is-tooltip-wrapper="true">
                            <button aria-label="Toggle Navigation" id="toggleNavigationButton-${index}"style="display: none;">
                                <svg id="toggleIcon-${index}" height="24px" viewBox="0 0 24 24" width="24px" style="display: block;">
                                    <path d="M3 12h18M3 6h18M3 18h18" stroke="#000" stroke-width="2" stroke-linecap="round" />
                                </svg>
                                <div class="tooltip">Meni</div>
                            </button>
                        </span>

                        <!-- Settings button (appears on hover) -->
                        <span data-is-tooltip-wrapper="true" class="toggle-target" id="navigationControlButton0-${index}"style="display: none;">
                            <button aria-label="Settings" id="settingsButton-${index}">
                                <!-- Settings Icon -->
                                <svg id="settingsIcon-${index}" height="24px" viewBox="0 0 24 24" width="24px" style="display: block;">
                                    <path stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 21h-4l-.551-2.48a6.991 6.991 0 0 1-1.819-1.05l-2.424.763-2-3.464 1.872-1.718a7.055 7.055 0 0 1 0-2.1L3.206 9.232l2-3.464 2.424.763A6.992 6.992 0 0 1 9.45 5.48L10 3h4l.551 2.48a6.992 6.992 0 0 1 1.819 1.05l2.424-.763 2 3.464-1.872 1.718a7.05 7.05 0 0 1 0 2.1l1.872 1.718-2 3.464-2.424-.763a6.99 6.99 0 0 1-1.819 1.052L14 21z"/>
                                    <circle cx="12" cy="12" r="3" stroke="#000000" stroke-width="2"/>
                                </svg>
                                <div class="tooltip">Nastavitve</div>
                            </button>
                        </span>

                        <span data-is-tooltip-wrapper='true' class="toggle-target" id="navigationControlButton1-${index}"style="display: none;">
                            <button aria-label='Prejšnja' id='previousPhoto-${index}'>
                                <span aria-hidden='true'>
                                    <svg height='24px' viewBox='0 0 24 24' width='24px'>
                                        <path d='M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z'/>
                                    </svg>
                                </span>
                                <div class='tooltip' style='display: none; opacity: 0;'>Prejšnja</div>
                            </button>
                        </span>

                        <span data-is-tooltip-wrapper='true' class="toggle-target" id="navigationControlButton2-${index}"style="display: none;">
                            <button aria-label='Predvajaj' id='toggleSlideshowButton-${index}'>
                                <span aria-hidden='true' id='toggleIcon-${index}'>
                                    <svg height='24px' viewBox='0 0 24 24' width='24px'>
                                        <path d='M8 5v14l11-7z' id='playIcon-${index}' style='display: block;'/>
                                        <path d='M6 19h4V5H6v14zm8-14v14h4V5h-4z' id='pauseIcon-${index}' style='display: none;'/>
                                    </svg>
                                </span>
                                <div class='tooltip' id='toggleTooltip-${index}' style='display: none; opacity: 0;'>Predvajaj</div>
                            </button>
                        </span>

                        <span data-is-tooltip-wrapper='true' class="toggle-target" id="navigationControlButton3-${index}"style="display: none;">
                            <button aria-label='Naprej' id='nextPhoto-${index}'>
                                <span aria-hidden='true'>
                                    <svg height='24px' viewBox='0 0 24 24' width='24px'>
                                        <path d='M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z'/>
                                    </svg>
                                </span>
                                <div class='tooltip' style='display: none; opacity: 0;'>Naprej</div>
                            </button>
                        </span>

                        <span data-is-tooltip-wrapper="true" class="toggle-target" id="navigationControlButton4-${index}"style="display: none;">
                            <button aria-label="Fullscreen" id="fullscreenButton-${index}">
                                <!-- Enter Fullscreen Icon -->
                                <svg id="enterFullscreenIcon-${index}" height="24px" viewBox="0 0 24 24" width="24px" style="display: block;">
                                    <path d="M4 4h5V2H2v7h2V4zm16 0v5h2V2h-7v2h5zM9 18H4v-5H2v7h7v-2zm11-5v5h-5v2h7v-7h-2z"></path>
                                </svg>
                                <!-- Exit Fullscreen Icon -->
                                <svg id="exitFullscreenIcon-${index}" height="24px" viewBox="0 0 24 24" width="24px" style="display: none;">
                                    <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"></path>
                                </svg>
                                <div class="tooltip">Celozaslonsko</div>
                            </button>
                        </span>
                    </div>

                    <!-- Slider Container inside the slideshow, positioned at bottom-right --> 
                    <div class='slider-container' id='sliderContainer-${index}' style="display: none; flex-direction: column; gap: 10px;">

                        <!-- Row for Quality Title and Auto Checkbox Title, aligned symmetrically above slider and checkbox -->
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <!-- Quality Title centered above the slider -->
                            <label for='qualitySliderElement' style="text-align: center; flex-basis: 70%;">Kvaliteta: <span id='qualityValueElement-${index}'>${initQuality}</span></label>
                            
                            <!-- Auto Checkbox Title centered above the checkbox -->
                            <label for='autoQualityCheckbox-${index}' style="text-align: center; flex-basis: 30%;">Auto</label>
                        </div>
                        
                        <!-- Row for Quality Slider and Auto Checkbox -->
                        <div style="display: flex; align-items: center;">
                            <!-- Quality Slider with 70% width -->
                            <input id='qualitySliderElement-${index}' max='11' min='1' step='1' type='range' value='${initQuality}' style="flex-basis: 70%;"/>
                            
                            <!-- Auto Checkbox with 30% width -->
                            <input type='checkbox' id='autoQualityCheckbox-${index}' checked style="flex-basis: 30%;"/>
                        </div>
                        
                        <!-- Row for Speed Slider -->
                        <div style="display: flex; flex-direction: column;">
                            <label for='speedSliderElement'>Hitrost: <span id='speedValueElement-${index}'>${initSpeed}</span>s</label>
                            <input id="speedSliderElement-${index}" max="${maxSpeed}" min="${minSpeed}" step="${stepSpeed}" type="range" value="${initSpeed}" />
                          </div>

                        <div style="display: flex; flex-direction: column;">
                            <!-- Button to Preload All Images as the last element -->
                            <button id="preloadAllButton-${index}" style="margin-top: 10px; width: 100%; background-color: transparent; color: gray; font-size: 12px; border: 3px solid gray; border-radius: 5px; line-height: 1;">Predpriprava slik</button>
                        </div>
    
                    </div>
                </div>
            </div>
        `;

        // Insert the wrapper div into the DOM after the corresponding script tag
        var scriptTags = document.getElementsByTagName('script');
        var targetScriptTag;

        // Find the target script tag that contains the specific index
        for (var i = 0; i < scriptTags.length; i++) {
            if (scriptTags[i].innerText.includes('var slideshowTitle' + index)) {
                targetScriptTag = scriptTags[i];
                numberOfSlideshows.push(index);   // Number of slideshows
                break;
            }
        }

        // If the target script tag is found, insert the container
        if (targetScriptTag) {
            targetScriptTag.parentNode.insertBefore(wrapperDiv, targetScriptTag.nextSibling);
        }
    }


    /**
     * @brief   Initializes the slideshow data and DOM elements for all slideshows.
     *
     * @details This function initializes the slideshow data, populates the slideshow arrays with default values,
     *          and collects DOM elements related to the slideshow. The function is called for each slideshow
     *          in the `numberOfSlideshows` array.
     *
     * @param   numberOfSlideshows  Array that contains the indices of the slideshows to be initialized.
     * @param   defaultImgSrc       The default image source to be used for missing cover photos.
     *
     * @return  None.
     */
    function initializeSlideshows(numberOfSlideshows, defaultImgSrc) {
        // Create the slideshows with default values for elements in the array
        numberOfSlideshows.forEach(index => {
            slideshows[index] = {
                startIndex: 1,
                maxResults: 25,
                imageBuffer: [],
                shuffledImages: [],
                currentBatchIndex: 0,
                activeSlide: 0,
                hideTimeout: null,
                slideshowTimeout: null,
                clickCount: -1, // Flag for menu layout
                slideshowSpeed: 3000, // Default speed (3 seconds)
                qualityValue: 7,      // Quality value
                isSlideshowRunning: false, // Flag for slideshow running state
                wasSlideshowRunning: false, // Flag for slideshow running state
                pauseSlideshowFlag: false,
                previousBackgroundColor: null,  // Variable to store the original background color of navigation button
                isSlideshowReady: false,  // Flag to track if all slideshows are initialized
                currentTime: 0,  // Store current time in milliseconds
                lastClickTime: 0,  // To store the time of the last click
                clickTimer: 0, // Timer for single-click detection
                progressBarHeightKey: '0px', // Progress bar status
                coverPhotoHidden: false,  // Track, that cover photo in hidden just once
                connectionErrorTimeout: null,  // Define a variable to store the timeout reference
                imageIsReady: true,  // Track when image is prepared (Initialize as true to ensure smooth start with manual slide functionality)
                attempts: 0, // Track internet quality
                manualAttempts: 0, // Track internet quality for manual sliding
                isProcessingQueue: false,  // Track it actions from manual sliding are proccesing
                errorFlag: true,  // Error flag (show or hide connection status message)
                textClickCount: 0, // Flag for image description container style
            };
        });

        // Populate the DOM element arrays
        numberOfSlideshows.forEach(index => {
            mySlideshowContainer.push(document.getElementById(`mySlideshowContainer-${index}`));
            slideshowOuterContainer.push(document.getElementById(`slideshowOuterContainer-${index}`));
            slideshowContainer.push(document.getElementById(`slideshowContainer-${index}`));
            progressBarContainer.push(document.getElementById(`progressBarContainer-${index}`));
            coverPhotoContainer.push(document.getElementById(`coverPhotoContainer-${index}`));
            photoOverlay.push(document.getElementById(`photoOverlay-${index}`));

            // Slide containers for each slideshow (contains three slides per slideshow)
            slideContainers.push([
                document.getElementById(`slide1-${index}`),
                document.getElementById(`slide2-${index}`),
                document.getElementById(`slide3-${index}`)
            ]);

            toggleNavigationButton.push(document.getElementById(`toggleNavigationButton-${index}`));
            settingsButton.push(document.getElementById(`settingsButton-${index}`));
            previousPhoto.push(document.getElementById(`previousPhoto-${index}`));
            toggleSlideshowButton.push(document.getElementById(`toggleSlideshowButton-${index}`));
            nextPhoto.push(document.getElementById(`nextPhoto-${index}`));
            fullscreenButton.push(document.getElementById(`fullscreenButton-${index}`));
            enterFullscreenIcon.push(document.getElementById(`enterFullscreenIcon-${index}`));
            exitFullscreenIcon.push(document.getElementById(`exitFullscreenIcon-${index}`));
            playIcon.push(document.getElementById(`playIcon-${index}`));
            pauseIcon.push(document.getElementById(`pauseIcon-${index}`));
            toggleTooltip.push(document.getElementById(`toggleTooltip-${index}`));
            qualitySliderElement.push(document.getElementById(`qualitySliderElement-${index}`));
            qualityValueElement.push(document.getElementById(`qualityValueElement-${index}`));
            speedSliderElement.push(document.getElementById(`speedSliderElement-${index}`));
            speedValueElement.push(document.getElementById(`speedValueElement-${index}`));
            navigationControl.push(document.getElementById(`navigationControl-${index}`));
            sliderContainer.push(document.getElementById(`sliderContainer-${index}`));
            autoQualityCheckbox.push(document.getElementById(`autoQualityCheckbox-${index}`));
            preloadAllButton.push(document.getElementById(`preloadAllButton-${index}`));

            
            controllButton = [
                `navigationControlButton0-${index}`,
                `navigationControlButton1-${index}`,
                `navigationControlButton2-${index}`,
                `navigationControlButton3-${index}`,
                `navigationControlButton4-${index}`
            ].map(id => document.getElementById(id));

            navigationControlButtons.push(controllButton);
  
            descriptionStyle = [
                `descriptionControllStyle0-${index}`,
                `descriptionControllStyle1-${index}`,
                `descriptionControllStyle2-${index}`
            ].map(id => document.getElementById(id));

            descriptionControlStyle.push(descriptionStyle);
        });
    }


/*######### Onresize functions  #########*/

    /**
     * @brief   Adjusts the quality of the slideshow based on container size when autoQualityCheckbox is selected.
     *
     * @details This function checks if the auto-quality checkbox is selected, and if so, it dynamically adjusts the font size, 
     *          padding, and image size based on the current dimensions of the slideshow container. It also updates the 
     *          quality slider based on the container's width and applies the appropriate color to the slider.
     *
     * @param   index  The index of the active slideshow to adjust the quality settings for.
     *
     * @return  None.
     */
    function autoSetQuality(index) {
        if (autoQualityCheckbox[index].checked) {
            // Get the width of the slideshow container in pixels
            containerWidth = slideshowContainer[index].offsetWidth; // Detects the width in pixels
            containerHeight = slideshowContainer[index].offsetHeight; // Detects the height in pixels

            // Dynamically adjust font size based on container width
            const fontSize = Math.max(containerWidth / 40, 12); // Font size is containerWidth/10 but caps at 6em

            // Dynamically adjust padding with a lower limit
            const padding = Math.max(containerWidth / 60, 8); // Padding based on container width, but minimum 8px

            // Apply font size to text elements
            const textElements = slideshowContainer[index].querySelectorAll('.text, .uppertext');
            if (textElements.length > 0) {
                textElements.forEach(textElement => {
                    textElement.style.fontSize = `${fontSize}px`; // Set font-size to the calculated value
                    textElement.style.padding = `${padding}px`; // Set padding to the calculated value
                });
            }

            // Assign the bigger value to a third variable
            const containerSize = Math.max(containerWidth, containerHeight); // Determine the larger value

            // Update size of images according container size
            slideshows[index].shuffledImages.forEach(img => {
                img.src = img.src.replace(/\/s\d+\/|\/w\d+-h\d+\//, `/s${containerSize}/`);
            });

            // Update the quality slider value based on the container width
            qualitySliderElement[index].value = Math.ceil(containerWidth / 400);
            qualityValueElement[index].textContent = Math.ceil(containerWidth / 400);
        }
        updateSliderColor(index);
    }


    /**
     * @brief   Updates the color and state of the quality slider based on the container size and auto-quality setting.
     *
     * @details This function checks whether the auto-quality checkbox is selected. If it is, the quality slider is disabled 
     *          and its color is set to gray. If not, the slider is enabled, and its color is updated based on a comparison 
     *          of the container's size and the slideshow's quality value. If the quality value is less than the container size, 
     *          the slider color is set to green; if greater, it is set to red; otherwise, it is reset to the default color.
     *
     * @param   index  The index of the slideshow to update.
     */
     function updateSliderColor(index) {
        if (autoQualityCheckbox[index].checked) {
            qualitySliderElement[index].disabled = true;  // Disable the slider
            qualitySliderElement[index].style.accentColor = 'gray';
        }
        else {
            qualitySliderElement[index].disabled = false;  // Enable the slider when unchecked

            // Get the width of the slideshow container in pixels
            containerWidth = slideshowContainer[index].offsetWidth; // Detects the width in pixels
            containerHeight = slideshowContainer[index].offsetHeight; // Detects the height in pixels

            // Assign the bigger value to a third variable
            const containerSize = Math.max(containerWidth, containerHeight); // Determine the larger value

            const comparisonValue = slideshows[index].qualityValue * 400;

            if (comparisonValue < containerSize) {
                qualitySliderElement[index].style.accentColor = 'green';  // Set to blue if comparisonValue < containerSize
            } else if (comparisonValue > containerSize) {
                qualitySliderElement[index].style.accentColor = 'red';   // Set to red if comparisonValue > containerSize
            } else {
                qualitySliderElement[index].style.accentColor = '';      // Reset to default if none of the conditions match
            }    
        }
    }


/*######### Onload functions  #########*/

    /**
     * @brief   Fetches and processes data for a slideshow.
     *
     * @details Constructs a blog feed URL based on the slideshow title or post ID 
     *          and retrieves image data using a fetch request. The function handles 
     *          special cases like "All pictures" (recursive loading) and processes 
     *          entries to populate the slideshow's image buffer. Updates the UI with 
     *          built slides or logs errors in case of failures.
     *
     * @param   index Index of the slideshow to fetch data for.
     */
    function fetchData(index) {
        var feedUrl;
        // const postId = getPostIdFromAnchor();
        
        // Determine the feed URL based on the slideshow title
        if (slideshowTitles[index] === "All pictures") {
            feedUrl = `${blogUrl}feeds/posts/default?start-index=${slideshows[index].startIndex}&max-results=${slideshows[index].maxResults}&alt=json`;
        } else if (slideshowTitles[index] === "Make post slideshow" || slideshowTitles[index] === "Make trip slideshow") {
            feedUrl = `${blogUrl}/feeds/posts/default/${postId}?alt=json`; // Get by postID
        } else {
            feedUrl = `${blogUrl}/feeds/posts/default?q=${encodeURIComponent(slideshowTitles[index])}&alt=json`;
        }
        // console.log("feedUrl:",feedUrl)

        const proxiedUrl = `https://corsproxy.io/?${feedUrl}`;

        // Fetch the data from the constructed feed URL
        fetch(proxiedUrl)
            .then(response => response.json())
            .then(async (data) => {
                // The entries are in data.entry, if retrieving data by postId
                let entries = data.entry;

                if (slideshowTitles[index] !== "Make post slideshow" && slideshowTitles[index] !== "Make trip slideshow") {
                    entries = data.feed.entry;
                }

                // If there's just one entry, wrap it into an array to handle it uniformly
                if (entries && !Array.isArray(entries)) {
                    entries = [entries]; // Convert single entry into an array
                }

                // Process "All pictures" scenario
                if (slideshowTitles[index] === "All pictures") {
                    if (!entries || entries.length === 0) {
                        console.log('Fetched all', slideshows[index].imageBuffer.length, 'images from blog');

                        slideshows[index].shuffledImages = shuffleArray(slideshows[index].imageBuffer.slice(), index);
                        buildSlides(index);
                        return;
                    }
                }

                // Set the slideshow quality for the current index
                setSlideshowQuality(index);

                // Process each entry
                for (let entry of entries) {
                    if (slideshowTitles[index] !== "Make trip slideshow") {
                        // Process the main entry if it's not "Make trip slideshow"
                        processEntry(index, entry);
                    } else if (slideshowTitles[index] === "Make trip slideshow") {
                        if (entry.content && entry.content.$t) {
                            const content = entry.content.$t; // HTML content of the entry
                            const parser = new DOMParser();
                            const htmlDoc = parser.parseFromString(content, 'text/html');
                            const postTitle = entry.title?.$t || "Untitled Post"; // Ensure a valid post title
                            const captions = getCaptions(htmlDoc);

                            // Parse <img> elements
                            const images = [...htmlDoc.querySelectorAll('img')]
                            .slice(1) // Exclude the first <img> element
                            .map((img, idx) => ({
                                type: 'img',
                                src: img.getAttribute('src'),
                                caption: captions[idx + 1] || '', // Shift index to match remaining images
                                position: htmlDoc.body.innerHTML.indexOf(img.outerHTML), // Get the position of the <img> in the content
                                dataSkip: img.getAttribute('data-skip') || "3" // Default value if missing
                            }));

                            // Get saved slider value
                            const PhotosRange = localStorage.getItem('photosSliderValue') || initPhotos; // Default value if not set

                            // Filter images based on `data-skip`, but keep SVGs
                            const filteredImages = images.filter(image => {
                                const src = image.src || "";
                                
                                // Always keep SVG-created images
                                if (src.startsWith("data:image/svg+xml")) {
                                    return true;
                                }

                                let dataSkip = image.dataSkip.toLowerCase();

                                // Replace text-based `data-skip` values with numeric equivalents
                                dataSkip = dataSkip.replace(/best/g, "0").replace(/cover/g, "-1").replace(/peak/g, "-2");

                                // Split into array
                                const dataSkipValues = dataSkip.split(";");

                                return dataSkipValues.some(value => {
                                    if (!isNaN(value)) {
                                        const numericValue = parseFloat(value);

                                        // Exclude if the only tag is `-2` (peak)
                                        if (numericValue === -2 && dataSkipValues.length === 1) {
                                            return false;
                                        }

                                        return numericValue <= PhotosRange;
                                    }
                                    return false;
                                });
                            });

                            // Parse <script> elements containing post IDs
                            const scriptMatches = content.match(/<script>[\s\S]*?var\s+postID\d+\s*=\s*'([^']+)';[\s\S]*?<\/script>/g);
                            const scripts = scriptMatches
                                ? scriptMatches.map(script => {
                                      const match = script.match(/var\s+postID\d+\s*=\s*'([^']+)'/);
                                      return match
                                          ? {
                                                type: 'script',
                                                postId: match[1],
                                                scriptContent: script,
                                                position: htmlDoc.body.innerHTML.indexOf(script) // Get the position of the <script> in the content
                                            }
                                          : null;
                                  }).filter(Boolean)
                                : [];

                            // Combine filtered images and scripts into a single array
                            const mixElements = [...filteredImages, ...scripts];

                            // Ensure the combined array is sorted by their position in the original content
                            mixElements.sort((a, b) => a.position - b.position);

                            // Log the sorted array, just for debug
                            // console.log(`Mixed elements:`, mixElements);

                            // Process each element based on its type
                            for (const element of mixElements) {
                                if (element.type === 'img') {
                                    slideshows[index].imageBuffer.push({
                                        src: element.src,
                                        caption: element.caption,
                                        title: postTitle, // Ensure the correct title is passed
                                    });
                                } else if (element.type === 'script') {
                                    const additionalPostId = element.postId;
                                    const additionalPostUrl = `${blogUrl}/feeds/posts/default/${additionalPostId}?alt=json`;
                                    const proxiedUrl = `https://corsproxy.io/?${additionalPostUrl}`;

                                    try {
                                        const additionalPostResponse = await fetch(proxiedUrl);

                                        if (!additionalPostResponse.ok) {
                                            console.error(`Failed to fetch additional post with ID ${additionalPostId}: HTTP ${additionalPostResponse.status}`);
                                            continue;
                                        }

                                        const additionalPostData = await additionalPostResponse.json();
                                        let additionalEntries = additionalPostData.entry;

                                        if (additionalEntries && !Array.isArray(additionalEntries)) {
                                            additionalEntries = [additionalEntries];
                                        }

                                        // Ensure correct title extraction from additional post
                                        const additionalPostTitle = additionalPostData.entry?.title?.$t || `Post ID: ${additionalPostId}`;

                                        // Process each additional entry
                                        additionalEntries.forEach(additionalEntry => {
                                            processEntry(index, additionalEntry);
                                            // console.log(`Adding images from additional entry with post ID: ${additionalPostId}`);
                                            console.log(`Adding images from additional entry with title: ${additionalPostTitle}`);
                                        });
                                    } catch (err) {
                                        console.error(`Error fetching additional post with ID ${additionalPostId}:`, err);
                                    }
                                }
                            }
                        } else {
                            console.warn(`Entry content is missing or undefined for index: ${index}`);
                        }
                    }
                }

                // Handle non-"All pictures" cases
                if (slideshowTitles[index] !== "All pictures") {
                    if (slideshowTitles[index] === "Make post slideshow" || slideshowTitles[index] === "Make trip slideshow") {
                        console.log('Fetched', slideshows[index].imageBuffer.length, 'images for title:', postTitle);
                    } else {
                        console.log('Fetched', slideshows[index].imageBuffer.length, 'images for title:', slideshowTitles[index]);
                    }

                    slideshows[index].shuffledImages = shuffleArray(slideshows[index].imageBuffer.slice(), index);
                    buildSlides(index);
                }

                // Recursively fetch more data for "All pictures"
                if (slideshowTitles[index] === "All pictures") {
                    slideshows[index].startIndex += slideshows[index].maxResults;
                    fetchData(index); // Fetch the next batch of pictures
                }

            })
            .catch(error => {
                console.error('Error fetching data:', error);
                console.error('Error: Possible typo in the post title. Please check for any mistakes.');

                // In case of an error, hide the current slideshow container
                const wrapperDiv = document.getElementById(`slideShow-${index}`);
                if (wrapperDiv) {
                    wrapperDiv.style.display = 'none'; // Hide the slideshow div
                }
            });
    }


    /**
     * @brief   Extracts the post ID from the anchor tag.
     *
     * @details This function searches for an anchor (`<a>`) element with a `name` attribute in the document and 
     *          retrieves the value of the `name` attribute, which is assumed to be the post ID. If the anchor 
     *          tag is found, the post ID is returned; otherwise, `null` is returned.
     *
     * @return  The post ID extracted from the `name` attribute of the anchor tag, or `null` if no anchor is found.
     */
    function getPostIdFromAnchor() {
        const anchor = document.querySelector('a[name]');
        if (anchor) {
            return anchor.getAttribute('name'); // Get the 'name' attribute value (the post ID)
        }
        return null;
    }


    /**
     * @brief   Shuffles an array of images or modifies the array based on slideshow type.
     *
     * @details This function shuffles an array of images using the Fisher-Yates algorithm if the slideshow is of type "All pictures". 
     *          For other slideshow types, it sets the first element of the array to a predefined image (`endImage`) and removes the 
     *          cover photo from the first index.
     *
     * @param   array  The array to be shuffled or modified.
     * @param   index  The index of the slideshow, used to determine the slideshow type.
     *
     * @return  Returns the shuffled or modified array.
     */
    function shuffleArray(array, index) {
        if (slideshowTitles[index] === "All pictures") {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        } else {
            // Set endImage as last element
            array.unshift(endImage); // Append a new image at the start
        }
        return array;
    }
    

    /**
     * @brief   Builds and displays slides for a slideshow.
     *
     * @details Initializes the slideshow by setting up slides, enabling navigation 
     *          buttons, and making the overlay clickable for slideshow control. 
     *          Marks the slideshow as ready for interaction.
     *
     * @param   index Index of the slideshow to build and display.
     */
    function buildSlides(index) {

        // Initialize all slides
        initializeSlides(index);

        // Unhide buttons after initialization of slideshow
        toggleNavigationButton[index].style.display = 'block'; // Show navigation bar
        toggleNavigation(index);

        // Now keylisteners can be initialized
        slideshows[index].isSlideshowReady = true;

        // Enable clickable overlay for slideshow controll
        const overlay = document.getElementById(`overlayContainer-${index}`);
        if (overlay) {
            overlay.style.height = '100%'; // Make overlay clickable
        }
        
        //showSlides(index); // Start the slideshow initially
    }


    /**
     * @brief   Initializes slides by preloading images and setting their content.
     *
     * @details Iterates through the slide containers of the specified slideshow index, 
     *          preloads images, and updates image sources, captions, and related content 
     *          based on the shuffled image data.
     *
     * @param   index Index of the slideshow whose slides are to be initialized.
     */
    function initializeSlides(index) {
        for (let i = 0; i < slideContainers[index].length; i++) {
            const imageObj = slideshows[index].shuffledImages[i];

            // Check if the image exists and has a valid src before using it
            if (imageObj && imageObj.src) {
                // Preload next/prev images
                preloadImage(imageObj.src);

                const imgElement = slideContainers[index][i].querySelector('img');
                imgElement.src = imageObj.src;

                // Set captions
                slideContainers[index][i].querySelector('.text').textContent = imageObj.caption || '';
                slideContainers[index][i].querySelector('.uppertext').textContent = ``;
            }
        }
    }



    // /**
    //  * @brief   Preloads an image asynchronously.
    //  *
    //  * @details Creates a new `Image` object, sets its source to the provided URL, and 
    //  *          resolves the promise when the image is successfully loaded. Rejects the 
    //  *          promise if there is an error during loading.
    //  *
    //  * @param   src URL of the image to be preloaded.
    //  *
    //  * @return  A Promise that resolves with the loaded `Image` object or rejects if loading fails.
    //  */
    // function preloadImage(src) {
    //     return new Promise((resolve, reject) => {
    //         const img = new Image();
    //         img.src = src;
    //         img.onload = resolve;
    //         img.onerror = reject;
    //     });
    // }


    /**
     * @brief   Preloads an image and caches it, ensuring efficient memory usage.
     *
     * @details This function attempts to load an image asynchronously and stores it in a cache
     *          if successfully loaded. The cache uses an approximate size-based limit to manage
     *          memory usage. If the image is already in the cache, it returns the cached version
     *          directly. The function calculates the image size based on its dimensions and 
     *          stores it along with the image in the cache.
     *
     * @param   src The URL of the image to be preloaded.
     *
     * @return  A Promise that resolves with the loaded `Image` object, or rejects if loading fails.
     *
     * @note    The cache calculates the size as width × height × 4 bytes (RGBA), providing a rough
     *          estimate of memory usage. This ensures the cache remains within acceptable limits
     *          for performance and memory efficiency.
     */
    async function preloadImage(src) {
        if (imageCache.has(src)) return imageCache.get(src); // Return cached image if available

        const loadPromise = new Promise((resolve, reject) => {
            const img = new Image();

            const onLoad = () => {
            const width = img.naturalWidth;
            const height = img.naturalHeight;

            if (!width || !height || isNaN(width) || isNaN(height)) {
                console.warn(`Skipping cache for ${src}: invalid image dimensions.`);
                resolve(img);
                cleanup();
                return;
            }

            const size = width * height * 4; // Estimate: 4 bytes per pixel
            imageCache.set(src, img, size);
            resolve(img);
            cleanup();
        };

            const onError = () => {
                reject(new Error(`Failed to load: ${src}`));
                cleanup();
            };

            const cleanup = () => {
                img.removeEventListener('load', onLoad);
                img.removeEventListener('error', onError);
            };

            img.addEventListener('load', onLoad);
            img.addEventListener('error', onError);
            img.src = src;
        });

        return loadPromise;
    }


    /**
     * @brief   Toggles the navigation layout and visibility in a slideshow.
     *
     * @details Changes the navigation control layout or visibility based on the click count:
     *          - First click: Switches the layout to vertical.
     *          - Second click: Hides all navigation buttons except the toggle button and changes background color.
     *          - Third click: Resets to the original horizontal layout, restores button visibility, and resets the click count.
     *
     * @param   index Index of the slideshow to toggle navigation for.
     */
    function toggleNavigation(index) {
        if (slideshows[index].clickCount === 0) {
            // First click: Change layout from horizontal to vertical
            navigationControl[index].classList.add('vertical');
        } else if (slideshows[index].clickCount === 1) {
            // Second click: Hide all buttons except toggle button
            slideshows[index].previousBackgroundColor = navigationControl[index].style.backgroundColor;
            navigationControl[index].style.backgroundColor = 'rgba(255, 255, 255, 0.15)';
            navigationControlButtons[index].forEach(button => button && (button.style.display = 'none'));
        } else {
            // Third click: Reset everything (show all buttons and set layout to horizontal)
            navigationControl[index].style.backgroundColor = slideshows[index].previousBackgroundColor;
            navigationControl[index].classList.remove('vertical');
            navigationControlButtons[index].forEach(button => button && (button.style.display = 'inline-block'));
            slideshows[index].clickCount = -1;  // Reset counter
        }
        slideshows[index].clickCount++;
    }


    /**
     * @brief   Toggles the visibility and appearance of image descriptions in a slideshow.
     *
     * @details Cycles through three interactive states based on the number of times the toggle button is clicked:
     *          1. **First click:** Adds a semi-transparent dark background to all image descriptions to improve readability.
     *          2. **Second click:** Removes the background color, making it fully transparent.
     *          3. **Third click:** Hides all image descriptions and resets the click count to restart the cycle.
     *
     *          This function selects the description group corresponding to the provided slideshow index 
     *          and dynamically updates the styles of descriptions according to the current state.
     *
     * @param   index Index of the slideshow for which to toggle the descriptions.
     */
    function toggleDescription(index) {
        // Retrieve the specific description group for the current slideshow index
        const descriptions = descriptionControlStyle[index];

        if (slideshows[index].descriptionClickCount === 0) {
            // First click: Set semi-transparent dark background for all descriptions
            descriptions.forEach(description => {
                description.style.backgroundColor = 'rgba(0, 0, 0, 0.55)';
                description.style.display = ''; // Ensure the description is visible
            });
        } else if (slideshows[index].descriptionClickCount === 1) {
            // Second click: Make the background of all descriptions fully transparent
            descriptions.forEach(description => {
                description.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            });
        } else {
            // Third click: Hide all descriptions and reset the click count
            descriptions.forEach(description => {
                description.style.display = 'none'; // Hide the description
            });
            slideshows[index].descriptionClickCount = -1; // Reset the click counter
        }
        // Increment the click count
        slideshows[index].descriptionClickCount++;
    }


    /**
     * @brief   Sets the quality of the slideshow based on the container width.
     *
     * @details This function calculates the quality value of the slideshow based on the width of the outer container. 
     *          It sets the value of the quality slider and updates the displayed quality value accordingly. 
     *          Additionally, it calls a function to update the color of the slider based on the new value.
     *
     * @param   index  The index of the slideshow, used to identify the corresponding elements.
     */
    function setSlideshowQuality(index) {                 
        // Ensure the element exists
        if (!slideshowContainer[index]) return; 

        // Get the current width of the outer container
        const containerWidth = slideshowContainer[index].offsetWidth;

        // Update the quality slider value based on the container width
        qualitySliderElement[index].value = Math.ceil(containerWidth / 400);
        qualityValueElement[index].textContent = Math.ceil(containerWidth / 400);

        // Call the function to update the slider color
        updateSliderColor(index);
    }


    /**
     * @brief   Processes a blog entry and extracts images and captions for the slideshow.
     *
     * @details This function parses the content of a blog entry, extracts image sources and captions, and stores them 
     *          in the `imageBuffer`. It also adjusts the image sizes based on the dimensions of the slideshow container.
     *          Images with a `data-skip` attribute greater than the current photo slider value are skipped. The images are 
     *          resized according to the larger dimension of the container (width or height) and added to the slideshow buffer 
     *          along with the associated caption and post title.
     *
     * @param   index   The index of the slideshow to process.
     * @param   entry   The blog entry object containing content and metadata.
     */
    function processEntry(index, entry) {
        const content = entry.content.$t;
        const parser = new DOMParser();
        const htmlDoc = parser.parseFromString(content, 'text/html');
        const images = htmlDoc.getElementsByTagName('img');
        const postTitle = entry.title.$t;
        const captions = getCaptions(htmlDoc);

        // Get the width and height of the slideshow container in pixels
        const containerWidth = slideshowContainer[index].offsetWidth; // Detects the width in pixels
        const containerHeight = slideshowContainer[index].offsetHeight; // Detects the height in pixels

        // Assign the bigger value to determine size
        const containerSize = Math.max(containerWidth, containerHeight); // Determine the larger value

        // Loop through the images and process their `data-skip` attribute
        for (let i = 1; i < images.length; i++) { // Start with 1 - do not include cover photo
            // Check if the image has a data-skip attribute with a value greater than value saved in initPhotos
            const PhotosRange = localStorage.getItem('photosSliderValue') || initPhotos; // Default value if not set
            // Extract the `data-skip` attribute content
            let dataSkip = images[i].getAttribute('data-skip');

            // Assign a default value to `data-skip` if undefined or "NA"
            if (dataSkip === "NA" || dataSkip === null || dataSkip === undefined) {
                dataSkip = "3"; // Assign a default value
            }

            // Replace "best" with "0" in the `data-skip` values
            dataSkip = dataSkip.replace(/best/g, "0");

            // Replace "cover" with "-1" in the `data-skip` values
            dataSkip = dataSkip.replace(/cover/g, "-1");

            // Replace "peak" with "-2" in the `data-skip` values
            dataSkip = dataSkip.replace(/peak/g, "-2");

            // Split `data-skip` values by semicolon
            const dataSkipValues = dataSkip.split(";");

            // Check if any value in `data-skip` matches or is within the PhotosRange
            const isWithinRange = dataSkipValues.some(value => {
                if (!isNaN(value)) {
                    const numericValue = parseFloat(value); // Parse each value to a number

                    // Exclude -2 (peaks) only if it is the ONLY value in dataSkipValues
                    if (numericValue === -2) {
                        return false;
                    }

                    // For other ranges, check if the value is within the range
                    return numericValue <= PhotosRange;
                }
                return false; // Non-numeric values are ignored
            });

            // Perform the desired action based on the range check
            if (isWithinRange) {
                // Process and add the image if data-skip is within range
                let imgSrc = images[i].getAttribute('src').replace(/\/s\d+\/|\/w\d+-h\d+\//, `/s${containerSize}/`);
                    const caption = captions[i] || '';
                slideshows[index].imageBuffer.push({ src: imgSrc, caption, title: postTitle });
            }
        }        
    }


    /**
      * @brief   Extracts captions for images from the HTML document.
      *
      * @details This function processes an HTML document, finds all images, and attempts to associate captions with 
      *          each image. Captions are stored in elements with the class `tr-caption`, and the function matches each
      *          caption to the corresponding image based on their order in the document. If no caption is found for an 
      *          image, an empty string is assigned. The function returns an array of captions corresponding to the images.
      *
      * @param   htmlDoc   The HTML document object to extract captions from.
      *
      * @return  An array of captions, where each element corresponds to a caption for an image.
      */
    function getCaptions(htmlDoc) {
        const images = htmlDoc.getElementsByTagName('img');
        const captionElements = htmlDoc.getElementsByClassName('tr-caption');
        const captions = [];
        let captionIndex = 0;

        for (let i = 0; i < images.length; i++) {
            let caption = '';
            while (captionIndex < captionElements.length) {
                const currentCaptionElement = captionElements[captionIndex];
                const nextImageElement = images[i + 1];
                if (!nextImageElement || currentCaptionElement.compareDocumentPosition(nextImageElement) & Node.DOCUMENT_POSITION_FOLLOWING) {
                    caption = currentCaptionElement.textContent.trim();
                    captionIndex++;
                    break;
                }
                break;
            }
            captions.push(caption);
        }
        return captions;
    }


    /**
      * @brief   Adjusts the slideshow speed based on slider input.
      *
      * @details This function retrieves the value from a speed slider input element, converts it from seconds to milliseconds, 
      *          and updates the slideshow speed accordingly. The speed value is also displayed to the user.
      *
      * @param   index  The index of the slideshow for which the speed needs to be adjusted.
      *
      * @return  None.
      */
    function updateSlideshowSpeed(index) {
        const speedInSeconds = speedSliderElement[index].value;
        slideshows[index].slideshowSpeed = speedInSeconds * 1000; // Convert to milliseconds
        speedValueElement[index].textContent = speedInSeconds; // Update the speed value display
    }

    
    /**
      * @brief   Retries initializing functions after DOMContentLoaded and slideshow setup.
      *
      * @details This function checks if the slideshow is ready. If so, it initializes the necessary event listeners 
      *          and starts observing the wrappers. If the slideshow is not yet initialized, it retries the process after a short delay.
      *
      * @param   index  The index of the slideshow to check and initialize.
      *
      * @return  None.
      */
    function checkAndInitialize(index) {
        if (slideshows[index].isSlideshowReady) { // Check if the slideshow is ready and DOM is loaded
            initializeKeyboardListeners(index); // Set up keyboard listeners
            observeVisibleWrappers(); // Start observing wrappers
        } else {
            // Retry after a short delay if the slideshow is not yet ready
            console.log("Slideshow not fully initialized yet. Retrying...");
            setTimeout(() => checkAndInitialize(index), 500); // Retry after 500ms
        }
    }


    /**
      * @brief   Initializes keyboard listeners for slideshow control.
      *
      * @details This function sets up event listeners for keydown events to control various aspects of the slideshow.
      *          Each key press triggers specific actions, such as navigating through slides, toggling slideshow play/pause, 
      *          toggling fullscreen, changing quality settings, and more.
      *
      * @param   index  The index of the active slideshow to control with keyboard inputs.
      *
      * @return  None.
      */
    function initializeKeyboardListeners(index) {
        document.addEventListener('keydown', ({ key }) => {
            // Determine which slideshow to control
            const index = activeFullscreenIndex !== null ? activeFullscreenIndex : currentSlideshowIndex;

            const actions = {
                ArrowRight: () => enqueueManualSlide(index, 1), // Next photo
                ArrowLeft: () => enqueueManualSlide(index, -1), // Previous photo
                s: () => (slideshows[index].isSlideshowRunning
                    ? pauseSlideshow
                    : resumeSlideshow)(index, SLIDESHOW_VISIBLE), // Toggle slideshow (start/pause)
                n: () => toggleNavigation(index), // Toggle navigation
                u: () => toggleDescription(index), // Toggle image description style
                f: () => toggleFullscreen(index), // Toggle fullscreen
                q: () => {
                    autoQualityCheckbox[index].checked = !autoQualityCheckbox[index].checked;
                    autoSetQuality(index);
                }, // Enable/disable auto quality
                p: () => preloadAllImages(index), // Preload all images
                t: () => toggleSlideshowOrImageVisibility(index), // Toggle slideshow or image visibility
                b: () => toggleProgressBarVisibility(index, 0, 'key'), // Toggle progressBar visibility
                e: () => {slideshows[index].errorFlag = !slideshows[index].errorFlag; console.log(`Error flag is now ${slideshows[index].errorFlag ? 'ON' : 'OFF'}`); }, // Toggle error flag
                '+': () => { speedSliderElement[index].value = Math.min(Number(speedSliderElement[index].value) + stepSpeed, maxSpeed); updateSlideshowSpeed(index); },
                '-': () => { speedSliderElement[index].value = Math.max(Number(speedSliderElement[index].value) - stepSpeed, minSpeed); updateSlideshowSpeed(index); },

                // Number controls
                '5': () => (slideshows[index].isSlideshowRunning
                    ? pauseSlideshow
                    : resumeSlideshow)(index, SLIDESHOW_VISIBLE), // Toggle slideshow (start/pause)
                '2': () => toggleNavigation(index), // Toggle navigation
                '7': () => toggleDescription(index), // Toggle image description style
                '1': () => toggleFullscreen(index), // Toggle fullscreen
                '9': () => {
                    autoQualityCheckbox[index].checked = !autoQualityCheckbox[index].checked;
                    autoSetQuality(index);
                }, // Enable/disable auto quality
                '0': () => preloadAllImages(index), // Preload all images
                t: () => toggleSlideshowOrImageVisibility(index), // Toggle slideshow or image visibility
                '3': () => toggleProgressBarVisibility(index, 0, 'key'), // Toggle progressBar visibility
                '8': () => {slideshows[index].errorFlag = !slideshows[index].errorFlag; console.log(`Error flag is now ${slideshows[index].errorFlag ? 'ON' : 'OFF'}`); }, // Toggle error flag
                '4': () => { speedSliderElement[index].value = Math.min(Number(speedSliderElement[index].value) + stepSpeed, maxSpeed); updateSlideshowSpeed(index); },
                '6': () => { speedSliderElement[index].value = Math.max(Number(speedSliderElement[index].value) - stepSpeed, minSpeed); updateSlideshowSpeed(index); }
              };

            actions[key]?.(); // Execute action if the key is in the actions map
        });
    }

    /**
    * @brief   Toggles the visibility and height of the progress bar for a slideshow.
    *
    * @details This function adjusts the height of the progress bar based on the specified mode. 
    *          In 'hover' mode, it sets the progress bar to a specified height if it is initially hidden. 
    *          In 'key' mode, it toggles the height of the progress bar between '0px' (hidden) and '5px' (visible). 
    *          The function ensures the progress bar element exists before making any changes and logs an error if not found.
    *
    * @param   index  The index of the slideshow whose progress bar visibility needs to be toggled.
    * @param   height The height to set the progress bar to when it is shown (e.g., '5px').
    * @param   mode   The mode of operation, either 'hover' or 'key'. In 'hover', the height is set when hovered. 
    *                 In 'key', it toggles the height between '0px' and '5px'.
    *
    * @return  None.
    */
    function toggleProgressBarVisibility(index, height, mode) {
        const progressBar = document.getElementById(`progressBar-${index}`);
        if (!progressBar) {
            console.error(`Progress container for slideshow ${index} not found.`);
            return;
        }
        // Manage height and state of progress bar
        if ((mode == 'hover') && (slideshows[index].progressBarHeightKey == '0px')) {
            progressBar.style.height = height;
        } else if (mode == 'key') {
            progressBar.style.height = progressBar.style.height === '0px' ? 
                (slideshows[index].progressBarHeightKey = '5px') : 
                (slideshows[index].progressBarHeightKey = '0px');
        }
    }


    /**
    * @brief   Toggles the visibility of slideshows and images.
    *
    * @details This function checks the current visibility of slideshows and switches between showing slideshows
    *          or images based on the current visibility state. It also updates the button's SVG and text to indicate
    *          the current mode (either "Presentation" mode with slideshows or "Image" mode with images). The function
    *          will also pause the slideshow and hide all slideshows when switching to image view, and resume the slideshow
    *          when switching back to presentation mode. The function utilizes a set of DOM elements (e.g., separators, tables)
    *          to toggle their visibility accordingly.
    *
    * @param   index  The index of the current slideshow to manage (used for pausing the slideshow).
    *
    * @return  None.
    */
    function toggleSlideshowOrImageVisibility(index) {
        const separators = document.querySelectorAll('.separator');
        const tables = document.querySelectorAll('table.tr-caption-container');

        // Update image sources to normal size
        updateImageSources(1200);

        // Flag to track if any slideshow is visible
        let isSlideshowVisible = false;

        // Iterate over all slideshows to check visibility
        mySlideshowContainer.forEach(function(slideshowDiv) {
            if (slideshowDiv.style.display === "block") {
                isSlideshowVisible = true; // Set to true if any slideshow is visible
            }
        });

        // Toggle based on whether slideshows are currently visible or not
        if (isSlideshowVisible) {
            // Pause slideshow if switch on images
            pauseSlideshow(index, SLIDESHOW_VISIBLE);

            // Hide all slideshows and show images
            mySlideshowContainer.forEach(function(slideshowDiv) {
                slideshowDiv.style.display = "none"; // Hide all slideshows
            });
            separators.forEach(function(separator) {
                separator.style.display = 'block'; // Show separators
            });
            tables.forEach(function(table) {
                table.style.display = 'table'; // Show tables
            });

            // Change SVG and button text for "Presentation" mode
            toggleButton.innerHTML = `
                <svg version="1.1" id="Icons" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 32 32" xml:space="preserve" width="80px" height="60px" fill="#000000">
                    <g id="SVGRepo_iconCarrier"> 
                        <style type="text/css"> .st0{fill:none;stroke:#000000;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;} </style> 
                        <polyline class="st0" points="25,11 27,13 25,15 "></polyline> 
                        <polyline class="st0" points="7,11 5,13 7,15 "></polyline> 
                        <path class="st0" d="M29,23H3c-1.1,0-2-0.9-2-2V5c0-1.1,0.9-2,2-2h26c1.1,0,2,0.9,2,2v16C31,22.1,30.1,23,29,23z"></path> 
                        <circle class="st0" cx="16" cy="28" r="1"></circle> 
                        <circle class="st0" cx="10" cy="28" r="1"></circle> 
                        <circle class="st0" cx="22" cy="28" r="1"></circle> 
                    </g>
                </svg>
            `;
        } else {
            // Show all slideshows and hide images
            mySlideshowContainer.forEach(function(slideshowDiv) {
                slideshowDiv.style.display = "block"; // Show all slideshows
            });
            separators.forEach(function(separator) {
                separator.style.display = 'none'; // Hide separators
            });
            tables.forEach(function(table) {
                table.style.display = 'none'; // Hide tables
            });

            // Change SVG and button text for "Image" mode
            toggleButton.innerHTML = `
                <svg fill="#000000" width="120px" height="120px" viewBox="0 0 36 36" version="1.1" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                    <g id="SVGRepo_iconCarrier"> 
                        <path fill="#000000" d="M32.12,10H3.88A1.88,1.88,0,0,0,2,11.88V30.12A1.88,1.88,0,0,0,3.88,32H32.12A1.88,1.88,0,0,0,34,30.12V11.88A1.88,1.88,0,0,0,32.12,10ZM32,30H4V12H32Z" class="clr-i-outline clr-i-outline-path-1"></path>
                        <path fill="#000000" d="M8.56,19.45a3,3,0,1,0-3-3A3,3,0,0,0,8.56,19.45Zm0-4.6A1.6,1.6,0,1,1,7,16.45,1.6,1.6,0,0,1,8.56,14.85Z" class="clr-i-outline clr-i-outline-path-2"></path>
                        <path fill="#000000" d="M7.9,28l6-6,3.18,3.18L14.26,28h2l7.46-7.46L30,26.77v-2L24.2,19a.71.71,0,0,0-1,0l-5.16,5.16L14.37,20.5a.71.71,0,0,0-1,0L5.92,28Z" class="clr-i-outline clr-i-outline-path-3"></path>
                        <path fill="#000000" d="M30.14,3h0a1,1,0,0,0-1-1h-22a1,1,0,0,0-1,1h0V4h24Z" class="clr-i-outline clr-i-outline-path-4"></path>
                        <path fill="#000000" d="M32.12,7V7a1,1,0,0,0-1-1h-26a1,1,0,0,0-1,1h0V8h28Z" class="clr-i-outline clr-i-outline-path-5"></path> 
                        <rect x="0" y="0" width="36" height="36" fill-opacity="0"></rect> 
                    </g>
                </svg>
            `;
        }
    }


    /**
     * @brief   Preloads all images for a specified slideshow.
     *
     * @details This function iterates over all shuffled images in a slideshow and preloads each image by calling 
     *          a helper function `preloadImage`. Once all images are successfully preloaded, a message is logged to 
     *          the console. If any error occurs during the preloading process, an error message is logged.
     *
     * @param   index  The index of the slideshow whose images need to be preloaded.
     *
     * @return  A Promise that resolves when all images have been preloaded or rejects if an error occurs.
     */
    function preloadAllImages(index) {
        return Promise.all(slideshows[index].shuffledImages.map(img => preloadImage(img.src)))
            .then(() => {
                console.log("All images preloaded");
                if (coverPhotoContainer[index]) {
                    // Show the overlay with the "Slike so pripravljene" message
                    photoOverlay[index].style.display = 'block';
                    photoOverlay[index].innerHTML = '<span class="connection-error">Slike so pripravljene</span>';
                    photoOverlay[index].style.color = 'white';
                    photoOverlay[index].style.zIndex = '2'; // Set the z-index to 2
                    
                    // Hide the overlay and change the message after 1 second
                    setTimeout(() => {
                        photoOverlay[index].style.display = 'none'; // Hide the overlay
                        photoOverlay[index].innerHTML = '<span class="connection-error">Ojoj, internetna povezava ne omogoča take hitrosti pri nastavljeni kvaliteti slik</span>';
                    }, 2000); // 2 second timeout
                }
            })
            .catch(error => console.error("Error preloading images:", error));
    }


    /**
     * @brief   Toggles fullscreen mode for a specific slideshow.
     *
     * @details This function checks if the document is currently in fullscreen mode. If it is, it exits fullscreen and
     *          removes the fullscreen class from all relevant slideshow containers. If it is not in fullscreen, it requests
     *          fullscreen for the specified slideshow and adds the fullscreen class. Additionally, the function toggles the 
     *          light theme for the slideshow and calls `autoSetQuality` with a slight delay.
     *
     * @param   index  The index of the slideshow that should enter or exit fullscreen mode.
     *
     * @return  None.
     */
    function toggleFullscreen(index) {
        const wrapper = document.querySelector(`#slideshowOuterContainer-${index}`);
        if (!wrapper) return;

        if (document.fullscreenElement) {
            // Exit fullscreen
            document.exitFullscreen().then(() => {
                activeFullscreenIndex = null; // Reset fullscreen index
            });
            [progressBarContainer[index], slideshowContainer[index], slideshowOuterContainer[index], mySlideshowContainer[index]].forEach(el => el.classList.remove('fullscreen')); // Remove fullscreen class
        } else {
            // Enter fullscreen
            wrapper.requestFullscreen().then(() => {
                activeFullscreenIndex = index; // Set the active fullscreen slideshow
            });
            [progressBarContainer[index], slideshowContainer[index], slideshowOuterContainer[index], mySlideshowContainer[index]].forEach(el => el.classList.add('fullscreen')); // Add fullscreen class
        }

        // Toggle light theme when exiting fullscreen
        if (document.fullscreenElement) {
            slideshowContainer[index].classList.remove('light-theme'); // Remove light theme if in fullscreen
        } else {
            slideshowContainer[index].classList.add('light-theme'); // Add light theme if not in fullscreen
        }

        setTimeout(() => autoSetQuality(index), 250); // Delay execution of autoSetQuality by 1/4 second
    }


    /**
     * @brief   Pauses the slideshow by clearing the timeout.
     *
     * @details This function stops the slideshow by clearing the timeout that controls the slide transitions. It also tracks 
     *          the state of the slideshow (whether it was running or not) before pausing. The slideshow state is updated, 
     *          and the toggle button is updated to reflect the paused state of the slideshow.
     *
     * @param   index              The index of the slideshow to be paused.
     * @param   isSlideshowHidden  A flag indicating whether the slideshow is hidden or not.
     *
     * @return  None.
     */
     function pauseSlideshow(index, isSlideshowHidden) {
        if(!isSlideshowHidden){
            // Track state
            slideshows[index].wasSlideshowRunning = slideshows[index].isSlideshowRunning;
        }
        clearTimeout(slideshows[index].slideshowTimeout);
        slideshows[index].isSlideshowRunning = false;
        updateToggleButton(index, slideshows[index].isSlideshowRunning); // Update button on pause
    }

    
    /**
     * @brief   Updates the toggle button icon and tooltip based on the slideshow state.
     *
     * @details This function changes the icon and tooltip of the toggle button based on whether the slideshow is playing or paused.
     *          If the slideshow is playing, it will display the pause icon and update the tooltip to "Ustavi" (Stop).
     *          If the slideshow is paused, it will display the play icon and update the tooltip to "Predvajaj" (Play).
     *
     * @param   index      The index of the slideshow whose toggle button needs to be updated.
     * @param   isPlaying  A boolean indicating whether the slideshow is currently playing or paused.
     *
     * @return  None.
     */
    function updateToggleButton(index, isPlaying) {
        if (isPlaying) {
            playIcon[index].style.display = "none";
            pauseIcon[index].style.display = "block";
            toggleTooltip[index].textContent = "Ustavi";
        } else {
            playIcon[index].style.display = "block";
            pauseIcon[index].style.display = "none";
            toggleTooltip[index].textContent = "Predvajaj";
        }
    }


    /**
     * @brief   Resumes the slideshow by restarting the timeout and updating the state.
     *
     * @details This function resumes the slideshow if it was previously paused. It updates the state to indicate that the slideshow
     *          is running, changes the toggle button to reflect the play state, and restarts the slideshow by calling `showSlides`.
     *          The slideshow will not resume if it was hidden and was not previously running.
     *
     * @param   index              The index of the slideshow to be resumed.
     * @param   isSlideshowHidden  A boolean indicating whether the slideshow is hidden or not.
     *
     * @return  None.
     */
    function resumeSlideshow(index, isSlideshowHidden) {       
        if(!(isSlideshowHidden && (slideshows[index].wasSlideshowRunning == false)) ) {
            slideshows[index].isSlideshowRunning = true;
            updateToggleButton(index, slideshows[index].isSlideshowRunning); // Update button on resume
            showSlides(index); // Restart the slideshow
        }
    }


    /**
     * @brief   Starts the automatic slideshow by calling the unified slide function.
     *
     * @details This function initiates the automatic sliding of images by invoking the `changeSlide` function. The slide change 
     *          is done with a direction of 1 (next slide) and without manually triggering the slide change.
     *
     * @param   index  The index of the slideshow for which the automatic slide change is triggered.
     *
     * @return  None.
     */
    async function showSlides(index) {
        changeSlide(index, 1, false);
    }


    /**
     * @brief   Changes the slide in the slideshow based on the given direction and mode.
     *
     * @details This function handles the logic for changing the slides in the slideshow. It supports both automatic 
     *          and manual slide changes. The direction determines whether the next or previous slide is shown, 
     *          and the `isManual` flag indicates whether the slide change was triggered by the user or automatically.
     *
     * @param   index      The index of the slideshow whose slide is to be changed.
     * @param   direction  The direction to change the slide (1 for next, -1 for previous). Default is 1.
     * @param   isManual   A flag indicating whether the slide change is triggered manually (true) or automatically (false). Default is false.
     *
     * @return  None.
     */
    async function changeSlide(index, direction = 1, isManual = false) {              
        // Hide the cover photo - do it once
        if (!slideshows[index].coverPhotoHidden) {
            if (coverPhotoContainer[index]) {
                // Remove the photo if it exists
                if (coverPhotoContainer[index].querySelector('img')) {
                    coverPhotoContainer[index].removeChild(coverPhotoContainer[index].querySelector('img'));
                }
                slideshows[index].coverPhotoHidden = true;

                // Prepare message for bad internet connection
                photoOverlay[index].style.display = 'none'; // Hide the overlay
                photoOverlay[index].innerHTML = '<span class="connection-error">Ojoj, internetna povezava ne omogoča take hitrosti pri nastavljeni kvaliteti slik</span>';
                photoOverlay[index].style.color = 'white';
                photoOverlay[index].style.zIndex = '2'; // Set the z-index to 2
            } else {
                console.error('Cover photo container not found.');
            }
        }

        if (slideshows[index].isSlideshowRunning){                 
            clearTimeout(slideshows[index].slideshowTimeout); // Clear the existing automatic timeout to reset it
        }

        // Immediately fade out the active slide
        slideContainers[index][slideshows[index].activeSlide].classList.remove('fade-in');
        slideContainers[index][slideshows[index].activeSlide].classList.add('fade-out'); // Quick fade-out

        // Update slideshows[index].activeSlide for the next iteration before using it
        if (direction === 1) {
            slideshows[index].activeSlide = (slideshows[index].activeSlide + 1) % 3;  // Move forward
        } else {
            slideshows[index].activeSlide = (slideshows[index].activeSlide + 2) % 3;  // Move backward
        }

        // Calculate the previous and next slide container indices
        const prevSlide = (slideshows[index].activeSlide + 2) % 3;  // Previous container (always 2 slides before active)
        const nextSlide = (slideshows[index].activeSlide + 1) % 3;  // Next container (always 1 slide after active)

        // Update the current batch index based on the direction (forward or backward)
        slideshows[index].currentBatchIndex = (slideshows[index].currentBatchIndex + direction + slideshows[index].shuffledImages.length) % slideshows[index].shuffledImages.length;

        // Calculate the previous and next image indices based on the current batch index
        const prevIndex = (slideshows[index].currentBatchIndex - 1 + slideshows[index].shuffledImages.length) % slideshows[index].shuffledImages.length;
        const nextIndex = (slideshows[index].currentBatchIndex + 1) % slideshows[index].shuffledImages.length;

        // After a quick fade-out, proceed to the next steps
        setTimeout(() => {
            // Update only the current slide container with the new image
            updateSlide(index, slideContainers[index][slideshows[index].activeSlide], slideshows[index].shuffledImages[slideshows[index].currentBatchIndex], 'current');

            // Update either the next or previous slide based on the direction of navigation
            if (direction === 1) {
                // If moving forward, update the next slide
                updateSlide(index, slideContainers[index][nextSlide], slideshows[index].shuffledImages[nextIndex], 'next');
                // Start preloading the next image in the background
                preloadThisImage(index, nextIndex);
            } else {
                // If moving backward, update the previous slide
                updateSlide(index, slideContainers[index][prevSlide], slideshows[index].shuffledImages[prevIndex], 'prev');
                // Start preloading the previous image in the background
                preloadThisImage(index, prevIndex);
            }

            // Adjust the slideshow container's height based on the current active slide
            //adjustSlideshowHeight(slideContainers[index][slideshows[index].activeSlide]);

            // After resizing the window, fade in the next slide slowly
            slideContainers[index][slideshows[index].activeSlide].classList.remove('fade-out');
            slideContainers[index][slideshows[index].activeSlide].classList.add('fade-in');

        }, 10); // Delay for fade-out (matches the quick fade-out time)
        if (slideshows[index].isSlideshowRunning){ 
            // Reset the slideshow timeout to continue auto-sliding after manual action
            slideshows[index].slideshowTimeout = setTimeout(() => attemptChangeSlide(index), slideshows[index].slideshowSpeed);
        }

        updateProgressBar(index); // Update the progress bar after changing the slide
    }


    /**
     * @brief   Updates the slide in a specific container with a new image and its details.
     *
     * @details This function asynchronously loads a new image and updates the slide content, 
     *          including the image source, caption, and upper text. It also handles errors by retrying 
     *          to load the next or previous image if the current one fails to load. 
     *          If the slideshow reaches the end, the slideshow is paused.
     *
     * @param   index          The index of the slideshow being updated.
     * @param   slideContainer The container element of the current slide where the image and text are displayed.
     * @param   entry          The image entry containing the image source, caption, and title to be displayed.
     * @param   direction      The direction ('next' or 'prev') to determine if the next or previous image should be loaded.
     *
     * @return  None.
     */
    async function updateSlide(index, slideContainer, entry, direction) {
        const imgElement = slideContainer.querySelector('img');
        const captionElement = slideContainer.querySelector('.text');
        const upperTextElement = slideContainer.querySelector('.uppertext');

        // Stop slideshow if the flag is set
        if (slideshows[index].pauseSlideshowFlag) {
            pauseSlideshow(index, SLIDESHOW_VISIBLE);
            slideshows[index].pauseSlideshowFlag = false;
        }

        try {
            // Preload the image asynchronously
            await preloadImage(entry.src);

            // Update the slide once the image is loaded
            imgElement.src = entry.src; // Set the valid image source
            captionElement.textContent = entry.caption || ''; // Set caption

            // Set upper text based on the entry title
            if (slideshowTitles[index] === "All pictures") {
                upperTextElement.textContent = entry.title || ''; // Set the title from the entry object
            } else {
                upperTextElement.textContent = ''; // Clear if not applicable
            }

            // Set flag to stop slideshow if it reaches the end
            if ((imgElement.src === endImage.src) && slideshows[index].isSlideshowRunning) {
                slideshows[index].pauseSlideshowFlag = true;
            }
        } catch (error) {
            console.warn(`Failed to load image: ${entry.src}. Attempting next/previous.`);

            // Handle image load failure and decide next step
            const nextEntry = getNextOrPreviousEntry(index, entry, direction);

            if (nextEntry) {
                // Recursively attempt to load the next/previous image
                await updateSlide(index, slideContainer, nextEntry, direction);
            } else {
                // Use placeholder if no valid entry is found
                setPlaceholderImage(imgElement, captionElement, upperTextElement);
            }
        }


    }


    /**
     * @brief   Retrieves the next or previous entry in the slideshow based on the specified direction.
     *
     * @details This function calculates the next or previous entry in the slideshow based on the provided direction 
     *          ('next' or 'prev'). It ensures that when the end or beginning of the slideshow is reached, it loops back 
     *          to the first or last entry, respectively, providing a continuous slideshow experience.
     *
     * @param   index        The index of the slideshow to which the current entry belongs.
     * @param   currentEntry The current entry (image) in the slideshow whose next or previous counterpart is needed.
     * @param   direction    The direction of the desired entry ('next' or 'prev').
     *
     * @return  The next or previous entry in the slideshow, or null if the direction is invalid.
     */
    function getNextOrPreviousEntry(index, currentEntry, direction) {
        const images = slideshows[index].shuffledImages;
        const currentIndex = images.indexOf(currentEntry);

        if (direction === 'next') {
            return images[(currentIndex + 1) % images.length];
        } else if (direction === 'prev') {
            return images[(currentIndex - 1 + images.length) % images.length];
        }
        return null;
    }


    /**
     * @brief   Sets a placeholder image and related text for an image element.
     *
     * @details This function updates the `src` of the provided image element to a default placeholder image. 
     *          It also sets default text for the caption and upper text elements, ensuring that these elements 
     *          display placeholder content when no valid image or caption is available.
     *
     * @param   imgElement      The image element where the placeholder image will be set.
     * @param   captionElement  The caption element where the placeholder caption will be displayed.
     * @param   upperTextElement The upper text element where placeholder text will be shown.
     *
     * @return  None.
     */
    function setPlaceholderImage(imgElement, captionElement, upperTextElement) {
        imgElement.src = 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgOeImsdWR0X78A0DBrMxPaz8JnOzELaQisEXya9i1FR0IJRLKxk-aqHFnA7evS4gqsbyvfKr0KuXrXTP6uZ8F10bYls4zfDU7qOgD9dG7HZBm3UJRsFc9nv4jXscecg0hbLt1V4vG8Px4hemML8-HAnkmYITUeOyP-PrIChGugMmX6UtRca6zgq1LFCIbm/s600/20230427_132541.jpg'; // Default placeholder
        captionElement.textContent = 'Ferrata degli Angeli'; // Placeholder caption
        upperTextElement.textContent = 'Tavolara'; // Placeholder upper text
    }


    /**
     * @brief   Preloads a specific image for a slideshow.
     *
     * @details This function preloads a specific image in the slideshow based on the provided indices.
     *          It utilizes the `preloadImage` function to asynchronously load the image. 
     *          Once the image is successfully loaded, the `imageIsReady` flag for the slideshow is set to true, 
     *          indicating that the image is ready to be displayed.
     *
     * @param   index      The index of the slideshow containing the image to be preloaded.
     * @param   photoIndex The index of the image within the slideshow to preload.
     *
     * @return  None.
     */
    async function preloadThisImage(index, photoIndex) {
        try {
            // Preload the specified image
            await Promise.all([
                preloadImage(slideshows[index].shuffledImages[photoIndex].src),
            ]);
            // Mark the image as ready once it is loaded
            slideshows[index].imageIsReady = true;
        } catch (err) {
            console.error("Error loading images:", err);
        }
    }


    /**
     * @brief   Updates the progress bar based on the current image index in the slideshow.
     *
     * @details This function calculates the progress percentage based on the current image index, adjusting for the batch and ensuring 
     *          that the progress bar corresponds to 100% when the first image is reached. The width of the progress bar is updated 
     *          accordingly, providing a visual indication of the slideshow's progress.
     *
     * @param   index  The index of the slideshow for which the progress bar needs to be updated.
     *
     * @return  None.
     */
    function updateProgressBar(index) {
        const progressBar = document.getElementById(`progressBar-${index}`);
        // Shift so 0 corresponds to 100%, without an extra offset
        const adjustedIndex = (slideshows[index].currentBatchIndex - 1 + slideshows[index].shuffledImages.length) % slideshows[index].shuffledImages.length;
        const progressPercentage = ((adjustedIndex + 1) / slideshows[index].shuffledImages.length) * 100;
        progressBar.style.width = `${progressPercentage}%`; // Update progress bar width        
    }


    /**
     * @brief   Attempts to change the slide if the image is ready for display.
     *
     * @details This function checks if the image for the current slide is ready. If the image is ready, it proceeds to change the slide 
     *          by calling the `changeSlide` function. If the image is not ready, it increases the attempt count and retries after 50 ms, 
     *          showing an error overlay in the meantime. This prevents the slideshow from advancing until the image has been fully loaded.
     *
     * @param   index  The index of the slideshow where the slide change should occur.
     *
     * @return  None.
     */
     function attemptChangeSlide(index) {  
        if (slideshows[index].imageIsReady) {
            if (slideshows[index].isProcessingQueue) {
              // Stop auto sliding if actions from manual sliding are proccesing
              return;
            }  
            slideshows[index].imageIsReady = false; // Reset the flag to avoid immediate re-calls
            changeSlide(index, 1, false); // Call the function only if the image is ready
            slideshows[index].attempts = 0;
        } else {
            slideshows[index].attempts++;
            showConnectionError(index); // Show the error overlay
            console.log("Retry");
            setTimeout(() => attemptChangeSlide(index), 100); // Retry after 50 ms
        }        
    }


    /**
     * @brief   Displays a connection error overlay with a color-coded message.
     *
     * @details This function manages an overlay message to indicate a connection error during slideshow operation. 
     *          The message color dynamically changes based on the number of attempts to load the image:
     *            - Red: For over 15 auto-attempts or 30 manual attempts.
     *            - Yellow: For more than 5 auto-attempts or 15 manual attempts.
     *            - White: For any attempts greater than 0 but within lower thresholds.
     * 
     *          The overlay is visible for 2 seconds, and any pre-existing timeout is cleared to ensure 
     *          consistent behavior. The function respects the slideshow's `errorFlag`, only displaying the 
     *          message when the flag is set.
     *
     * @param   index  The index of the slideshow instance showing the connection error.
     *
     * @return  None.
     */
    function showConnectionError(index) {
        if(slideshows[index].errorFlag) {
            // Show the overlay
            photoOverlay[index].style.display = '';

            // Set color
            switch (true) {
                case (slideshows[index].attempts > 15):
                case (slideshows[index].manualAttempts > 30):
                    photoOverlay[index].style.color = 'red';
                    break;
                case (slideshows[index].attempts > 5):
                case (slideshows[index].manualAttempts > 15):
                    photoOverlay[index].style.color = 'yellow';
                    break;
                case (slideshows[index].attempts > 0):
                case (slideshows[index].manualAttempts > 5):
                    photoOverlay[index].style.color = 'white';
                    break;
            }

            // Clear any existing timeout
            clearTimeout(slideshows[index].connectionErrorTimeout);

            // Set a new timeout to hide the overlay
            slideshows[index].connectionErrorTimeout = setTimeout(() => {
                photoOverlay[index].style.display = 'none'; // Hide the overlay
                slideshows[index].connectionErrorTimeout = null; // Reset the timeout reference
            }, 2000); // 2000ms = 2 seconds
        }
    }


    /**
     * @brief   Monitors the visibility of slideshow wrapper divs and updates the active slideshow index.
     *
     * @details This function uses the IntersectionObserver API to track when a slideshow wrapper is visible in the viewport.
     *          It triggers an update to the `currentSlideshowIndex` if more than 50% of a wrapper is visible, ensuring 
     *          the active slideshow is only updated when not in fullscreen mode. The highest intersection ratio is tracked 
     *          to determine the most visible wrapper.
     *
     * @return  None.
     */
    function observeVisibleWrappers() {
        const observerOptions = {
            root: null, // Viewport
            rootMargin: '0px',
            threshold: 0.5 // Trigger when 50% of the wrapper is visible
        };

        const observer = new IntersectionObserver((entries) => {
            let mostVisibleIndex = -1;
            let highestIntersectionRatio = 0;

            entries.forEach((entry) => {
                const wrapperId = entry.target.id; // E.g., "slideShow-0", "slideShow-1"
                const index = Number(wrapperId.split('-')[1]); // Extract the index from the ID

                if (entry.isIntersecting && entry.intersectionRatio > highestIntersectionRatio) {
                    mostVisibleIndex = index;
                    highestIntersectionRatio = entry.intersectionRatio;
                }
            });

            // Update the currently visible slideshow index only if not in fullscreen mode
            if (mostVisibleIndex !== -1 && activeFullscreenIndex === null) {
                currentSlideshowIndex = mostVisibleIndex;
            }
        }, observerOptions);

        // Observe all wrapper divs
        const wrapperDivs = document.querySelectorAll('.my-slideshow-wrapper'); // Select all slideshow wrappers
        wrapperDivs.forEach((wrapper) => observer.observe(wrapper));
    }


/*######### Event listeners functions  #########*/

    /**
     * @brief   Creates and inserts a toggle button element into the DOM.
     *
     * @details This function checks if the `mySlideshowContainer` is not empty, 
     *          and then creates a toggle button to switch between different display modes. 
     *          The button is styled and includes an SVG icon. The button is inserted into the document 
     *          body and placed just before a target div with the class `.peak-tag` if it exists.
     *
     * @return  None.
     */
    function createToggleButton() {
        // Check if mySlideshowContainer is not empty
        if (mySlideshowContainer.length > 0) {
            // Find the target div with class 'peak-tag'
            var targetDiv = document.querySelector(".peak-tag");

            // Create the container element
            const container = document.createElement("div");
            container.style.display = "flex";

            // Create content element
            const content = document.createElement("div");
            content.style.flexGrow = "1"; // Allow content to grow and take space

            // Init the button element
            toggleButton = document.createElement("button");
            toggleButton.style.backgroundColor = "#f3891d"; 
            toggleButton.style.borderRadius = "5px"; 
            toggleButton.style.cursor = "pointer"; 
            toggleButton.style.padding = "12px"; 
            toggleButton.style.display = "flex"; 
            toggleButton.style.alignItems = "center"; 
            toggleButton.style.justifyContent = "center"; 
            toggleButton.style.width = "80px"; 
            toggleButton.style.height = "60px"; 

            // Create SVG element
            toggleButton.innerHTML = `
                <svg fill="#000000" width="80px" height="60px" viewBox="0 0 36 36" version="1.1" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                    <g id="SVGRepo_iconCarrier"> 
                        <path d="M32.12,10H3.88A1.88,1.88,0,0,0,2,11.88V30.12A1.88,1.88,0,0,0,3.88,32H32.12A1.88,1.88,0,0,0,34,30.12V11.88A1.88,1.88,0,0,0,32.12,10ZM32,30H4V12H32Z" class="clr-i-outline clr-i-outline-path-1"></path>
                        <path d="M8.56,19.45a3,3,0,1,0-3-3A3,3,0,0,0,8.56,19.45Zm0-4.6A1.6,1.6,0,1,1,7,16.45,1.6,1.6,0,0,1,8.56,14.85Z" class="clr-i-outline clr-i-outline-path-2"></path>
                        <path d="M7.9,28l6-6,3.18,3.18L14.26,28h2l7.46-7.46L30,26.77v-2L24.2,19a.71.71,0,0,0-1,0l-5.16,5.16L14.37,20.5a.71.71,0,0,0-1,0L5.92,28Z" class="clr-i-outline clr-i-outline-path-3"></path>
                        <path d="M30.14,3h0a1,1,0,0,0-1-1h-22a1,1,0,0,0-1,1h0V4h24Z" class="clr-i-outline clr-i-outline-path-4"></path>
                        <path d="M32.12,7V7a1,1,0,0,0-1-1h-26a1,1,0,0,0-1,1h0V8h28Z" class="clr-i-outline clr-i-outline-path-5"></path> 
                        <rect x="0" y="0" width="36" height="36" fill-opacity="0"></rect> 
                    </g>
                </svg>
            `; // Added new SVG to the button's innerHTML

            // Append content and button to the container
            container.appendChild(content);
            container.appendChild(toggleButton);

            // Append the container to the body
            document.body.appendChild(container);

            // Insert the button after the target div
            if (targetDiv) {
                targetDiv.insertAdjacentElement("beforebegin", container);
            } else {
                console.error("Target div not found!");
            }
        }
    }


    /**
     * @brief   Hides all images (both separators and tables) on the page.
     *
     * @details This function hides all images represented by elements with the 
     *          `.separator` class and all tables with the class `.tr-caption-container`.
     *          It checks if the `mySlideshowContainer` is not empty before proceeding.
     *
     * @return  None.
     */
    function hideAllImages() {
        // Check if mySlideshowContainer is not empty
        if (mySlideshowContainer.length > 0) {
            // Find all separators and tables
            const separators = document.querySelectorAll('.separator');
            const tables = document.querySelectorAll('table.tr-caption-container');

            // Set display to 'none' for all separators (images in divs)
            separators.forEach(function(separator) {
                separator.style.display = 'none';
            });

            // Set display to 'none' for all tables (captioned images in tables)
            tables.forEach(function(table) {
                table.style.display = 'none';
            });
        }
    }


    /**
     * @brief   Updates the image quality based on the slider value.
     *
     * @details This function retrieves the quality value from the quality slider for a specific slideshow and updates 
     *          the image quality for all images in the slideshow's buffer. If the quality value is 11, the quality is 
     *          set to the maximum level (`/s0/`). For other values, the quality is adjusted by multiplying the value by 
     *          400 and updating the image source accordingly.
     *
     * @param   index  The index of the slideshow whose image quality needs to be updated.
     *
     * @return  None.
     */
    function updateImageQuality(index) {
        slideshows[index].qualityValue = qualitySliderElement[index].value;
        qualityValueElement[index].textContent = slideshows[index].qualityValue;

        slideshows[index].imageBuffer.forEach(img => {
            // If slideshows[index].qualityValue === 11 set quality to max
            const newQuality = (slideshows[index].qualityValue === '11') ? '/s0/' : `/s${slideshows[index].qualityValue * 400}/`;
            img.src = img.src.replace(/\/s\d+\/|\/w\d+-h\d+\//, newQuality);
        });
    }


    /**
     * @brief   Manages the queuing of manual slide navigation requests.
     *
     * @details This function ensures that manual slide navigation requests are processed sequentially. 
     *          It maintains a queue of requests for each slideshow, enforcing a limit to prevent overload. 
     *          New requests are added to the queue unless the queue is full, and the processing 
     *          of requests starts if it is not already in progress.
     *
     * @param   index      The index of the slideshow for which the manual slide navigation is requested.
     * @param   direction  The direction of the slide navigation (-1 for previous, 1 for next).
     *
     * @return  None.
     */
     function enqueueManualSlide(index, direction) {
        // Initialize callQueue if it doesn't exist yet
        const queue = slideshows[index].callQueue || (slideshows[index].callQueue = []);

        // If the queue already has 5 calls, discard the new request
        if (queue.length >= 5) {
            console.log("Queue is full. Discarding additional requests.");
            return;
        }

        // Add the direction to the queue
        queue.push(direction);

        // Start processing the queue if not already processing
        if (!slideshows[index].isProcessingQueue) {
            processQueue(index);
        }
    }


    /**
     * @brief Processes the call queue for manual slide changes.
     *
     * @details This function checks if the queue for manual slide change requests is empty. 
     *          If not, it sets the slideshow as processing and starts handling queued requests by calling the `checkAndExecute` function.
     *
     * @param index The index of the slideshow for which the queue is being processed.
     *
     * @return None.
     */
    function processQueue(index) {
        const queue = slideshows[index].callQueue;

        // If the queue is empty, mark processing as complete
        if (queue.length === 0) {
            slideshows[index].isProcessingQueue = false;
            return;
        }

        slideshows[index].isProcessingQueue = true;

        // Start checking readiness and processing the queue
        checkAndExecute(index);
    }


    /**
     * @brief Checks if the next queued call can be executed and processes it.
     *
     * @details This function ensures that the current image is ready before executing the next slide change request. 
     *          If the image is not ready, it retries after a short delay. Once a request is processed, it continues to the next 
     *          one in the queue until the queue is empty.
     *
     * @param index The index of the slideshow being processed.
     *
     * @return None.
     */
    function checkAndExecute(index) {
        const queue = slideshows[index].callQueue;

        if (slideshows[index].imageIsReady) {
            slideshows[index].imageIsReady = false;

            // Get the next direction from the queue and execute the slide change
            const direction = queue.shift();
            changeSlide(index, direction, true); // Call the unified slide function with manual=true
            slideshows[index].manualAttempts = 0;

            // After processing the current call, continue with the next one if the queue is not empty
            if (queue.length > 0) {
                checkAndExecute(index);
            } else {
                slideshows[index].isProcessingQueue = false; // Mark processing as complete
            }
        } else {
            // If image is not ready, retry after a short delay
            slideshows[index].manualAttempts++;
            if(slideshows[index].manualAttempts > 5){
                showConnectionError(index); // Show error overlay indicating loading issue
            }
            console.log("M_Retry");
            setTimeout(() => checkAndExecute(index), 100); // Retry every 100ms if the image is not ready
        }
    }


    /**
     * @brief Toggles the visibility of the slider settings and manages auto-hide functionality.
     *
     * @details This function checks the current visibility state of the slider settings container 
     *          and toggles its display. If the settings are shown, it refreshes the auto-hide 
     *          timer to ensure the settings auto-hide after a certain period. If the settings are 
     *          hidden, it clears the auto-hide timer to prevent unnecessary hiding actions.
     *
     * @param index The index of the slideshow for which the slider settings visibility is being toggled.
     *
     * @return None.
     */
    function openSettings(index) {
        const isHidden = sliderContainer[index].style.display === 'none' || sliderContainer[index].style.display === '';
        sliderContainer[index].style.display = isHidden ? 'block' : 'none';
        isHidden ? refreshAutoHide(index) : clearTimeout(slideshows[index].hideTimeout);
    }


    /**
     * @brief   Resets the auto-hide timer for the slider container.
     *
     * @details This function clears any existing auto-hide timeout for the slider container of a specific slideshow 
     *          and sets a new timeout. The slider container will be hidden after 2.5 seconds of inactivity.
     *
     * @param   index  The index of the slideshow whose slider container should be auto-hidden.
     *
     * @return  None.
     */
    function refreshAutoHide(index) {
        clearTimeout(slideshows[index].hideTimeout);
        slideshows[index].hideTimeout = setTimeout(() => sliderContainer[index].style.display = 'none', 2500);
    }


    /**
     * @brief   Updates the fullscreen icons based on the current fullscreen state.
     *
     * @details This function checks whether the document is in fullscreen mode and updates the display 
     *          of the "enter fullscreen" and "exit fullscreen" icons accordingly. The correct icon is shown 
     *          to reflect the fullscreen state of the slideshow.
     *
     * @param   index  The index of the slideshow whose fullscreen icons need to be updated.
     *
     * @return  None.
     */
    function updateFullscreenIcons(index) {
        if (document.fullscreenElement) {
            // In fullscreen mode, show the "exit fullscreen" icon
            enterFullscreenIcon[index].style.display = 'none';
            exitFullscreenIcon[index].style.display = 'block';
        } else {
            // Not in fullscreen mode, show the "enter fullscreen" icon
            enterFullscreenIcon[index].style.display = 'block';
            exitFullscreenIcon[index].style.display = 'none';
        }
    }


    /**
     * @brief   Displays a tooltip for a control button after a short delay.
     *
     * @details This function triggers a delayed display of a tooltip associated with a specific control button. 
     *          It sets a timeout to show the tooltip, ensuring a smooth user experience by only displaying 
     *          the tooltip when the button is hovered over for a sufficient duration.
     *
     * @param   controllButton  The DOM element representing the control button whose tooltip is to be displayed.
     *
     * @return  None.
     */
    function showTooltip(controllButton) {
        controllButton.tooltipTimeout = setTimeout(() => {
            const tooltip = controllButton.querySelector('.tooltip');
            tooltip.style.display = 'block'; // Make the tooltip visible
            tooltip.style.opacity = '1';    // Apply fade-in effect
        }, 300); // Delay in milliseconds before showing the tooltip
    }


    /**
     * @brief   Hides the tooltip for a control button with a fade-out effect.
     *
     * @details This function cancels any pending tooltip display timeout and applies a fade-out animation 
     *          to the tooltip. Once the fade-out animation is complete, the tooltip is hidden to ensure 
     *          a seamless user interface interaction.
     *
     * @param   controllButton  The DOM element representing the control button whose tooltip is to be hidden.
     *
     * @return  None.
     */
    function hideTooltip(controllButton) {
        clearTimeout(controllButton.tooltipTimeout); // Cancel pending tooltip display
        const tooltip = controllButton.querySelector('.tooltip');
        tooltip.style.opacity = '0'; // Trigger fade-out effect
        setTimeout(() => {
            tooltip.style.display = 'none'; // Hide tooltip after fade-out completes
        }, 300); // Duration of the fade-out effect in milliseconds
    }


    /**
     * @brief   Handles both single and double-click actions on the slideshow.
     *
     * @details This function distinguishes between single and double-click events on the slideshow.
     *          If a double-click is detected (within a defined time threshold), it triggers a double-click action, 
     *          such as toggling the fullscreen mode. If a single-click is detected, it triggers the appropriate 
     *          single-click action, such as clicking a specific button for the slideshow.
     *
     * @param   index  The index of the slideshow that the click action applies to.
     *
     * @return  None.
     */
    function handleClick(index) {
        slideshows[index].currentTime = Date.now(); // Get current time in milliseconds
        // Check if the time between clicks is less than the threshold for double-click
        if (slideshows[index].currentTime - slideshows[index].lastClickTime <= doubleClickThreshold) {
            // Clear the single-click action timer, if any, as the double-click takes precedence
            if (slideshows[index].clickTimer) {
                clearTimeout(slideshows[index].clickTimer);
                slideshows[index].clickTimer = null; // Reset the click timer
            }
            // Call your double-click function here (toggle fullscreen)
            toggleFullscreen(index);
        } else {
            // Set a timer to perform the single-click action after the double-click threshold
            slideshows[index].clickTimer = setTimeout(() => {
                // Perform the single-click action, like clicking the button
                document.getElementById(`toggleSlideshowButton-${index}`).click();
            }, doubleClickThreshold);
        }

        // Update last click time for this slideshow
        slideshows[index].lastClickTime = slideshows[index].currentTime;
    }


    window.addEventListener('DOMContentLoaded', () => {
        // Call functions for creating buttons and hiding images
        createToggleButton();
        hideAllImages();

        numberOfSlideshows.forEach(index => {
            qualitySliderElement[index].addEventListener('input', () => { updateImageQuality(index); updateSliderColor(index); });
            speedSliderElement[index].addEventListener('input', () => updateSlideshowSpeed(index));
            toggleSlideshowButton[index].addEventListener('click', () => slideshows[index].isSlideshowRunning ? pauseSlideshow(index, SLIDESHOW_VISIBLE) : resumeSlideshow(index, SLIDESHOW_VISIBLE));
            previousPhoto[index].addEventListener('click', () => enqueueManualSlide(index, -1));  // Attach event listeners with the enqueue function
            nextPhoto[index].addEventListener('click', () => enqueueManualSlide(index, 1));       // Attach event listeners with the enqueue function
            toggleNavigationButton[index].addEventListener('click', () => toggleNavigation(index));
            settingsButton[index].addEventListener('click', () => openSettings(index));
            fullscreenButton[index].addEventListener('click', () => toggleFullscreen(index));
            sliderContainer[index].addEventListener('mouseenter', () => clearTimeout(slideshows[index].hideTimeout));
            sliderContainer[index].addEventListener('mouseleave', () => refreshAutoHide(index));
            autoQualityCheckbox[index].addEventListener('change', () => autoSetQuality(index));
            preloadAllButton[index].addEventListener('click', () => preloadAllImages(index));
            toggleButton.addEventListener('click', () => toggleSlideshowOrImageVisibility(index));
        })

        document.addEventListener('fullscreenchange', () => { for (let index = 0; index < slideshows.length; index++) { updateFullscreenIcons(index); } });
        document.addEventListener('visibilitychange', () => { for (let index = 0; index < slideshows.length; index++) { document.visibilityState === 'hidden' ? pauseSlideshow(index, SLIDESHOW_HIDDEN) : resumeSlideshow(index, SLIDESHOW_HIDDEN); } });

        // Add event listeners for mouse enter and leave on control buttons
        controllButton.forEach(button => {
            button.addEventListener('mouseenter', () => showTooltip(button));
            button.addEventListener('mouseleave', () => hideTooltip(button));
        });      
    });


    // Onload event
    window.addEventListener('load', function () {
        numberOfSlideshows.forEach(index => {
            fetchData(index);
            updateSlideshowSpeed(index); // Initialize the speed on load for each slideshow

            // Check slideshow readiness after the window is fully loaded
            checkAndInitialize(index); // Start checking if the slideshow is ready and initialize once done
        });
    });

    
    // Onresize event
    window.onresize = () => {
                numberOfSlideshows.forEach(index => {
                    autoSetQuality(index);  // Call updateSliderColor for each slideshow or if auto selected also resize images
                });
            };
